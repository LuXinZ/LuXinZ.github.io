<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="变量， 范围， 和 内存primitive 原始值 和 reference values 引用值 变量中包含两种不同的类型数据 原始值 就是简单的数据，基本数据类型 引用值： 就是由多个值组成的对象   将数据值分配给一个变量之后，JS 必须要确定他的数据类型是原始值还是引用值。 六个原始&#x2F;基本类型 ： undefined ，null , boolean, string, number, symb">
<meta property="og:type" content="article">
<meta property="og:title" content="JS 高级程序设计 读书笔记">
<meta property="og:url" content="2020/02/06/JS%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="变量， 范围， 和 内存primitive 原始值 和 reference values 引用值 变量中包含两种不同的类型数据 原始值 就是简单的数据，基本数据类型 引用值： 就是由多个值组成的对象   将数据值分配给一个变量之后，JS 必须要确定他的数据类型是原始值还是引用值。 六个原始&#x2F;基本类型 ： undefined ，null , boolean, string, number, symb">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-02-05T16:27:57.000Z">
<meta property="article:modified_time" content="2020-02-08T15:46:15.247Z">
<meta property="article:author" content="Luxin Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="LuXinZ.github.io/2020/02/06/JS 高级程序设计 读书笔记/"/>





  <title>JS 高级程序设计 读书笔记 | 个人博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" target="_blank"  class="brand" rel="start noopener">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每日笔记</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" target="_blank" rel="section noopener">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" target="_blank" rel="section noopener">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/06/JS 高级程序设计 读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JS 高级程序设计 读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-06T00:27:57+08:00">
                2020-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="变量，-范围，-和-内存"><a href="#变量，-范围，-和-内存" target="_blank" rel="noopener" class="headerlink" title="变量， 范围， 和 内存"></a>变量， 范围， 和 内存</h1><h2 id="primitive-原始值-和-reference-values-引用值"><a href="#primitive-原始值-和-reference-values-引用值" target="_blank" rel="noopener" class="headerlink" title="primitive 原始值 和 reference values 引用值"></a>primitive 原始值 和 reference values 引用值</h2><ul>
<li>变量中包含两种不同的类型数据<ul>
<li>原始值 就是简单的数据，基本数据类型</li>
<li>引用值： 就是由多个值组成的对象</li>
</ul>
</li>
<li>将数据值分配给一个变量之后，JS 必须要确定他的数据类型是原始值还是引用值。</li>
<li>六个原始/基本类型 ： undefined ，null , boolean, string, number, symbol,<ul>
<li>这些变量是按值访问的，因为你正在操作的就是存储在变量中的实际值</li>
</ul>
</li>
<li>引用值是储存在内存的对象，JS 不允许直接访问内存的位置，一年春不允许直接操作对象的内存空间。当你操作一个对象时候，你实际上是对该对象的引用进行操作，而不是实际的对象本身，因此，可以说这些值是通过引用访问的。<h3 id="Dynamic-properties-动态属性"><a href="#Dynamic-properties-动态属性" target="_blank" rel="noopener" class="headerlink" title="Dynamic properties 动态属性"></a>Dynamic properties 动态属性</h3>原始值和引用值的定义类似：当一个变量创建后并为其分配值。但是执行的操作却大不相同，使用引用值的时候，可以随时添加，更改或者删除属性的方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'Jack'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
这里，创建了一个对象，并存储到变量person 中，接下来，为这个对象添加了一个名为name 的属性，并且为其分配了字符串Jack.从现在起，就可以访问新属性了，知道对象被销毁，或者属性明确地移除<br>但是，原始值不能添加属性，即使这样做不会报错<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Nicholas"</span>; </span><br><span class="line">name.age = <span class="number">27</span>; </span><br><span class="line"><span class="built_in">console</span>.log(name.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
这里，在字符串name定义了一个age 属性，并且为其赋值27，。但是在下一行，属性不存在。<br>所以只有引用值可以定义属性供以后使用。<br>注意： 原始类型的实例化可以使用基本文字形式。如果要是用new关键字，JS 将创建一个Object类型，但是这个行为类似于基本。<br>这是例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">'Jack'</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Matt'</span>)</span><br><span class="line">name1.age = <span class="number">27</span>;</span><br><span class="line">name2.age = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age) ; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age) ; <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1) <span class="comment">// String</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2) <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
可以看出，new之后， 将会变为对象<h3 id="Copying-Values-复制值"><a href="#Copying-Values-复制值" target="_blank" rel="noopener" class="headerlink" title="Copying Values 复制值"></a>Copying Values 复制值</h3>除了存储方式不同之外，原始值和引用值在从一个变量复制到另一个变量时的作用也不同。将原始值从一个变量分配给另一个变量时，值储存在变量对象被创建和复制到新变量的位置。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num1 &#x3D; 5;</span><br><span class="line">let num2 &#x3D; num1;</span><br></pre></td></tr></table></figure>
这里，num1的值是5，当num2 初始化为num1 时，它也获得值5。该值与num1中存储的值完全分开。因为这是那个值的复制。<br>现在每个值都可以单独使用，而没有副作用<br>当引用值从一个变量分配给另一个变量的时候，存储在变量对象上的值也会复制到新变量的位置。区别在于该值实际上是指向在对象存储的堆。一旦操作完成了，两个变量指向完全相同的对象。因此对一个变量的更改会反应在另一个变量上。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.name= <span class="string">'Jack'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name) <span class="comment">// 'Jack'</span></span><br></pre></td></tr></table></figure>
变量boj1 填充到了一个new 实例的对象中，然后将值赋值到obj2,这意味着两个变量都指向相同的对象。当属性名设置在obj1上，这个属性可以从obj2上进行访问，因为他们指向相同的对象。<h3 id="Argument-Passing-参数传递"><a href="#Argument-Passing-参数传递" target="_blank" rel="noopener" class="headerlink" title="Argument Passing  参数传递"></a>Argument Passing  参数传递</h3>JS 中所有函数的参数均是按值传递。这意味着将函数外部的值复制到函数内部的参数中，就像值从一个变量复制到另一变量中。如果值是是原始值，则其行为就像是基本变量的拷贝，如果值是引用值，则其行为就像是引用变量的拷贝。因为变量既可以通过值和引用访问，但是参数只能通过值传递。<br>当参数通过值传递，该值将被复制到局部变量 local variable。当参数通过引用传递，值在内存中的位置是存储在局部变量中，这意味着对局部变量的更改将将反应在函数的外部<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log (count) <span class="comment">// 20 - no change</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
在这里，函数addTen() 有一个参数 num, 这是个局部变量。当调用时，这个变量count作为参数传递。，此变量的值是20，将其赋值到参数num 中然后在addTen() 内部使用。在函数中，参数num的值通过加10进行了更改，但是它没有更改函数外部存在的原始的变量。参数num 和变量 variable 无法互相识别，他们恰巧有相同的价值。如果num 通过引用传递，然后count的值将更改为30，以反映在函数内部所做的更改。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'jack'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person)</span><br><span class="line">consol.log(person.name) <span class="comment">// jack</span></span><br></pre></td></tr></table></figure>
在此代码中，将创建一个对象并储存在变量person 中，然后将对象传递到setName() 方法中，然后将其赋值到obj中。在函数内部，obj和person 都是指向相同的对象、结果是obJ是引用来访问对象的，即使他通过值传递到函数中。 当name属性被设置到函数内部的obj中，此更改将反应在函数的外部。因为它指向的对象存在堆中的全局。当全局更改反应到对象的局部更改时，这意味着参数已经通过引用传递了。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'jack'</span></span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    obj.name = <span class="string">'Rose'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 'Jack'</span></span><br></pre></td></tr></table></figure>
这个例子中与上一个例子中的唯一变化是，在setName() 中添加了两行，将obj重新定义为新的对象并且带有不同的name。当person将值传递到setName() 中，其中的name属性被设置为jack.然后变量obj被设置为新的对象，并且他name的属性被设置Rose。 如果person通过引用传递，这个person将会自动指向Rose的对象。但是当再次访问person.name的时候，这个值还是Jack。这表明，即使参数的值在函数内部更改了，原始引用值仍然保持不变。当obj在函数被覆盖，他将会变成指针指向局部对象。函数执行完成后，这个局部对象会被销毁。<h3 id="Determining-Type-确定类型"><a href="#Determining-Type-确定类型" target="_blank" rel="noopener" class="headerlink" title="Determining Type  确定类型"></a>Determining Type  确定类型</h3>typeof 是确定原始数据类型的最佳方法，但是只是string，number,boolean, undefined. 这些类型<br>如果值是object 和null ，则会返回object、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'Jack'</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>  <span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> u;  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>   <span class="comment">// object</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);   <span class="comment">// string </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i);   <span class="comment">// number </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);   <span class="comment">// boolean console.log(typeof u);   // undefined </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n);   <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o);   <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
尽管typeof 用于原始数据类型，但是很少用于引用数据类型。<br>如果想知道他是什么类型的对象， JS 中提供了instanceof 运算符<br>语法：<br>result = variable  instanceof constructor<br>instanceof 会返回一个true 如果这个变量是给定引用类型give reference type <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// person 是不是对象</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// color 是不是数组</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="comment">// pattern 是是不是正则</span></span><br></pre></td></tr></table></figure>
根据定义，所有引用值都是Object的实例。因此instanceof运算符与引用值和Object构造函数一起一起使用时始终返回true。 同样，如果 instanceof 使用的是基本类型值，它会返回false,因为基本值不是对象<br>当在函数上用typeof的时候会返回function。 <h2 id="EXECUTION-CONTEXT-AND-SCOPE-执行上下和作用域"><a href="#EXECUTION-CONTEXT-AND-SCOPE-执行上下和作用域" target="_blank" rel="noopener" class="headerlink" title="EXECUTION CONTEXT AND SCOPE 执行上下和作用域"></a>EXECUTION CONTEXT AND SCOPE 执行上下和作用域</h2>执行上下文，简称上下文，在JS 中至关重要。变量和函数的执行上下文定义了它可以访问的其他数据和其执行方式。每个执行上下文都有一个关联的变量对象，其所有定义的变量和函数都存在于该对象上。这个对象无法通过代码访问，但在后台被用于处理数据。<br>全局上下文是最外部的上下文。根据JS事先的主主机环境，表示此上下问的对象可能不同。在浏览器中，全局上下文是被称为window 的对象。所以使用var定义的所有全局变量和函数都被作为属性和方法创建在window 对象上。<br>声明使用let和const 在最顶层不会被定义在全局上下文中。但是他们在作用域脸上的解析方式相同。当执行上下文执行完所有代码后，他就会销毁，并且带走其定义的所有变量和函数（全局上下文不会被销毁除非应用程序退出，例如关闭网页和关闭应用程序的时候）<br>每个函数调用自己的执行上下文。每当代码执行流入函数中，函数的上下文就会被推送到上下文堆中。函数执行完成后，堆就会弹出，并且返回控制权到上一个执行上下文。这个功能通过ESMC的程序控制执行流程<br>当代码被执行在上下文中，将创建变量对象的作用域链。作用域链的目的提供对执行上下中有权访问的所有变量和函数进行有序访问。作用域链的前端始终是代码正在执行的上下文的变量对象、如果上下文是函数，就会激活对象用作变量对象。激活对象以一个定义为参数的变量开始。（这对于全局上下文不存在）。链中的下一个变量对象来自包含上下文，而其后的下一个变量对象来自下一个包含上下文。这种模式一直持续到全局上下文找到。全局上下文变量对象一直是作用域链中的最后一个。<br>通过导航作用域链以搜索标识符名称来解析标识符。搜索始终从链的最前面开始，一直进行到最后，直到标识符被找到（如果找不到标识符通常会发生错误。）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (color ===<span class="string">'blue'</span>)&#123;</span><br><span class="line">        color = <span class="string">"red"</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        color = <span class="string">"blue"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor()</span><br></pre></td></tr></table></figure>
函数changeColor()的作用域链包含了两个对象在里面：他自己的变量对象（在其上定义了参数对象）。和全局作用域变量对象、这个变量color是可以在函数内部访问的，因为他可以在作用域链中找到。<br>此外，局部定义变量可以用来与全局变量交换在局部上线文中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> anotherColor =<span class="string">"red"</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor</span><br><span class="line">        <span class="comment">// color, anotherColor, and tempColor are all accessible here </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// color and anotherColor are accessible here, but not tempColor swapColors();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only color is accessible here </span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
此代码包含了三个执行上下文：全局上下文，局部上下文changeColor() , 和局部上下文swapColor()、全局上下文有一个变量，color和一个函数。changeColor(). 局部上下文changeColor() 有一个变量anotherColor 和一个函数命名文swapColor(),但它依然可以访问变量color 从全局上下文中。局部上下文swapColro() 有一个变量tempColor， 它只能在该上下文中访问。无论是全局上下文或者局部上下文swapColors() 都无法访问到tempcolor。 但是，在swapColors() 中，其他两个上下文中的变量是完全可以访问的。因为他是父执行上下文、<br>在这个表格中。矩形代表特定的执行上下文。内部上下文可以访问所有外部上下文中的所有内容通过作用域链。但是外部上不可以访问任何在内部上下文中的内容。这个链接有线性的并且有秩序的。每个上下文可以搜索作用域链中的变量和函数，但是没有上下文可以向下索索作用域链中的另一个执行上下文。作用域链中局部上下文swapColors存在三个对象: swapColors() 变量对象，变量对象来自changeColor() 和 全局变量对象。swapColors() 的局部上下文开始寻找变量和函数名称在它自己变量对象中，在沿着链前进之前。changeColor() 的上下文的作用域链只有两个对象： 是自己变量对象和全局变量对象。这意味着它无法访问swapColor() 的上下文、<br>函数参数被视为变量，并且和其他变量在执行上下文中有相同的访问规则<h3 id="Scope-Chain-Augmentatio-延长作用域链"><a href="#Scope-Chain-Augmentatio-延长作用域链" target="_blank" rel="noopener" class="headerlink" title="Scope Chain Augmentatio 延长作用域链"></a>Scope Chain Augmentatio 延长作用域链</h3>即使执行环境只有两种主要类型：即全局和函数（第三种存在于eval()的调用内），但是还有其他的途径扩展作用域链。某些语句可以在作用域链的连段临时增加一个变量对象，，然后在代码执行后移除此变量对象。有两种情况会发生这种现象，特别是当执行进入以下任意情况时：<br>try-catch 语句中的catch块。<br>with 语句<br>这两个语句豆浆一个变量对象添加到作用域链的最前端。对于with语句，将指定的对象添加到租用与链。对于catch语句，将创建一个新的变量对象并且包含引发错误对象的声明。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function buildUrl()&#123;</span><br><span class="line">    LET qs&#x3D; &quot;?debug&#x3D;true&quot;</span><br><span class="line">    whit(location)&#123;</span><br><span class="line">        let url &#x3D; href + qs</span><br><span class="line">    &#125;</span><br><span class="line">    return url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
whit 语句作用域 location 对象，所以location本身被添加到作用域的前面。buildURL()函数中定义了一个变量qs。当在with语句中引用变量href时候，引用的是location.href。当变量qs被引用的时候，引用的是正在buildUrl()中的定义的变量，该变量在函数环境的变量对象中。在with语句背部，则声明了一个url变量，这个变量成为了函数环境的一个部分，因此可以作为函数的值返回<h3 id="变量声明"><a href="#变量声明" target="_blank" rel="noopener" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="Function-Scope-Declaration-Using-var-使用var的函数声明范围"><a href="#Function-Scope-Declaration-Using-var-使用var的函数声明范围" target="_blank" rel="noopener" class="headerlink" title="Function Scope Declaration Using var 使用var的函数声明范围"></a>Function Scope Declaration Using var 使用var的函数声明范围</h4>使用var声明变量的时候，他会自动的添加到可用的最接近的环境中。在函数中，最近接的环境就是函数局部环境。在with语句中，最接近的就是函数韩静。如果初始化的时候没有事先声明变量，则该变量会自动添加到全局环境中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 无效变量错误</span></span><br></pre></td></tr></table></figure>
这里，函数add()定义了一个局部变量sum， 其中包含了加法的运算结果。虽然结果从函数值返回了，但是变量sum不是可以在函数外部访问的。如果var 这个关键字被省略掉，sum就会变成可以在add()执行完毕后，可以访问的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    sum = num1+ num2</span><br><span class="line">    <span class="keyword">return</span> sum </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">//30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 3-</span></span><br></pre></td></tr></table></figure>
变量sum被初花一个值，但是并没有使用关键字var进行声明。调用add()的时候，sum在全局环境中创建，并且即使代码执行完毕后，也可以在之后的代码中访问<br>在严格模式下，初始化未经声明的变量会导致错误<br>var 声明将置于函数或者全局作用域的顶部，并且位于其中的任何现有代码之前。这种被称为hoisting， 提升。这允许你安全的使用提升的函数在作用域的任何地方，而不需要考虑是否声明了。但是，实际上，这会导致合法但奇怪的代码，其中在变量声明之前就是使用了该变量。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span></span><br><span class="line"><span class="comment">// 等同于 :</span></span><br><span class="line">name = <span class="string">'jack'</span></span><br><span class="line"><span class="keyword">var</span> name</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'jake'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    name = <span class="string">'Jake'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是可以通过在变量声明之前检查自己的变量是否被提升了。你会看到undefined而不是ReferenceError<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'jake'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'jake'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Block-Scope-Declaration-Using-let-使用let的块级声明"><a href="#Block-Scope-Declaration-Using-let-使用let的块级声明" target="_blank" rel="noopener" class="headerlink" title="Block Scope Declaration Using let 使用let的块级声明"></a>Block Scope Declaration Using let 使用let的块级声明</h4>let可以和var相同的方式进行操作，但是它的作用域是块级的。块级作用域的概念是最接近的一组大括号{}。这意味着，if快，while块，function块，甚至独立快将成为用let声明的任何变量的范围。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//  报错，ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//  ReferenceError: b is not defined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">//  ReferenceError: c is not defined,，这个var 也会引发错误</span></span><br><span class="line"><span class="comment">// 这不是对象文字，这是一个独立的快</span></span><br><span class="line"><span class="comment">// js会基于内容识别</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> d</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// ReferenceError: d is not defined</span></span><br></pre></td></tr></table></figure>
与var的行为类似，不能再同一范围内两次声明let。重复的var声明将被忽略，宠物的let声明会引发语法错误syntaxError<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// no errors thrown</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 语法错误： SyntaxError: identifier b has already been declared</span></span><br></pre></td></tr></table></figure>
当在循环体中使用迭代器，let的行为特别有用、使用var的声明迭代器完成后外流循环。这种行为是非常不好的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span> ;j++&gt;)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(j) <span class="comment">// ReferenceError, J没有定义</span></span><br></pre></td></tr></table></figure>
let 在JS中运行的时候是技术提升的。但是由于存在临时性四驱。因此无法使用该变量在其声明的上方。因此let 与 var 的提升方式不同。<h4 id="Constant-Declaration-Using-const-使用const的常量声明"><a href="#Constant-Declaration-Using-const-使用const的常量声明" target="_blank" rel="noopener" class="headerlink" title="Constant Declaration Using const 使用const的常量声明"></a>Constant Declaration Using const 使用const的常量声明</h4>ES6 还引入了const 作为陪伴let，使用const声明的变量必须初始化为某个值。一次声明后，就不能重新分配给新的值了在其声明周期的任何时候。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="comment">//  报错，缺少初始化。</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 3</span></span><br><span class="line">b= <span class="number">4</span> <span class="comment">// TypeError: Assignment to a constant variable</span></span><br></pre></td></tr></table></figure>
除了执行const 规则外，const变量行为与let 一样<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;  <span class="keyword">const</span> a = <span class="number">0</span>; &#125; <span class="built_in">console</span>.log(a);  <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="keyword">const</span> b = <span class="number">1</span>; &#125; <span class="built_in">console</span>.log(b);  <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">const</span> c = <span class="number">2</span>; &#125; <span class="built_in">console</span>.log(c);  <span class="comment">// ReferenceError: c is not defined</span></span><br><span class="line"> </span><br><span class="line">&#123;  <span class="keyword">const</span> d = <span class="number">3</span>; &#125; <span class="built_in">console</span>.log(d);  <span class="comment">// ReferenceError: d is not defined</span></span><br></pre></td></tr></table></figure>
const 声明仅适用于处于顶级的基本类型和对象。换句话说，const变量不能将分配给对象的值重新分配给另一个殷涌智，但是该对象内部的键值不受到保护、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 =&#123;&#125;</span><br><span class="line">o1 = &#123;&#125; <span class="comment">// TypeError: Assignment to a constant variable;</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125; </span><br><span class="line">o2.name = <span class="string">'jake'</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.name)  <span class="comment">// jake</span></span><br></pre></td></tr></table></figure>
如果希望整个对象都变的不可以更改，可以使用Object.freeze，尽管尝试分配属性不会引发错误；他只会默默的失败<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;)</span><br><span class="line">o3.name = <span class="string">'jake'</span></span><br><span class="line"><span class="built_in">console</span>.log(o3.name) ; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
由于const 声明暗示该值是单一类型且不可变的。因此JS 运行编译器时候可以用实际值替换其所有势力，而不用通过变量表查询该变量。V8引擎执行了这样的优化。<h4 id="Identifier-Lookup-标识符查询"><a href="#Identifier-Lookup-标识符查询" target="_blank" rel="noopener" class="headerlink" title="Identifier Lookup 标识符查询"></a>Identifier Lookup 标识符查询</h4>挡在某个环境中为了读取或写入而引用一个标志服，必须通过搜索一确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字相匹配的标识符。如果它在局部连梁中找到了该标识符名称，则搜索就会停止并且设置该变量。如果搜索不到这个变量名字，他会继续沿着作用链向上搜索。（请注意，作用域链中的对象也是具有原型链的，因此搜索可能会包含每个对象的原型链）此过程一直寻找到全局环境的变量对象位置，如果在在此找不到标识符，则说明尚未声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
当调用函数getColor（） 的时候，将引用变量color。此时，将会开始两步搜索。第一步getColor() 的变量对象中搜索一个包含名为color 的标识符。 当找不到该对象的时候，将搜索（从全局环境中）到下一个变量对象，然后在那里找到了名为color 的标识符。因为在该变量对象中定义了颜色，所以搜索结束。<br>在此搜索过程中，引用局部变量自动会停止搜索，不在进入另一个变量对象。这意味着，如果局部环境中的标识符存在相同的名称，则无法引用位于父环境中的标识符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">'red'</span></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">// red</span></span><br></pre></td></tr></table></figure>
使用块级域声明不会改变搜索进程，但是会为为词汇层次结构添加额外的级别。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">'red'</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> color = <span class="string">'green'</span></span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">// green</span></span><br></pre></td></tr></table></figure>
在此修改后的代码中，在getColor() 函数中声明的名为color局部变量，在调用函数的时候，这个变量会被声明。当函数的第二行执行的时候，它知道命名为color的变量必须被使用。搜索从局部环境开始，在找到变量名称为color，值为green。因为找到了变量，所以这个搜索停止了，并且这个局部变量被使用了，这意味着这个函数会返回green。任何位于局部变量color声明之后的代码都不能将都不能访问全局color 变量如果限定其使用window.color。如果一个操作数是一个对象，而另一个不是、valueOf() 方法会被调用，以检索原始值的方法根据原先的规则。<h2 id="Garbage-Collection-垃圾收集"><a href="#Garbage-Collection-垃圾收集" target="_blank" rel="noopener" class="headerlink" title="Garbage Collection 垃圾收集"></a>Garbage Collection 垃圾收集</h2>JS 具有垃圾收集的语言。，这意味着操作环境会负责管理代码执行期间所需要的内存。而在C和C++ 语言中，跟踪内存的使用是一个主要问题，开发人员的一项基本任务就是手工跟踪内存的使用情况。JS 通过自动分配所需的内容并回收不在使用的内存，使得开发人员不必担心内存管理。这种原理很简单：找出将不在使用的变量，释放与其关联的内存。此过程是周期性的，垃圾收集器以指定的时间间隔（或在代码执行中预定义收集时候）运行。垃圾回收的过程是一个近似且不完善的解决方案，因为知道知道是否需要某些内存的一般问题是不确定的，这意味着无法用算法解决。<br>考虑函数中局部变量的正常声明周期。该变量值在函数执行的过程中存在，那时，内存在堆（可能是栈）内存分配，以提供一个该值的储存空间。这个变量被使用在函数内部，然后函数结束。此时，不需要此变量，因为可以回收其内存以供以后使用。在这种情况下，显然不需要该变量。但是并非所有情况都是这样显而易见。垃圾收集器必须跟踪那些变量可以使用那些不可以使用，对不在有用的变量打上标记，以备将来收回其占用的内存。尽管传统上的浏览器使用了连个中策略：用于标识未使用的变量的策略可能会因事先方式而有所不同。但是这些策略通常是 mark-and-sweep 标记清除 和 reference counting 引用计数<h3 id="Mark-and-Sweep-标记清除"><a href="#Mark-and-Sweep-标记清除" target="_blank" rel="noopener" class="headerlink" title="Mark-and-Sweep  标记清除"></a>Mark-and-Sweep  标记清除</h3>JS 中最受欢迎的垃圾回收是标记清除。当变量进入到环境中，例如变量在函数中声明，会将其标记在环境中。从逻辑上讲，环境中的变量永远都不应该释放内存，继续使用它就会可能会在环境中继续执行，当变量离开环境，他也会被标记上脱离环境。<br>可以使用多种方式来标记变量，可以通过反转某个特殊的位来记录变量何时进入了环境。或者在使用一个进入环境的变量列表以及离开环境的变量列表。标记的实现并不重要，关键是理论。、<br>当垃圾收集器运行的时候，它将标记存储在内存中的所有变量（可以使用任何标记方式），然后它将清除环境中的变量和被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将会被视为删除的变量，原因是环境中的变量已经无法访问他们了。然后垃圾收集器完成内存清除工作，销毁那些标记的值并且回收他们所占用的内存空间。<br>从2008年开始，尽管垃圾回收的是时间不同，但是浏览器在其JS 中都使用了标记清除式的垃圾收集策略。<h3 id="Reference-Counting-引用计数"><a href="#Reference-Counting-引用计数" target="_blank" rel="noopener" class="headerlink" title="Reference Counting 引用计数"></a>Reference Counting 引用计数</h3>未完成 163 页<h3 id="Performance"><a href="#Performance" target="_blank" rel="noopener" class="headerlink" title="Performance"></a>Performance</h3>未完成163 页<h3 id="Managing-Memory"><a href="#Managing-Memory" target="_blank" rel="noopener" class="headerlink" title="Managing Memory"></a>Managing Memory</h3>未完成164页<h4 id="Performance-Boosts-with-const-and-let-Declarations"><a href="#Performance-Boosts-with-const-and-let-Declarations" target="_blank" rel="noopener" class="headerlink" title="Performance Boosts with const and let Declarations"></a>Performance Boosts with const and let Declarations</h4>在ES6中引入这些关键字不仅对代码风格有好处，而且对垃圾收集过程也有好处。因为const 和let 的作用域是块而不是函数，所以根据代码的组织方式，这可能会对垃圾回收器发出信号，表明已经分配的变量是符合清除的资格，相对于使用var的时候来说。当会计作用域远早于函数作用域终止时，就会发生这种情况<h4 id="Hidden-Classes-and-the-delete-Operation-隐藏类和删除操作"><a href="#Hidden-Classes-and-the-delete-Operation-隐藏类和删除操作" target="_blank" rel="noopener" class="headerlink" title="Hidden Classes and the delete Operation 隐藏类和删除操作"></a>Hidden Classes and the delete Operation 隐藏类和删除操作</h4>根据您希望JS 运行的位置，有时候值得考虑基于浏览器使用JS引擎的各种性能影响。V8利用隐藏类，当接收后的JS便以为实际的机器代码，如果正在编写对性能很敏感的代码，很重要<br>在运行的时候，V8将关联隐藏的类在对象创建之后，并且跟踪其属性的形状、对象是能够共享相同的隐藏的类会有更高的性能，v8将会对此优化但是并非总是如此<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'Hello'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article()</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article()</span><br></pre></td></tr></table></figure>
在后台，V8将配置两个类实例共享相同的隐藏的类。这是有道理的，因为他们共享一个构造函数和原型。假设将一下代码添加到此代码的末尾。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.author &#x3D; &#39;jake&#39;</span><br></pre></td></tr></table></figure>
现在这两个Article 实例将具有两个不同的隐藏类事项。根据此操作的频率和隐藏类的大小，这可能会对性能产生重要的影响<br>解决方案当时避免分配JS 的ready-fire-aim动态属性，而是在构造函数中声明所有属性。若夏<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'Hello'</span></span><br><span class="line">    <span class="keyword">this</span>.author = opt_author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br></pre></td></tr></table></figure>
现在，这两个实例的行为基本上是相同的（不计算hasOwnProperty的返回值），并且他们还将共享一个隐藏的类，从而有可能提高性能。请记住，尽管使用delete关键字可以生成相同的隐藏类碎片。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'Hello'</span></span><br><span class="line">    <span class="keyword">this</span>.author = <span class="string">'jake'</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">delete</span> a1.author</span><br></pre></td></tr></table></figure>
在此代码端的结尾，即使两个实例使用同一的构造函数，那么他们也不再共享隐藏的类。动态删除属性将产生于动态添加相同的效果。最佳做法要求将不需要的属性设置为null，它将允许隐藏的类保存原样和共享，并且对于删除引用具有相同的作用，以便使垃圾回收器收益。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'hello'</span></span><br><span class="line">    <span class="keyword">this</span>.author = <span class="string">'jake'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1= <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article()</span><br><span class="line">a1.author =<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h4 id="Memory-Leaks-内存泄露"><a href="#Memory-Leaks-内存泄露" target="_blank" rel="noopener" class="headerlink" title="Memory Leaks 内存泄露"></a>Memory Leaks 内存泄露</h4>未完成 166 页<h4 id="Static-Allocation-and-Object-Pools-Static-Allocation-and-Object-Pools"><a href="#Static-Allocation-and-Object-Pools-Static-Allocation-and-Object-Pools" target="_blank" rel="noopener" class="headerlink" title="Static Allocation and Object Pools Static Allocation and Object Pools"></a>Static Allocation and Object Pools Static Allocation and Object Pools</h4>未完成167页 <h3 id="Summary"><a href="#Summary" target="_blank" rel="noopener" class="headerlink" title="Summary"></a>Summary</h3>可以在JS 变量中存储两种类型的值，基本值和引用值。基本值有六个：undefined， null ， string , number, symbol,boolean.</li>
<li>基本值和引用值有如下特征<ul>
<li>基本值是固定大小的，因此存储在堆内存中。</li>
<li>将基本值从一个变量赋值到另一个变量，将创建这个值的第二个拷贝。</li>
<li>引用值是对象，储存在堆内存中。</li>
<li>包含引用值的变量世纪上仅包含指向对象的指针，不包含对象本身</li>
<li>将引用值复制到另一个变量仅仅复制指针，因此两个变量最终都引用同一对象。</li>
<li>typeof 运算符确定值的原始类型，而instanceof运算符用于确定值的引用类型</li>
</ul>
</li>
<li>所有变量（）都存在于操作环境中（也叫做作用域），环境确定变量生命周期和那些代码可以访问它。操作环境可以总结如下：<ul>
<li>操作环境存在全局，成为全局环境，在函数内部和块内部</li>
<li>每次进入新的操作环境中，它都会创建一个作用域链以搜索变量和函数</li>
<li>函数或者块级不仅可以访问作用域中变量还可以访问任何包含环境和全局环境的变量在环境中、</li>
<li>全局环境只能访问变量或者函数在全局环境，不能直接访问数据在任何局部环境中</li>
<li>变量的操作环境有助于确定何时释放内存。</li>
</ul>
</li>
<li>JS是一个具有垃圾回收的变成环境，开发人员无需担心内存的分配和回收。JS 的垃圾回收流程如下<ul>
<li>超出范围的值会被自动表弟并且回收，并且在垃圾回收过程中删除。</li>
<li>主要垃圾收集算法成为 标记清除， 该算法会标记当前未使用的值，然后返回以回收该内存。</li>
<li>另一种算法是引用计数，该算法跟踪特定值有多少个引用，JS 不在使用此算法，但是由于JS 中访问了非本地JS对象，它仍然会影响IE</li>
<li>当代码中存才循环引用的时候，引用计数会导致问题，</li>
<li>接触变量的引用不仅有助于消除循环引用对象，而且对垃圾收集也有好处，为了确保有效的回收内存，应该及时解除不在使用的全局对象，全局对象属性以及循环引用变量的引用。<h1 id="Basic-Reference-Type"><a href="#Basic-Reference-Type" target="_blank" rel="noopener" class="headerlink" title="Basic Reference Type"></a>Basic Reference Type</h1>未完成 171<h2 id="The-Date-Type-日期类型"><a href="#The-Date-Type-日期类型" target="_blank" rel="noopener" class="headerlink" title="The Date Type 日期类型"></a>The Date Type 日期类型</h2>Date() 类型基于JAVA的早期版本，因此，日期类型将日期存储为UTC 自1970年1月1日以来经过的毫秒数。使用此数据储存格式，日期类型可以表示285616之后的日期。<br>若要创建日期对象，使用new运算符以及Date构造函数<br>let now = new Date()<br>使用不带参数的Date构造函数的时候，将会创建对象，并且分配当前的日期和时间。要给予其他日期或者时间创建日期，必须传入日期的毫秒。为了帮助完成此过程，提供了两种方法Date.parse() 和Date.UTC()<br>Date.parse() 方法接受表示日期的字符串参数。它尝试将字符串转换为日期的毫秒数表示。应该支持现在的格式日期。所有实现都必须支持一下日期格式。</li>
</ul>
</li>
<li>month/date/year (例如，5/23/2019)</li>
<li>month_name date, year(such as May 23,2019)</li>
<li>day_of_week month_name date year hours:minutes:seconds time_zone (such as Tue May 23 2019 00:00:00 GMT-0700) </li>
<li>ISO 8601 extended format YYYY-MM-DDTHH:mm:ss.sssZ (such as 2019-0523T00:00:00). This works only in ECMAScript 5–compliant implementations.<br>例如，要为2019年5月23日创建日期对象，可以使用一下代码：<br>let someDate = new Date(Date.parse(‘May 23,2019’))<br>如果传递给Data.parse() 的字符串不能代表一个日期，则其返回NaN。 如果直接传递一个字符串，则Date的构造函数将在调用Date.parse() ，这意味一下代码以前面的实例相同<br>let someDate = new Date(‘May 23, 2019’)<br>这个<br>Date.UTC() 方法也返回日期的毫秒数表示，但是使用与Data.parse()不同的信息构造该值。Date.UTC() 的参数是年，从零开始的月，月份中的一天，和小时，分钟，秒，以及毫秒。在参数中，只有前两个（年和月）是需要的。如果没有提供当月的日期，则假设为1。而所有其他省略的参数都假定为0。<br>这是Date的两个实例，UTC()的作用<br>// January 1 , 2000 at midnight GMT<br>let y2k = new Date(Date.UTC(2000,0))<br>// May 5, 2005 at 5:55:55 PM GMT<br>let allFives = new Date(Date.UTC(2005,4,5,17,55,55))<br>在此实例中创建连个日期，第一个日期是2000年1月1日，以2000年和0个月（即1月）表示。由于其他参数已经填写（将月份中的设置为1，将其他所有内容都设置为0），因此结果是该月的第一天午夜。第二个时期表示2005年5月5日5：55：:55，即是日期和时间仅仅包含5位，创建该日期也需要一些不同的数字，必须将月份设置为4、因为月份是从零开始的，而必须将消失设置为17，因为小时是从0到23标示的，其余的参数符合预期。<br>与Date.parse()一样。Date.UTC() 模仿与Date的构造函数，但是有一个主要的区别。创建日期的和时间在本地时区中，而不在GMT中。但是Date构造函数采用的与Date.UTC()相同的函数，因此如果第一个参数是数字，则够赞函数的假定它是日期的年份。第二个参数是月份，以此类推，可以写成<br>// January 1 , 2000 at midnight in local time<br>let y2k = new Date(2000,0)<br>// May 5 ,2005 at 5:55:55 PM local time<br>let allFives = new Date(2005,4,5,17,55,55)<br>但是两个日期都位于系统设置所确定的本地时区中<br>还提供了Date.now()，该方法返回执行毫秒数代表的日期和时间。使用此方法可以轻松的将Date对象用于代码分析。<br>// get start time<br>let start = Date.now()<br>// call a function<br>doSomething()<br>// get stop time<br>let stop = Date.now(),<br>  result = stop - start;<h3 id="Inherited-Methods-继承方法"><a href="#Inherited-Methods-继承方法" target="_blank" rel="noopener" class="headerlink" title="Inherited Methods 继承方法"></a>Inherited Methods 继承方法</h3>与其他引用类型一样，Date类型会覆盖 toLocaleString().toString()和valueOf()，尽管与之以前的类型不同，每种方法返回不同的内容。Date类型的toLocaleString()方法返回日期和时间以适合浏览器的语言环境的格式。这通常意味着该格式包含时间的AM或者PM，并且不包含任何时区的信息（确切的格式因浏览器而异）。toString 方法通常返回带有时区信息的日期和时间，并且该时间通常以24小时制表示。当en-US 区域设置中表示，PST 午夜2019年2月1日的日期和时间。以下显示toLocaleString() 和toString()格式<br>toLocaleString() - 2/1/2019 12：:00：:00 PM<br>toString() - Thu Feb 1 2019 00：:00：:0 GMT-0800 PST<br>现代浏览器已经融合这两种方法输出相同的字符串，使用旧版的浏览器，浏览器针对每种方法返回的搁置之间存在差异，这些差异意味着toLocalString() 和toString() 仅用于调试目的，而不是用于显示目的<br>Date类型的valueOf() 方法根本不会返回任何字符串，因为它被重写为返回日期的毫秒形式，以便运算符适用于日期值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// 一月一日，2019</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">// 2月1日，2019</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &lt;date2 &gt;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &gt; date2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
日期2019年1月1日早于 2019年2月1日，因此可以说前者少于后者。由于2019年1月1日的毫秒小于2019年2月1日的毫秒表示，因此小于日期运算符在比较日期的时候返回true，从而提供了一种确定日期顺序的简便方法。<h3 id="Date-Formatting-Methods-日期格式化方法"><a href="#Date-Formatting-Methods-日期格式化方法" target="_blank" rel="noopener" class="headerlink" title="Date-Formatting Methods 日期格式化方法"></a>Date-Formatting Methods 日期格式化方法</h3>有几种日期类型方法专门用于将日期格式化为字符串。</li>
<li>toDateString()  以实现特定的格式显示日期的星期，月份，日期和年。</li>
<li>toTimeString() 以实现特定的格式显示小时，分钟，秒和时区</li>
<li>toLocalDateString() 以实现特定格式显示日期的小时，分钟，秒和时区</li>
<li>toUTCString() 以特定格式显示完成UTC日期<br>这些方法输出的，与toLocalString() 和toString() 一样，因浏览器而异，因此不能在用户界面中使用以一致的显示日期<h3 id="Date-Time-Component-Methods"><a href="#Date-Time-Component-Methods" target="_blank" rel="noopener" class="headerlink" title="Date/Time Component Methods"></a>Date/Time Component Methods</h3>175页<br>日期的其余方法，直接处理或者和设置日期的特定部分</li>
</ul>
<h2 id="The-RegExp-Type-正则类型"><a href="#The-RegExp-Type-正则类型" target="_blank" rel="noopener" class="headerlink" title="The RegExp Type  正则类型"></a>The RegExp Type  正则类型</h2><p>通过RegExp类型支持正则表达式，正则表达式易于使用类似于Perl的语法创建<br>let expression = /pattern/flags;<br>表达式的模式部分可以是任何简单或者复杂的正则表达式，包括字符类，两次，分组，预行和向后引用。每个表达式可以具有零个或多个指示该表达式应该如何工作的标志，支持的三个标志表示匹配模式，如下表示：</p>
<ul>
<li>g 表示全局模式，表示将模式应用于所有字符串，而不是在找到一个匹配项后停止</li>
<li>i 表示不区分大小写的模式，这意味着在确定匹配项时将忽略模式和字符串的大小写</li>
<li>m 表示多行模式，意味着该模式将在一行文本的末尾后继续查找匹配项</li>
<li>y 表示粘滞模式，表示模式仅仅查看从lastIndex开始的字符串内容</li>
<li>u 表示已启用Unicode 模式<br>如本例所示，使用模式和这些标志的组合来创建正则表达式以产生不同的结果<br>// 匹配字符串中所有 at 的实例<br>let pattern1 = /at/g<br>// 匹配第一个，bat 或者 cat , 忽略大小写<br>let pattern2 = /[bc]at/i<br>// 匹配三个自怒 以 at 结尾的。忽略大小写<br>let pattern3 = /.at/gi<br>与其他语言中的正则表达式一样，当用作模式的一部分的时候，所有元字符都必须转义，元字符如下<br>([{^$|)]}?*+.<br>每个元字符在正则表达式语法中都有一个或者多个用途，因此当要匹配字符串中的字符的时候，必须用反斜杠将其转移，这里有些例子<br>// 匹配第一个实例 是bat 或者cat ,忽略大小写<br>let pattern1 = /[bc]at/i<br>// 匹配第一个实例是 [bc]at 忽略大小写<br>let  pattern2  = /[bc]at/i<br>// 匹配三个字母 以 at 结尾 忽略大小写<br>let pattern3 = /.at/gi<br>// 匹配所有 实例 .at ， 忽略大小写<br>let pattern4 = /.at/gi<br>再次代码中，pattern1 匹配的把bat 或者cat 的所有实例，无论大小写如何。要直接匹配[bc]at ， 两个方括号都需要使用反斜杠进行转移，如pattern2 中所示。 在pattern3中，点表示任何字符都可以在at之前匹配，如果要匹配 .at 则需要将点转义如pattern4 所示<br>前面的实例都是用文字形式定义了正则表达式，也可以使用RegExp 构造函数来创建正则表达式，该构造函数接收两个参数，要匹配的字符串模式和要应用的可选标志字符串，可以使用文字语法定义的任何正则表达式也可以使用构造函数来定义。、<br>// 匹配第一个 实例 有 bat 或者 cat ,忽略大小写<br>let pattern1 = /[bc]at/i<br>// 使用构造函数<br>let pattern2  = new RegExp(“[bc]at”, ‘i’)<br>在这里，pattern1 和 pattern2 定了相同的正则表达式，注意，RegExp构造函数的两个参数都是字符串（不应将正则表达式文字传递给RegExp 构造函数）。 因为 RegExp 构造函数模式 参数是一个字符串，所以在某些情况下 需要对字符串进行两次转移，所有元字符都必须被两次转义，已经转义的字符串也必须被转义。例如 \n (\字符，当在正则表达式字符串中使用时，通常会在字符串中转义为\变成\)。 下表以文字形式显示了一些模式以及使用 RegExp构造函数所需的等效字符串。<br>记住，使用文字创建正则表达式与使用RegExp构造函数创建正则表达式并不完全相同，正则表达式文字始终共享相同的RegExp实例，而通过构造函数创建的RegExp始终会导致一个新实例。<br>let re = null;<br>for (let i = 0; i &lt;10; i++){<br>  re = /cat/g;<br>  re.test(‘catastroppjo’)<br>}<br>for (let i = 0;i&lt;10; i++){<br>  re = new RegExp(‘cat’,’g’);<br>  re.test(‘catejijijijni’)<br>}<br>在第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp实例。由于实例属性不会重置，所以在循环中再次调用test（）方法会失败。这是因为第一次调用test（）找到了cat,但是第二次调用时从索引为3的字符开始的，所以就找不到他了。由于会测试到字符串末尾，所以下一次在调用test()就由从头开始了<br>第二个循环使用RegExp构造函数在每次循环中创建正则表达式。每次调用test()都会返回true,因为会为每次迭代创建一个新的RegExp实例。<br>也可以赋值现有的正则表达式实例，并可以选择使用构造函数修改其标志<br>const re1 = /cat/g; console.log(re1);  // “/cat/g”</li>
</ul>
<p>const re2 = new RegExp(re1); console.log(re2);  // “/cat/g”</p>
<p>const re3 = new RegExp(re1, “i”); console.log(re3);  // “/cat/i</p>
<h3 id="RegExp-Instance-Properties"><a href="#RegExp-Instance-Properties" target="_blank" rel="noopener" class="headerlink" title="RegExp Instance Properties"></a>RegExp Instance Properties</h3><p>每个RegExp 实例都有以下属性，这些属性可以获取有关模式的信息</p>
<ul>
<li>global 布尔值，表示是否设置了g标志</li>
<li>ignoreCase 布尔值，表示是否设置了i标志</li>
<li>unicode 布尔值，表示是否设置了u标志</li>
<li>sticky 布尔值，指示是否设置了y标志</li>
<li>lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从0开始</li>
<li>multiline 布尔值，表示是否设置了m 标志</li>
<li>source  正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
<li>flags 正则表达式的字符串标志，总是返回该值，以字面量形式制定的那样，而不是传递给构造函数的字符串模式。<br>这些属性有助于识别正则表达式的各个方面，但是他们通常都没有用，因为该信息可在模式声明中找到。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;         </span><br><span class="line"><span class="built_in">console</span>.log(pattern1.global);     <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.ignoreCase); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.multiline);  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);  <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.source);     <span class="comment">// "\[bc\]at" </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.flags);      <span class="comment">// "i"         </span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);         <span class="built_in">console</span>.log(pattern2.global);     <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.multiline);  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);  <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.source);     <span class="comment">// "\[bc\]at" </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.flags);      <span class="comment">// "i"</span></span><br></pre></td></tr></table></figure>
主义，尽管第一个模式使用过的是字面量，第二个模式使用的是RegExp构造函数，每个模式的source 和flags 属性也是等效的。课件source 和flags 属性保存的是规范形式的字符串，即字面量形式所用的字符串。<h3 id="RegExp-Instance-Methods-RegExp-实例方法"><a href="#RegExp-Instance-Methods-RegExp-实例方法" target="_blank" rel="noopener" class="headerlink" title="RegExp Instance Methods  RegExp 实例方法"></a>RegExp Instance Methods  RegExp 实例方法</h3>RegExp 对象的主要方法是 exec() ，该方法是专门为捕获组而设计的。exec() 方法接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；如果没有匹配项的情况下，则返回null。返回的数组尽管是array的实例，但是包含两个附加的属性：index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，任何其他项时与模式中的捕获租匹配的字符串（如果模式中没有捕获组，则该数组值包含一项）<br>let text = ‘mom and dad and baby’<br>let pattern = /mon (and dad ( and baby)?)?/gi<br>let matches = pattern.exec(text)<br>console.log(matches.index) //0<br>console.log(matches.input) // ‘mom and dad and baby’<br>console.log(matches[1]);     // “ and dad and baby” console.log(matches[2]);     // “ and baby”<br>在这个例子中的模式包含两个捕获租。最内部的捕获组匹配”and dad” 或者”and dad and baby”。 当把字符串传入exec()方法后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs 的index 属性值为0。 。数组中的第一个匹配的是整个字符串，第二项包含于第一个捕获租匹配的内容，第三项包含与第二个捕获组匹配的内容。<br>对于exec()方法而言，即使在模式中设置了全局标志g,他每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串多次调用exec()将始终返回第一个匹配项的信息。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat,sat,fat"</span></span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text)</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 0 console.log(matches[0]);          // cat console.log(pattern.lastIndex);   // 0         matches = pattern.exec(text);    console.log(matches.index);       // 0 console.log(matches[0]);          // cat console.log(pattern.lastIndex);   // 0</span></span><br></pre></td></tr></table></figure>
此实例中的模式不是全局模式，因此每次调用exec()都是返回第一个匹配项（”cat”）。在非全局模式下，lastIndex保持不变<br>在模式上设置了g标志之后，对exec()的每次调用都会进一步移入字符串以查找匹配项。<br>let text = “cat, bat, sat, fat”;<br>let pattern = /.at/g;<br>let matches = pattern.exec(text);<br>console.log(matches.index);       // 0<br>console.log(matches[0]);          // cat<br>console.log(pattern.lastIndex);   // 3<br>matches = pattern.exec(text);<br>console.log(matches.index);       // 5<br>console.log(matches[0]);          // bat<br>console.log(pattern.lastIndex);   // 8<br>matches = pattern.exec(text);<br>console.log(matches.index);       // 10<br>console.log(matches[0]);          // sat<br>console.log(pattern.lastIndex);   // 13<br>此模式是全局模式，因此每次调用exec() 都会返回字符串的下一个匹配项，直到到达字符串末尾位置。另请注意的模式的lastIndex属性如何受到影响。在全局模式下，每次调用exec() 后，lastIndex都会增加。lastIndex 跟踪紧接在最后一个匹配项右侧的字符的索引。<br>在模式设置了粘滞y标志后，每次对exec() 的调用都只会在lastIndex处的字符串搜索匹配项。否则就没有其他的地方。黏贴标志将覆盖全局标志。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;    </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/y</span>;         </span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);    </span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// cat </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 3         // There is no match starting at character index 3, so exec() will return null // exec() finding no matches resets lastIndex to 0 </span></span><br><span class="line">matches = pattern.exec(text);    </span><br><span class="line"><span class="built_in">console</span>.log(matches);             <span class="comment">// null </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Advancing lastIndex will allow a sticky regex exec() to find the next match: </span></span><br><span class="line">pattern.lastIndex = <span class="number">5</span>; </span><br><span class="line">matches = pattern.exec(text);    </span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 5 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// bat </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
正则表达式的另一种方法是text()， 它接受一个字符串参数，如果模式与参数相匹配，则返回true， 否则返回false. 当想知道某个模式是否匹配，但是不需要实际匹配的文本的时候，此方法很有用，test() 方法通常用于if 语句中例如：、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"000-00-0000"</span>;    </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;        </span><br><span class="line"> <span class="keyword">if</span> (pattern.test(text)) &#123;  <span class="built_in">console</span>.log(<span class="string">"The pattern was matched."</span>); &#125;</span><br></pre></td></tr></table></figure>
在这个例子中，正则表达式测试特定的数字序列，如果输入的文本与模式相匹配，则会显示一条消息。这功能通常用于验证用户输入，当您只在乎输入是否有效的时候、<br>toLocalString() 和toString() 的继承方法均返回正则表达式的文字表示形式，而不管其创建方式如何<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"gi"</span>); <span class="built_in">console</span>.log(pattern.toString());      <span class="comment">// /\[bc\]at/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.toLocaleString());  <span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure>
在此示例中的模式是使用RegExp构造函数创建的，toLocaleString()和toString() 方法仍然会向它是字面量形式创建一样显示其字符串表示。<br>正则表达式的valueOf()方法返回正则表达式本身。<h3 id="RegExp-Constructor-Properties-构造函数属性"><a href="#RegExp-Constructor-Properties-构造函数属性" target="_blank" rel="noopener" class="headerlink" title="RegExp Constructor Properties 构造函数属性"></a>RegExp Constructor Properties 构造函数属性</h3>RegExp 构造函数具有多个属性。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问他们。欢聚话说，这些属性分别有一个长属性名和一个短属性名<br>input  $_  最近一次要匹配的字符串<br>lastMatch $&amp; 最近一次的匹配项。<br>lastParen &amp;+ 最近一次匹配的补货组<br>leftContext $` input 字符串中lastMatch之前的文本<br>rightContext $’ input 字符串中lastMatch 之后的文本<br>使用这些属性可以从exec()或者text() 执行的操作中提取出更具体的信息<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"this has been a short summer"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input);         <span class="comment">// this has been a short summer  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext);   <span class="comment">// this has been a        </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext);  <span class="comment">// summer </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch);     <span class="comment">// short  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastParen);     <span class="comment">// s </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
这段代码创建了一个模式，匹配任何一个字符后跟hort, 而且把第一个字符放在一个捕获租中。<br>各种属性用法如下：<br>input 属性返回了原始字符串<br>leftContext 属性返回了单词short 之前的字符串，而rightContext 属性返回了short 之后的字符串<br>lastMatch 属性返回最近一次与整个正则表达式匹配的字符串。 即short<br>lastParen 属性返回最近一次匹配的捕获租，即例子中的s<br>这些长属性名都可以用相应的短属性名来代替，只不过短属性名大都不是有效的标识符，因此必须通过方括号语法来访问他们<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"this has been a short summer"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>;         <span class="comment">/* * Note: Opera doesn't short property names. * Internet Explorer doesn't support multiline. */</span>    </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_);         <span class="comment">// this has been a short summer  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]);      <span class="comment">// this has been a        </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]);      <span class="comment">// summer  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]);      <span class="comment">// short  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]);      <span class="comment">// s  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
除了上面的几个属性之外，还有多大9个用于储存捕获租的构造函数属性。访问这些属性RegExp.$1,RegExp.$2,RegExp.$3,…RegExp.$9, 分别用于存储第一，第二。。到第九个匹配的捕获组。在调用exec() 和test() 方法时候，这些属性会被自动填充。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"this has been a short summer"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(..)or(.)/g</span>;  </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);   <span class="comment">// sh  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);   <span class="comment">// t &#125;</span></span><br></pre></td></tr></table></figure>
这里创建了包含两个捕获组的模式，并用该模式测试了一个字符串，即使test()方法值返回一个布尔值。但RegExp构造函数的属性$1和$2 也会被匹配相应的捕获组的字符串自动填充<br>这些构造函数属性，都不是任何web标准的一部分，避免使用<h3 id="Pattern-Limitations"><a href="#Pattern-Limitations" target="_blank" rel="noopener" class="headerlink" title="Pattern Limitations"></a>Pattern Limitations</h3>p185 未写完<h2 id="Primitive-Wrapper-Types-基本包装类型"><a href="#Primitive-Wrapper-Types-基本包装类型" target="_blank" rel="noopener" class="headerlink" title="Primitive Wrapper Types 基本包装类型"></a>Primitive Wrapper Types 基本包装类型</h2>为了便于操作基本类型值，还提供了3个特殊的引用类型： Boolean,Number, String 这些类型与本章介绍的其他引用类型相似，但是同时也具有各自的基本类型相应的特殊行为。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"some text"</span></span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
这个例子变量s1包含了一个字符串，字符串当然是基本类型值。而下一行调用了s1的substring() 方法，并将返回的结果保存在了s2中。基本类型值不是对象，因而从逻辑上讲他们不应该有方法。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问s1的时候，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串的时候，后台都会自动完成以下的处理。</li>
</ul>
<ol>
<li>创建String 类型的一个实例</li>
<li>在实例上调用指定的方法</li>
<li>销毁这个实例。<br>可以想到以下三个代码中使用的三个步骤。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>)</span><br><span class="line">s1 = <span class="literal">null</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">此行为允许原始字符串充当对象。。而且上面三个步骤也适用于 Boolean 和number 类型对应的布尔值和数字值</span></span><br><span class="line"><span class="string">引用类型与基本包装类型的主要区别就是对象的生存期。使用new 运算符创建的引用类型实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型值添加属性和方法。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">"some text"</span></span><br><span class="line">s1.color = <span class="string">"red"</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.color) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
在此，第二行代码试图为字符串s1添加一个color 属性，但是当第三行代码在此访问s1的时候，其color 属性不见了。问题的原因就是第二行创建的String 对象在执行第三行代码的时候已经被销毁了，第三行代码又创建自己的String对象，而该对象没有color 属性。<br>当然，可以显式地调用Boolean ，number 和string 。不过，应该在绝对必要的情况下在这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例条用typeof 会返回object ，而所有基本包装类型的对象都会被转换为布尔值true<br>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
把字符串传给object 构造函数，就会创建string的实例，而传入数值参数会得到number的实例，传入布尔值参数就会得到Boolean的实例。<br>使用new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">"25"</span></span><br><span class="line"><span class="keyword">let</span> number = <span class="built_in">Number</span>(value) <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number) <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value) <span class="comment">// constructor</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj) <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
在这个例子中，变量number 中保存的基本类型的值25，而变量obj中保存的是Number的实例<br>尽管不建议显式地创建基本包装类型的对象，但他们操作基本类型的能力还是相当重要的，而每个基本包装类型都提供了操作相应值的便捷方法。<h3 id="The-Boolean-Type"><a href="#The-Boolean-Type" target="_blank" rel="noopener" class="headerlink" title="The Boolean Type"></a>The Boolean Type</h3>Boolean 类型是与布尔值相对应的引用类型。要创建Boolean 对象，可以像下面嗲用Boolean 构造函数并传入true 或false 值<br>let booleanObject  = new Boolean(true)<br>Boolean 类型的实例重写了valueOf() 方法，返回基本类型值true 或者false。 重写toString() 方法，返回字符串true 和false 、 可是，Boolean 对象的用处不大， 因为他经常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用Boolean对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// true         </span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>; </span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
在这个例子中，我们使用false值创建了一个Boolean 对象，然后将这个对象与基本类型值true构成了逻辑表达式，在布尔运算中，false &amp;&amp; true 等于 false， 可是，实例中的这行代码是对falseObject 而不是对它的值false 进行求值。布尔表达式中的所有对象都会被转换为true ，因此 falseObject 对象在布尔表达式中代表的true。 结果true &amp;&amp; true 当然就等于true了<br>基本类型与引用类型的布尔值还有两个区别。首先typeof操作符对基本类型返回Boolean。而对引用类型返回object，其次由于Boolean对象是Boolean类型的实例，所以使用instanceof 操作符测试boolean 对象返回true ，而此时基本类型的布尔值则返回false。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject);        <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue);         <span class="comment">// boolean </span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="The-Number-Type"><a href="#The-Number-Type" target="_blank" rel="noopener" class="headerlink" title="The Number Type"></a>The Number Type</h3>number 类型是数字值的引用类型，要创建number 对象，可以在调用number构造函数时向中传递相应的数值。<br>let numberObject = new Number(10)<br>与Boolean 类型一样，number 类型也重写了valueOf() ,toLocaleString() 和toString() 方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。toString() 方法可以选择接受一个参数，该参数用于表示数字的技术，告诉他返回即几进制数值的字符串形式。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toString());    <span class="comment">// "10"</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));   <span class="comment">// "1010" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));   <span class="comment">// "12" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>));  <span class="comment">// "10" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>));  <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
除了继承的方法之外，number类型还提供了一些用于将数值格式化为字符串的方法。<br>toFixed() 方法会按照指定的小数位返回数值的字符串表示。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)) <span class="comment">// "10.00"</span></span><br></pre></td></tr></table></figure>
这里给toFixed() 方法传入了数值2 ，意思就是显示几位小数。于是这个方法就返回”10.00”,即以0填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10.005</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
toFixed()的舍入特性，是的很适合处理货币值。多个浮点值之间的算数运算可能不会产生确切的结果，例如0.1+0.2 =0.30000004<br>另外一种方法是toExponential() ， 该方法返回以指数表示法（也成为e表示法），表示的数值的字符串形式。与toFixed() 一样，toExponential () 也接受一个参数，而且该参数同样也是指定输出结果中的小数位数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num =<span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.lgo(num,toExponential(<span class="number">1</span>))  <span class="comment">// "1.0e+1"</span></span><br></pre></td></tr></table></figure>
此代码输出了1.0e+1 不过这么小的数值一般不必使用e表示法，如果想得到表示某个数值的最合适的格式，就应该是用toPrecision()方法<br>toPrecision() 方法返回数字的固定大小格式，也可能返回指数格式，具体规则是看哪种格式最合适。这种方法接受一个参数，即表示数值的所有数字的位数。（不包括指数部分。）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>));  <span class="comment">// "1e+2" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>));  <span class="comment">// "99" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>));  <span class="comment">// "99.0"</span></span><br></pre></td></tr></table></figure>
在实例中，第一个任务是用一个数字来表示99，结果是1e+2 ，否则成为100. 由于99不能只用一个数字来准确表示，因此该方法四舍五入为100，这样就可以使用一位数来表示它了。而接下来的用两位数表示99，当然还是99。最后，在想以三位数表示99的时候，toPrecision() 方法返回了99.0 实际上，toPrecision() 会根据要处理的数值决定到底是调用toFixed() 还是调用toExponential() 。而这三个方法都可以通过向上或者向下舍入，做到以最准确的形式来表示带正确小数位的值。<br>与Boolean对象类似，number 对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化number 类型，而原因与显式创建Boolean对象一样，就是在使用typeof 和instanceof操作符测试基本类型数值与引用类型数值时候，得到的结果完全不同，<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">let</span> numberValue = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObject);       <span class="comment">// "object" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberValue);        <span class="comment">// "number" </span></span><br><span class="line"><span class="built_in">console</span>.log(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
在使用typeof 操作符测试基本类型数值的时候，始终会返回number， 而在测试number对象的时候，则会返回object， 类似的number对象是number 类型的实例，而基本类型的数值则不是。<h4 id="The-isInteger-Method-and-Safe-Integers-安全整数"><a href="#The-isInteger-Method-and-Safe-Integers-安全整数" target="_blank" rel="noopener" class="headerlink" title="The isInteger() Method and Safe Integers  安全整数"></a>The isInteger() Method and Safe Integers  安全整数</h4>ES6中引入了Number.isInteger() 方法能够辨别数字值是否存储为整数，当十进制0可能掩盖该数字是否已浮点格式储存的时候，此功能很有用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1</span>));     <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.00</span>));  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.01</span>));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
IEEE 754 数字格式具有不同的数值范围，在该范围内二进制值可以恰好表示一个整数值。此数字范围从Number.MIN_SAFE_INTEGER -2^53 + 1 到  Number.MAX_SAFE_INTEGER  2^53 - 1. 在此范围之外，可以尝试存储整数，但是此编码格式意味着此二进制也可能别名为完全不同的数字。要确定数字是否在此范围内，可以使用Number.isSafeInteger() 方法轻松检查。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">-1</span> * (<span class="number">2</span> ** <span class="number">53</span>)));      <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">-1</span> * (<span class="number">2</span> ** <span class="number">53</span>) + <span class="number">1</span>));  <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span> ** <span class="number">53</span>));             <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger((<span class="number">2</span> ** <span class="number">53</span>) - <span class="number">1</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">### The String Type</span></span><br><span class="line"><span class="string">String 类型 是字符串的对象包装类型，可以使用string 构造函数来创建</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"helle world"</span>)</span><br></pre></td></tr></table></figure>
String对象的方法在所有基本的字符串值中访问到。其中继承的valueOf(), toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。<br>String类型的每个实例都包含一个属性，即length， 该属性指示字符串中的字符数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.length) <span class="comment">//11</span></span><br></pre></td></tr></table></figure>
本示例输出11 ， 即hello world 中的字符串，清楚一，即使字符串中包含双字节字符（不是占一个字节的ASCII字符），每个字符也仍然算一个字符。<br>String类型提供了很多方法，用于辅助完成对字符串的解析和操作。<h4 id="The-JavaScript-Character-JS-字符"><a href="#The-JavaScript-Character-JS-字符" target="_blank" rel="noopener" class="headerlink" title="The JavaScript Character  JS 字符"></a>The JavaScript Character  JS 字符</h4>JS 字符串由16位代码单元组成，对于大多数字符，每个16位代码单元将对应一个字符。length属性就是指示字符串内出现了多少个16位代码单元<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"abcde"</span></span><br><span class="line"><span class="built_in">console</span>.log(message.length) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
此外，charAt() 以单字符字符串的形式返回给定位置的那个字符，该索引由方法的整数参数指定。具体来说，此方法在制定的索引出找到16位代码单元，并返回与该代码单元向对应的字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"abcde"</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>)) <span class="comment">// c</span></span><br></pre></td></tr></table></figure>
JS 字符串使用两种Unicode 编码的混合策略： USC-2和UTF-16 ,对于可以用16位编码的字符，这两种编码实际上是相同的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"abcde"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Unicode "Latin small letter C" is U+0063 </span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));  <span class="comment">// 99</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Decimal 99 === Hexadecimal 63 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99</span> === <span class="number">0x63</span>);            <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
fromCharCode() 方法用于根据其UTF-16代码单元形式在字符串中创建字符。此方法接受任意数量的数字，并返回连接到字符串中的等效字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode "Latin small letter A" is U+0061 </span></span><br><span class="line"><span class="comment">// Unicode "Latin small letter B" is U+0062 </span></span><br><span class="line"><span class="comment">// Unicode "Latin small letter C" is U+0063 </span></span><br><span class="line"><span class="comment">// Unicode "Latin small letter D" is U+0064 </span></span><br><span class="line"><span class="comment">// Unicode "Latin small letter E" is U+0065</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>));  <span class="comment">// "abcde"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 0x0061 === 97 </span></span><br><span class="line"><span class="comment">// 0x0062 === 98 </span></span><br><span class="line"><span class="comment">// 0x0063 === 99 </span></span><br><span class="line"><span class="comment">// 0x0064 === 100 </span></span><br><span class="line"><span class="comment">// 0x0065 === 101</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>));          <span class="comment">// "abcde"</span></span><br></pre></td></tr></table></figure>
对于u+0000到 u+FFFF范围，length,charAt(), charCodeAt() 和fromCharCode() 的行为俊宇期待的一样，这是因为每个字符都代表16字节表示，并且这些方法都是以16位代码为单位进行操作。只要字符编码大小和代码单位大小之间存在奇偶校验，这些方法就可以按预期运行。<br>191页<h4 id="The-normalize-Method"><a href="#The-normalize-Method" target="_blank" rel="noopener" class="headerlink" title="The normalize() Method"></a>The normalize() Method</h4>193 页<h4 id="String-Manipulation-Methods"><a href="#String-Manipulation-Methods" target="_blank" rel="noopener" class="headerlink" title="String-Manipulation Methods"></a>String-Manipulation Methods</h4>有几种方法可以操纵字符串的值，这些方法中的第一个是concat()， 用于将一或多个字符串拼接起来，并返回连接字符串作为结果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">"world"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// "hello world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
在这个例子中，在stringValue上调用concat() 方法的结果是 hello world。 即stringValue的值保持不变，concat() 方法接受任意数量的参数，也就是说可以通过它拼接任意多个字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello "</span>; </span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(result);       <span class="comment">// "hello world!" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue);  <span class="comment">// "hello</span></span><br></pre></td></tr></table></figure>
这个例子将world 和！ 拼接到了hello 末尾，尽管concat() 是专门用来拼接字符串的方法，但时间中使用的更多还是加号操作符，而且加号操作符在大多数情况下都比使用concat() 方法要简便易行。<br>JS 还提供了三种基于子字符创建新字符串的方法： slice(),substr(),substring() 这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一个或者两个参数，第一个参数指定子字符串的开始位置，第二个参数表示字符串到哪里结束。具体来说slice() 和substring() 的第二个参数指定的是子字符最后一个字符后面的位置。对于substr() 的第二个参数指定的则是返回字符个数。如果没有个这些方法传递第二个参数，则将字符串的长度作为结束位置，与concat()一样，slice()， substr()，substring() 也不会修改字符串本身的值，他们只是返回一个基本类型的字符串值，对原始字符串没有任何影响<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>));        <span class="comment">// "lo world" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>));    <span class="comment">// "lo world" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>));       <span class="comment">// "lo world" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>));     <span class="comment">// "lo w" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>));  <span class="comment">// "lo w" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>));    <span class="comment">// "lo worl"</span></span><br></pre></td></tr></table></figure>
在此实例中，slice(),substr() 和substring() 以相同的方式使用，并且在大多数情况返回相同的值。在只制定一个参数3 的情况下，这三个方法都返回lo world ，因为hello 中的第二个l处于位置3 ，而在制定两个参数3 和7的情况下，slice() 和substring() 返回low (world中的o处于位置7因此结果不包含o) 但substr() 返回lo worl 因为它的第二个参数指定的是要返回的字符个数。<br>当参数为负数的时候，这些方法会有不同的行为，对于slice() 方法会将将传入的负值与字符串的长度相加，substr() 方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。 最后substring() 方法会把所有负值参数都转换为0 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">-3</span>));         <span class="comment">//rld</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">-3</span>));     <span class="comment">// hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">-3</span>));        <span class="comment">// rld</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">-4</span>));      <span class="comment">// lo w</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>, <span class="number">-4</span>));  <span class="comment">// hel</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">-4</span>));   <span class="comment">// ''</span></span><br></pre></td></tr></table></figure>
这个例子清晰的表明了三种方法之间的区别，当时用单个负参数调用slice()和substr() 的时候，他们作用的相同。发生这种情况是因为-3 被转换为7.从而有效的调用了slice(7) 和substr(7)。 另一方面，由于-3 转换为0 ， substring()方法返回整个字符串。<br>当第二个参数为负的时候，这三种方法的行为都会有所不同，slice() 方法将第二个参数转换为7，从而使调用等效于slice(3,7) 因此返回了lo w. 对于substring()方法会把第二个参数转换0, 是调用变成了substring(3,0) 。 而由于这个方法会将较小的数作为开始位置，将较大的数作为结束位置。因此最终相当于调用了substring(0,3) 。substr() 也会将第二个参数转换为0 ，也就意味着返回包含零个字符的字符串，也就是一个空字符串。  <h4 id="String-Inclusion-Methods-字符串位置方法"><a href="#String-Inclusion-Methods-字符串位置方法" target="_blank" rel="noopener" class="headerlink" title="String Inclusion Methods  字符串位置方法"></a>String Inclusion Methods  字符串位置方法</h4>有两种可以从字符串查找子字符串的方法，indexOf() 和lastIndexOf() 。 这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置（如果没有找到该字符串，则返回-1）。两者之间的区别在于indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法从字符串的末尾开始寻找<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">"o"</span>));      <span class="comment">// 4 </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">"o"</span>));  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
在这里 字符串o的首次出现是在位置4，即hello 的o 。 最后一次出现的位置是7，即world中的o。 如果o在这个字符串中仅出现了一次，那么indexOf和lastIndexOf() 返回相同的位置。<br>每个方法都接受一个可选的第二个参数，该参数指示从字符串中开始搜索的位置，这意味着indexOf() 方法将从该位置开始搜索，并且朝着字符串的结尾移动，而忽略起始位置之前的所有内容。而lastIndexOf() 从指定的位置向前搜索，忽略该位置之后的所有字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">"o"</span>,<span class="number">6</span>)) <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">"o"</span>,<span class="number">6</span>)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
在将第二个参数6传递给这两个方法之后，得到了与前面例子相反的结果。这一次由于indexOf()是从位置6 字母w 开始向后搜索，结果在位置7找到了o , 因此它返回7. 而lastIndexOf() 是从位置6开始向前搜索。结果找到了hello 中的o ,因此它返回4 。在使用第二个参数的情况下，可以通过循环调用indexOf() 或者lastIndexOf()来找到所有匹配的字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"Lorem ipsum dolor sit amet, consectetur adipisicing elit"</span>; <span class="keyword">let</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"><span class="keyword">let</span> pos = stringValue.indexOf(<span class="string">"e"</span>);         </span><br><span class="line"><span class="keyword">while</span>(pos &gt; <span class="number">-1</span>) &#123;  </span><br><span class="line">    positions.push(pos);  </span><br><span class="line">    pos = stringValue.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>); &#125;  </span><br><span class="line"><span class="built_in">console</span>.log(positions);  <span class="comment">// "3,24,32,35,52"</span></span><br></pre></td></tr></table></figure>
这个例子通过不断增加indexOf() 方法开始查找的位置，遍历了一个长字符串。在循环之外，首先找了e 在字符串中的初始位置； 而进入循环后，则每次都给indexOf() 传递上一次的位置+1，这样就确保了每次新搜索都从上一次找到的子字符串的后面开始，每次搜索返回的位置一次被保存在数组positions 中、 以便于将来使用。<h4 id="String-Inclusion-Methods"><a href="#String-Inclusion-Methods" target="_blank" rel="noopener" class="headerlink" title="String Inclusion Methods"></a>String Inclusion Methods</h4>ES6 添加了三种其他方法来确定一个字符串是否包含在另一个字符串中：startsWith(),endsWith() 和includes() 。 所有方法都在字符串中搜索给定的子字符串，并返回一个布尔值，用来指示是否包括该字符串。 他们之间的区别在于startsWith() 检查从索引0 开始的匹配项，endWith() 检查从索引（string.length-substring.length） 开始的匹配项，includes()检查整个字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"foobarbaz"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"foo"</span>));  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"bar"</span>));  <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"baz"</span>));    <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"bar"</span>));    <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"bar"</span>));    <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"qux"</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
startWith() 和includes() 方法接受一个可选的第二个参数，该参数指示从字符串中开始搜索的位置，这意味着这些将该位置开始搜索，并朝字符串的结尾移动，而忽略起始位置之前的所有内容。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"foobarbaz"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"foo"</span>));     <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"foo"</span>, <span class="number">1</span>));  <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"bar"</span>));       <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"bar"</span>, <span class="number">4</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
EndWith() 方法接受一个可选的第二个参数，该参数指示应视为字符串结尾的位置，如果没有提供这个值，则默认使用字符串的长度，当提第二个参数的时候，该方法会将字符串视为仅仅包含这些字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"foobarbaz"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"bar"</span>));     <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"bar"</span>, <span class="number">6</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="The-trim-Method"><a href="#The-trim-Method" target="_blank" rel="noopener" class="headerlink" title="The trim() Method"></a>The trim() Method</h4>ECMA在所有字符串上都具有trim() 方法，这个方法会创建一个字符串的副本，删除前置以及后缀的所有空格，然后返回结果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"  hello world  "</span>; </span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.trim(); </span><br><span class="line"><span class="built_in">console</span>.log(stringValue);         <span class="comment">// "  hello world  " </span></span><br><span class="line"><span class="built_in">console</span>.log(trimmedStringValue);  <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>
由于trim()返回的是字符串的副本，所以原始字符串的前置以及后缀空格会保持不变。trimLeft()和trimRight() 方法，分别用于删除字符串开头和末尾的空格。<h4 id="The-repeat-Method"><a href="#The-repeat-Method" target="_blank" rel="noopener" class="headerlink" title="The repeat() Method"></a>The repeat() Method</h4>所有字符串都具有repeat()方法，repeat() 方法接受单个整数参数计算，复制字符串计数时间，并连接所有副本。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"na "</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.repeat(<span class="number">16</span>) + <span class="string">"batman"</span>); <span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure>
<h4 id="The-padStart-and-padEnd-Methods"><a href="#The-padStart-and-padEnd-Methods" target="_blank" rel="noopener" class="headerlink" title="The padStart() and padEnd() Methods"></a>The padStart() and padEnd() Methods</h4>padStart() 和padEnd() 方法将复制一个字符串，如果字符串的长度小于制定的长度，则在字符串的任一侧添加填充以将其扩展到指定长度。第一个参数是所需的长度，第二个参数是添加为填充的可选字符串。如果没有提供，将使用U+0020 空格字符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"foo"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">6</span>));       <span class="comment">// "   foo" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">9</span>, <span class="string">"."</span>));  <span class="comment">// "......foo" </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">6</span>));         <span class="comment">// "foo   " </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">9</span>, <span class="string">"."</span>));    <span class="comment">// "foo......"</span></span><br></pre></td></tr></table></figure>
可选参数不限于单个字符，如果提供了多个字符的字符串，则该方法量使用串联的填充，并将其截断为确切的长度。此外，如果长度小于或等于字符串长度，则该操作实际上是空操作。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"foo"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">8</span>, <span class="string">"bar"</span>));  <span class="comment">// "barbafoo" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">2</span>));         <span class="comment">// "foo" </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">8</span>, <span class="string">"bar"</span>));    <span class="comment">// "foobarba" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">2</span>));           <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<h4 id="String-Iterators-and-Destructuring"><a href="#String-Iterators-and-Destructuring" target="_blank" rel="noopener" class="headerlink" title="String Iterators and Destructuring"></a>String Iterators and Destructuring</h4>189页<h4 id="String-Case-Methods"><a href="#String-Case-Methods" target="_blank" rel="noopener" class="headerlink" title="String Case Methods"></a>String Case Methods</h4>下一组方法涉及大小写转换。四种方法执行大小写转换：toLowerCase(), toLocaleLowerCase(), toUpperCase(), toLocaleUpperCase() . toLocaleLowerCase和toLocaleUpperCase 需要在特定的语言中使用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleUpperCase());  <span class="comment">// "HELLO WORLD" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toUpperCase());        <span class="comment">// "HELLO WORLD" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleLowerCase());  <span class="comment">// "hello world" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLowerCase());        <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>
以上代码嗲用了toLocaleUpperCase() 和toUpperCase() 都返回了 HELLO WORLD, 就像调用toLocaleLowerCase() 和toLowerCase() 都返回hello world 一样。 一般来说，在不知道自己的代码将在哪种语言环境下运行的情况下，还是针对地区的方法更稳妥一些。一般来说，在不知道自己的代码将在哪种语言环境下运行的情况下，还是针对地区的方法更稳妥一些。<h4 id="String-Pattern-Matching-Methods-字符串的模式匹配方法"><a href="#String-Pattern-Matching-Methods-字符串的模式匹配方法" target="_blank" rel="noopener" class="headerlink" title="String Pattern-Matching Methods  字符串的模式匹配方法"></a>String Pattern-Matching Methods  字符串的模式匹配方法</h4>字符串类型定义了几个用于在字符串中匹配模式的方法，这些方法中的第一个是match(),在字符串上嗲用这个方法，本质上与调用RegExp的exec() 方法相同。match() 方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;    </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;         <span class="comment">// same as pattern.exec(text) </span></span><br><span class="line"><span class="keyword">let</span> matches = text.match(pattern); </span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// "cat" </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
match() 方法返回了一个数组，如果是调用RegExp对象的exec() 方法并传递本例中的字符串作为参数，那么也会得到与此相同的数组，数组的第一项是与整个模式匹配的字符串，之后的每一项保存着与正则表达式中的捕获数组匹配的字符串。</li>
</ol>
<p>200页</p>
<h4 id="The-localeCompare-Method"><a href="#The-localeCompare-Method" target="_blank" rel="noopener" class="headerlink" title="The localeCompare() Method"></a>The localeCompare() Method</h4><p>202 页</p>
<h4 id="HTML-Methods"><a href="#HTML-Methods" target="_blank" rel="noopener" class="headerlink" title="HTML Methods"></a>HTML Methods</h4><p>203页</p>
<h2 id="Singleton-Built-in-objects-单体内置对象"><a href="#Singleton-Built-in-objects-单体内置对象" target="_blank" rel="noopener" class="headerlink" title="Singleton Built-in objects  单体内置对象"></a>Singleton Built-in objects  单体内置对象</h2><p>203</p>
<h3 id="The-Global-Object"><a href="#The-Global-Object" target="_blank" rel="noopener" class="headerlink" title="The Global Object"></a>The Global Object</h3><p>203</p>
<h4 id="URI-Encoding-Methods"><a href="#URI-Encoding-Methods" target="_blank" rel="noopener" class="headerlink" title="URI-Encoding Methods"></a>URI-Encoding Methods</h4><h4 id="The-eval-Method"><a href="#The-eval-Method" target="_blank" rel="noopener" class="headerlink" title="The eval() Method"></a>The eval() Method</h4><p>205页</p>
<h4 id="Global-Object-Properties"><a href="#Global-Object-Properties" target="_blank" rel="noopener" class="headerlink" title="Global Object Properties"></a>Global Object Properties</h4><p>206页</p>
<h4 id="The-Window-Object"><a href="#The-Window-Object" target="_blank" rel="noopener" class="headerlink" title="The Window Object"></a>The Window Object</h4><p>207页</p>
<h3 id="The-Math-Object"><a href="#The-Math-Object" target="_blank" rel="noopener" class="headerlink" title="The Math Object"></a>The Math Object</h3><p>207页</p>
<h4 id="Math-Object-Properties"><a href="#Math-Object-Properties" target="_blank" rel="noopener" class="headerlink" title="Math Object Properties"></a>Math Object Properties</h4><h4 id="The-min-and-max-Methods"><a href="#The-min-and-max-Methods" target="_blank" rel="noopener" class="headerlink" title="The min() and max() Methods"></a>The min() and max() Methods</h4><h4 id="Rounding-Methods"><a href="#Rounding-Methods" target="_blank" rel="noopener" class="headerlink" title="Rounding Methods"></a>Rounding Methods</h4><h4 id="The-random-Method"><a href="#The-random-Method" target="_blank" rel="noopener" class="headerlink" title="The random() Method"></a>The random() Method</h4><h4 id="Other-Methods"><a href="#Other-Methods" target="_blank" rel="noopener" class="headerlink" title="Other Methods"></a>Other Methods</h4><h2 id="Summary-1"><a href="#Summary-1" target="_blank" rel="noopener" class="headerlink" title="Summary"></a>Summary</h2><h1 id="COLLECTION-REFERENCE-TYPES"><a href="#COLLECTION-REFERENCE-TYPES" target="_blank" rel="noopener" class="headerlink" title="COLLECTION REFERENCE TYPES"></a>COLLECTION REFERENCE TYPES</h1><h2 id="The-object-Type"><a href="#The-object-Type" target="_blank" rel="noopener" class="headerlink" title="The object Type"></a>The object Type</h2><p>到目前为止，大多数的引用类型值都是Object 类型，这是JS中最常用的类型之一，尽管object的实例不具备多少功能，但他们非常适合在应用程序中存储和传输数据<br>创建object实例的方式有两种，第一种是使用new操作符后跟object构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span></span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用对象字面量表示法，对面字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span></span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，左边的花括号 { 表示对象字面量的开始，因为它出现在了表达式上下文中。JS 中的表达式上下文值的是能够返回一个值（表达式）。赋值操作符表示后面是一个 值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个语句上下文中，例如跟在if 语句条件的后面，则表示一个语句块的开始。<br>然后我们定义了name属性，之后就是一个冒号，在后面是这个属性的值。 在对象字面量中，使用逗号来分隔不同的属性，因此”Nicholas” 后面是一个逗号但是在age属性的值29后面不能添加逗号，因为age是这个对象的最后一个属性<br>在使用对象字面量语法的时候，属性名也可以使用字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    <span class="string">"age"</span>: <span class="number">29</span>,  </span><br><span class="line">    <span class="number">5</span>: <span class="literal">true</span> </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子会创建一个对象，包含三个属性，name age 和 5， 但这里的数值属性名会自动转换为字符串。<br>另外，使用对象字面量语法的时候，如果留空其花括号，则可以定义质保函默认属性和方法的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;  <span class="comment">// same as new Object() </span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>虽然可以使用前面介绍的任意一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉，实际上，对象字面量也是向函数传递大量可选参数的首选方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">""</span>;             </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args.name == <span class="string">"string"</span>)&#123;    </span><br><span class="line">        output += <span class="string">"Name: "</span> + args.name + <span class="string">"\n"</span>;  &#125;             </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args.age == <span class="string">"number"</span>) &#123;    </span><br><span class="line">        output += <span class="string">"Age: "</span> + args.age + <span class="string">"\n"</span>;  &#125;             </span><br><span class="line">    alert(output); &#125;           </span><br><span class="line">    displayInfo(&#123;   <span class="attr">name</span>: <span class="string">"Nicholas"</span>,   <span class="attr">age</span>: <span class="number">29</span> &#125;);          </span><br><span class="line">    displayInfo(&#123;  <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，displayInfo() 接受一个名为args 的参数，该参数可能带有一个名为name 或者age 的属性。也可能这两个属性都有或者都没有。在这个函数内部，我们通过typeof 操作符来检测每个属性是否存在，然后在基于相应的属性来构建一条要显示的消息。然后，我们调用了两次这个函数，每次都使用一个对象字面量来制定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。<br>尽管访问对象属性时使用的都是点表示法，这是很多面相对象语言中通用的语法。不过在JS 也可以使用方括号表示法来访问对象的属性。在使用方括号语法的时候，应该将要访问的属性以字符串的形式放在方括号中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person&#123;<span class="string">"name"</span>&#125;) <span class="comment">// NICHOLAS</span></span><br><span class="line">alert(person.name) <span class="comment">// NICHOLAS</span></span><br></pre></td></tr></table></figure>
<p>从功能上看，这两种访问对象属性的方法没有任何区别，但是方括号语法的主要优点是可以通过变量来访问属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">"name"</span></span><br><span class="line">alert&#123;person[propertyName]&#125; <span class="comment">// Nicholas</span></span><br></pre></td></tr></table></figure>
<p>当属性名称包含可能是语法错误，或关键字的字符时候，也可以使用括号表示法<br>person[“first name”] = “Nicholas”<br>由于first name 中包含一个空格，所以不能使用点表示法来访问他，然而，属性名中可以是包含非字母非数字的，这时候就可以方括号来访问他们</p>
<h2 id="The-Array-Type-170"><a href="#The-Array-Type-170" target="_blank" rel="noopener" class="headerlink" title="The Array Type 170"></a>The Array Type 170</h2><p>在Object 类型之外，Array类型恐怕是JS 中最常用的类型了。而且，js中的数组与其他多数语言中的数组有着很大的区别。虽然JS 数组与其他语言中的数组都是数据的有序列表，但是不同的是，JS数组的每一项可以保存任何类型的数据，也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象。数组的大小是可以动态掉秤的，既可以随着数据的添加自动增长以容纳新的数据。</p>
<h3 id="Creating-Arrays-170"><a href="#Creating-Arrays-170" target="_blank" rel="noopener" class="headerlink" title="Creating Arrays 170"></a>Creating Arrays 170</h3><p>创建数组的基本方式有两种，第一种是使用Array构造函数<br>let colors = new Array()<br>如果乳腺知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length 属性的值。 例如，下面的代码将创建length值为20的数组。<br>let colors = new Array(20)<br>也可以像Array 构造函数传递数组中应该包含的项。以下代码创建了一个包含3个字符串值的数组<br>let colors = new Array(“red”,”blue”,”green”)<br>给构造函数传递一个值也可以创建数组，但这个时候问题就复杂一点了，因为如果传递的是数值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// 创建一个包含3项的数组</span></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>) <span class="comment">// 创建一个包含一项，即字符串Greg的数组</span></span><br></pre></td></tr></table></figure>
<p>另外，在使用构造函数的时候也可以省略new操作符，<br>let colors = Array(3) //<br>let names = Array(“Greg”)<br>创建数组的第二种基本方式是使用数组字面量表示法，数组字面量由一堆包含数组项的方括号表示，多个数组项之前以逗号隔开。<br>let colors = [“red”,”blue”,”green”] // 创建一个数组包含3个字符串。<br>let name = [] // 创建一个空数组<br>let values = [1,2,] // 不要这样，这样会创建一个包含2项<br> 在此代码中第一行创建了一个包含3个字符串的数组，第二行使用一对空方括号创建了一个空数组。第三行展示了在数组字面量的最后一项添加逗号的结果： values 回城为一个包含2项且值分别为1和2 的数组。<br> 数组构造函数在ES6中还引入了两个额外的静态方法来创建数组，from()和of() 。 from() 用于将类似数组的构造转换为数组的实例。而of() 用于将参数集合转换为数组实例。<br> Array.from() 的第一个参数是 arrayLike 对象，该对象是可迭代或者具有属性长度和索引元素的任何对象。这种类型可以大量使用。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Strings will be broken up into an array of single characters alert</span></span><br><span class="line"> (<span class="built_in">Array</span>.from(<span class="string">"Matt"</span>));  <span class="comment">// ["M", "a", "t", "t"]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Sets and Maps can be converted into an new array instance using from() </span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="number">1</span>, <span class="number">2</span>)                   </span><br><span class="line">                    .set(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="number">1</span>)                   </span><br><span class="line">                    .add(<span class="number">2</span>)                   </span><br><span class="line">                    .add(<span class="number">3</span>)                   </span><br><span class="line">                    .add(<span class="number">4</span>);</span><br><span class="line">alert(<span class="built_in">Array</span>.from(m));  <span class="comment">// [[1, 2], [3, 4]] </span></span><br><span class="line">alert(<span class="built_in">Array</span>.from(s));  <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"> <span class="comment">// Array.from() performs a shallow copy of an existing array </span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1);</span><br><span class="line">alert(a1);         <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line">alert(a1 === a2);  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Any iterable object can be used </span></span><br><span class="line"><span class="keyword">const</span> iter = &#123;  </span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;    </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;    </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;     </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;    </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">  &#125; &#125;; </span><br><span class="line">alert(<span class="built_in">Array</span>.from(iter));  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// The arguments object can now easily be casted into an array: </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgsArray</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>); &#125; </span><br><span class="line">alert(getArgsArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// from() will happily use a custom object with required properties </span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123;  <span class="number">0</span>: <span class="number">1</span>,  <span class="number">1</span>: <span class="number">2</span>,   <span class="number">2</span>: <span class="number">3</span>,  <span class="number">3</span>: <span class="number">4</span>,  <span class="attr">length</span>: <span class="number">4</span> &#125;; </span><br><span class="line">alert(<span class="built_in">Array</span>.from(arrayLikeObject));  <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><br> Array.from () 还接受第二个可选的map函数参数，这样无需先创建中间数组就可以增加新数组的值，如果使用Array.from() 。 map() 进行了相同操作，变回出现这种情况。第三个可选参数指定map函数内部的this的，覆盖的this值不适用于箭头函数。、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1, x =&gt; x**<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> a3 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x**<span class="keyword">this</span>.exponent&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;); </span><br><span class="line">alert(a2);  <span class="comment">// [1, 4, 9, 16] alert(a3);  // [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>
<p>Array.of 会将参数列表转换为数组，这可以代替异常笨拙的Array.prototype.slice.call(arguments) 将参数对象转换为数组的ES6之前的通用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// [1,2,3,4]</span></span><br><span class="line">alert(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>))<span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-Holes-172-数组空"><a href="#Array-Holes-172-数组空" target="_blank" rel="noopener" class="headerlink" title="Array Holes 172  数组空"></a>Array Holes 172  数组空</h3><p>使用数组字面量初始化数组可以使用顺序逗号来创建空洞。 js 将逗号之间的索引处的值视为一个孔，并且ES6规范了如何处理这些孔。<br>可能会如下创建数组孔</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [,,,,,];  <span class="comment">// Creates an array with 5 items </span></span><br><span class="line">alert(options.length);    <span class="comment">// 5 </span></span><br><span class="line">alert(options);           <span class="comment">// [,,,,,]</span></span><br></pre></td></tr></table></figure>
<p>ES6中引用的方法和迭代器的行为与早期JS 版本中存在的方法不同，ES6的添加将把这些孔普遍视为值为undefined的现有条目。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123;  </span><br><span class="line">    alert(option === <span class="literal">undefined</span>); &#125; </span><br><span class="line">    <span class="comment">// false </span></span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Array</span>.from([,,,]);  <span class="comment">// Array of 3 holes created with ES6's Array.from() </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> a) &#123;  </span><br><span class="line">    alert(val === <span class="literal">undefined</span>); &#125; </span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="built_in">Array</span>.of(...[,,,]));  <span class="comment">// [undefined, undefined, undefined]</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> options.entries()) &#123;  </span><br><span class="line">    alert(value); &#125; </span><br><span class="line">    <span class="comment">// 1 </span></span><br><span class="line">    <span class="comment">// undefined </span></span><br><span class="line">    <span class="comment">// undefined </span></span><br><span class="line">    <span class="comment">// undefined </span></span><br><span class="line">    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>相反，ES6之前可用的方法往往会忽略这些漏洞，尽管确切的行为可能在方法之间略有不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// map() will skip the holes entirely </span></span><br><span class="line">alert(options.map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">6</span>));  <span class="comment">// [6, undefined, undefined, undefined, 6]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// join() treats holes as empty strings </span></span><br><span class="line">alert(options.join(<span class="string">'-'</span>));     <span class="comment">// "1----5"</span></span><br></pre></td></tr></table></figure>
<h3 id="Indexing-into-Arrays-174"><a href="#Indexing-into-Arrays-174" target="_blank" rel="noopener" class="headerlink" title="Indexing into Arrays 174"></a>Indexing into Arrays 174</h3><p>要读取和设置数值，请使用方括号并提供响应值的基于0的数字索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// define an array of strings </span></span><br><span class="line">alert(colors[<span class="number">0</span>]);                       <span class="comment">// display the first item </span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">"black"</span>;                    <span class="comment">// change the third item </span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"brown"</span>;                    <span class="comment">// add a fourth item</span></span><br></pre></td></tr></table></figure>
<p>方括号中的索引表示要访问的值，如果索引小于数组中的项数，则返回对应项的值，就像这个例子中的colors[0] 会显示red 一样。设置数组的值也使用相同的语法，但会替换指定位置的值。如果设置某个值的索引超过了数组现有项数，如这个例子中的colors[3]所示，数组就会自动增加到该索引加1的长度。<br>数组中的项数保存在其length属性中，这个属性始终会返回0或者更大的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line"><span class="keyword">let</span> names = [];                         <span class="comment">// creates an empty array           </span></span><br><span class="line">alert(colors.length);  <span class="comment">// 3 </span></span><br><span class="line">alert(names.length);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>数组的length属性很有特点，它不是只读的，因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">colors.length = <span class="number">2</span>; </span><br><span class="line">alert(colors[<span class="number">2</span>]);  <span class="comment">// undefine</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的数组colors 一开始有3个值，将其length属性设置为2 会移除最后一项（位置为2的哪一项），结果在访问colors[2]就会显示undefined了，如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">colors.length = <span class="number">4</span>; </span><br><span class="line">alert(colors[<span class="number">3</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>虽然colors 数组包含3个项，但把它的length属性设置成了4。 这个数组不存在位置3 ，所以访问这个位置的值就得到了特殊值undefined<br>利用length属性也可以方便的在数组末尾添加新项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">colors[colors.length] = <span class="string">"black"</span>;        <span class="comment">// add a color (position 3) </span></span><br><span class="line">colors[colors.length] = <span class="string">"brown"</span>;        <span class="comment">// add another color (position 4)</span></span><br></pre></td></tr></table></figure>
<p>由于数组的最后一项的索引始终是length-1, 因此下一个新项的位置就是length。每当数组末尾添加一项后，其length 属性都会自动更新以反映这一变化。欢聚话说，上面例子第二行中的colors[colors.length] 为位置3 添加了一个值，最后一行的colors[colors.length]则为位置4添加了一个值，当吧一个值放在超出当前数组大小的位置上的时候，数组就会重新计算其长度值，即长度值等于最后一项的索引加1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">"black"</span>;                   <span class="comment">// add a color (position 99) </span></span><br><span class="line">alert(colors.length);                   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，向colors数组的位置99插入一个值，结果数组新长度length就是100（99+1） ，而位置3 到位置98 实际上都是不存在的。</p>
<h3 id="Detecting-Arrays-175"><a href="#Detecting-Arrays-175" target="_blank" rel="noopener" class="headerlink" title="Detecting Arrays 175"></a>Detecting Arrays 175</h3><p>经典的ECMA问题是确定某个对象是不是数组的经典问题。对于一个网页或者一个全局作用域而言，使用instanceof 操作符就能得到满意的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123; </span><br><span class="line">     <span class="comment">// do something on the array &#125;</span></span><br></pre></td></tr></table></figure>
<p>instanceof 的一个问题在于，它假定只有一个全局执行环境，如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数，如果你从一个框架箱另一个框架传入一个数组。那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数<br>为了解决这个问题，JS 提供了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123; </span><br><span class="line">     <span class="comment">// do something on the array &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Iterator-Methods-176-迭代器方法"><a href="#Iterator-Methods-176-迭代器方法" target="_blank" rel="noopener" class="headerlink" title="Iterator Methods 176  迭代器方法"></a>Iterator Methods 176  迭代器方法</h3><p>在ES6中，数组原型上公开了三种新方法，可以检查数组的内容：keys(), values(), 和 entries()。 keys()将返回数组索引的迭代器。values() 将返回数组元素的迭代器， entries() 将返回索引/值对的迭代器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"qux"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Because these methods return iterators, you can funnel their contents </span></span><br><span class="line"><span class="comment">// into array instances using Array.from() </span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="built_in">Array</span>.from(a.keys()); </span><br><span class="line"><span class="keyword">const</span> aValues = <span class="built_in">Array</span>.from(a.values()); </span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="built_in">Array</span>.from(a.entries());</span><br><span class="line"> </span><br><span class="line">alert(aKeys);     <span class="comment">// [0, 1, 2, 3] </span></span><br><span class="line">alert(aValues);   <span class="comment">// ["foo", "bar", "baz", "qux"] </span></span><br><span class="line">alert(aEntries);  <span class="comment">// [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]</span></span><br></pre></td></tr></table></figure>
<p>ES6 结构意味着现在很容易在循环内拆分键值对</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"qux"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.entries()) [ </span><br><span class="line">     alert(idx);  </span><br><span class="line">     alert(element); &#125; </span><br><span class="line">     <span class="comment">// 0 </span></span><br><span class="line">     <span class="comment">// foo </span></span><br><span class="line">     <span class="comment">// 1 </span></span><br><span class="line">     <span class="comment">// bar </span></span><br><span class="line">     <span class="comment">// 2 </span></span><br><span class="line">     <span class="comment">// baz </span></span><br><span class="line">     <span class="comment">// 3 </span></span><br><span class="line">     <span class="comment">// qux</span></span><br></pre></td></tr></table></figure>
<h3 id="Copy-and-Fill-Methods-176"><a href="#Copy-and-Fill-Methods-176" target="_blank" rel="noopener" class="headerlink" title="Copy and Fill Methods 176"></a>Copy and Fill Methods 176</h3><p>ES6 的新增功能是fill() 和copyWithin() 这两种方法。他们分别允许数组内批量填充和复制。两种方法都有类似的函数签名，因为他们允许使用包含的开始索引和包含的结束索引来制定现有数组实例中的范围，使用此方法的数组将永远不会调整大小。<br>fill() 方法允许将相同的值插入到现有数组的全部或者一部分中。制定可选的歧视索引将指示填充从该索引开始，除非提供了终止索引,否则填充将继续到数组的末尾。负索引从数组末尾开始解释，另一的思考方式是，福索引具有添加到他们的数组长度以计算正索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// Fill the entire array with 5 </span></span><br><span class="line">zeroes.fill(<span class="number">5</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [5, 5, 5, 5, 5] </span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);  <span class="comment">// reset</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill all indices &gt;=3 with 6 </span></span><br><span class="line">zeroes.fill(<span class="number">6</span>, <span class="number">3</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 6, 6] </span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);  <span class="comment">// reset</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill all indices &gt;= 1 and &lt; 3 with 7 </span></span><br><span class="line">zeroes.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 7, 7, 0, 0]; </span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);  <span class="comment">// reset</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill all indices &gt;=1 and &lt; 4 with 8 </span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1) </span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4) </span></span><br><span class="line">zeroes.fill(<span class="number">8</span>, <span class="number">-4</span>, <span class="number">-1</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 8, 8, 8, 0];</span></span><br></pre></td></tr></table></figure>
<p>fill() 默默的忽略超出数组边界，长度为0或者倒退的范围。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill with too low indices is noop </span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, <span class="number">-10</span>, <span class="number">-6</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill with too high indices is noop </span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill with reversed indices is noop </span></span><br><span class="line">zeroes.fill(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill with partial index overlap is best effort </span></span><br><span class="line">zeroes.fill(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>) </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 4, 4]</span></span><br></pre></td></tr></table></figure>
<p>与fill() 不同，copyWithin() 会执行一些数组迭代浅拷贝，并覆盖从提供的索引处开始的现有值，但是他对开始和结束索引使用的相同的约定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,    </span><br><span class="line">reset = <span class="function"><span class="params">()</span> =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; reset();</span><br><span class="line"><span class="comment">// 将从索引0 开始ints 内容复制到索引5开始的值。 </span></span><br><span class="line"><span class="comment">// 在到达数组的末尾的时候停止</span></span><br><span class="line"><span class="comment">// 索引或者目标索引。</span></span><br><span class="line">ints.copyWithin(<span class="number">5</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] </span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将以索引5开始的ints内容复制到，以索引0开始的值</span></span><br><span class="line">ints.copyWithin(<span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9] </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将从索引0开始到索引3结束的内容复制到值</span></span><br><span class="line"><span class="comment">// 从索引4开始</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// JS 引擎将在之前插入执行之范围的完整拷贝</span></span><br><span class="line"><span class="comment">// 所以在复制过程中没有覆盖的危险.</span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]  </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 支持否定索引的行为与该否定索引的fill()相同</span></span><br><span class="line"><span class="comment">// 相对于数组末尾计算索引</span></span><br><span class="line">ints.copyWithin(<span class="number">-4</span>, <span class="number">-7</span>, <span class="number">-3</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>CopyWithin () 默默的忽略超出数组边界，长度为0 ，或者倒退的范围。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,    </span><br><span class="line">reset = <span class="function"><span class="params">()</span> =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy with too low indices is noop </span></span><br><span class="line">ints.copyWithin(<span class="number">1</span>, <span class="number">-15</span>, <span class="number">-12</span>); </span><br><span class="line">alert(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line">reset()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy with too high indices is noop </span></span><br><span class="line">ints.copyWithin(<span class="number">1</span>, <span class="number">12</span>, <span class="number">15</span>); </span><br><span class="line">alert(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy with reversed indices is noop </span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line">alert(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy with partial index overlap is best effort </span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>) </span><br><span class="line">alert(ints);   <span class="comment">// [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];</span></span><br></pre></td></tr></table></figure>
<h3 id="Conversion-Methods-179-转换方法"><a href="#Conversion-Methods-179-转换方法" target="_blank" rel="noopener" class="headerlink" title="Conversion Methods 179  转换方法"></a>Conversion Methods 179  转换方法</h3><p>所有的对象都具有toLocaleString(), toString() 和valueOf方法。其中，嗲用数组的toString() 和valueOf() 返回相同的值。结果是一个逗号分隔的字符串，其中包含数组中每个值的等效字符串。也就是说，为了创建这个字符串会嗲用数组每一项的toString()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">alert(colors.toString());  <span class="comment">// red,blue,green </span></span><br><span class="line">alert(colors.valueOf());   <span class="comment">// red,blue,green </span></span><br><span class="line">alert(colors);             <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure>
<p>在这里，首先显式的调用了toString() 方法和valueOf() 方法，以便返回数组的字符串表示，每个值的字符串表示拼接在了一起，中间以逗号分隔。最后一行将数值直接传递到alert() 中，因为alert() 需要一个字符串，所以它在后台调用toString() 来获得与直接调用toString() 的时候相同的结果。<br>toLocalString()方法可能最终返回与toString() 和valueOf() 方法相同的值，但也不是如此，当调用数组的toLocaleString()方法的时候，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的每一项的toLocaleString()方法，而不是toString() 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = &#123;  </span><br><span class="line">    toLocaleString() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nikolaos"</span>;  &#125;,    </span><br><span class="line">    toString() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span>;  &#125; &#125;;           </span><br><span class="line"><span class="keyword">let</span> person2 = &#123;  </span><br><span class="line">    toLocaleString() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Grigorios"</span>;  &#125;,    </span><br><span class="line">    toString() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Greg"</span>;  &#125; &#125;;           </span><br><span class="line"><span class="keyword">let</span> people = [person1, person2]; </span><br><span class="line">alert(people);                   <span class="comment">// Nicholas,Greg </span></span><br><span class="line">alert(people.toString());        <span class="comment">// Nicholas,Greg </span></span><br><span class="line">alert(people.toLocaleString());  <span class="comment">// Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure>
<p>此处定义了两个对象 person1 和person2。 而且还分别为每个对象定义了一个toString() 方法和一个toLocaleString(), 这两个方法返回不同值。然后创建一个包含前面定义的两个对象的数组。在将数组传递给alert() 的时候，输出的结果是Nicholas, Greg 。因为调用了数组的每一项的toString() 方法，同样这与下一行显示调用toString()方法得到的结果相同。而当调用数组的toLocaleString() 方法的时候，输出结果是Nikolaos,grigorios。 原因是调用了数组每一项的toLocaleString()方法。<br>数组继承的toLocaleString() , toString() 和valueOf() 方法，在默认情况下都会以逗号分隔字符串的形式返回数组项。而如果使用join(),则可以使用不同的分隔符来构建这个字符串。join()方法只接受一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]; </span><br><span class="line">alert(colors.join(<span class="string">","</span>));    <span class="comment">// red,green,blue </span></span><br><span class="line">alert(colors.join(<span class="string">"||"</span>));   <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure>
<p>在这里，使用join()方法重现了toSting() 方法的输出。在传递逗号的情况下，得到了以逗号分隔的数值组。而在最后一行代码中，我们传递了双竖线符号，结果就得到了字符串red||green||blue。 如果不给join()方法传入任何值，或者传入undefined，则使用逗号作为分隔符、</p>
<h3 id="Stack-Methods-180-栈方法"><a href="#Stack-Methods-180-栈方法" target="_blank" rel="noopener" class="headerlink" title="Stack Methods 180 栈方法"></a>Stack Methods 180 栈方法</h3><p>JS 数组也提供了一种让数组的行为类似于其他数据结构的方法。具体来说，数组可以表现的像栈一样，后者是一种可以限制插入的和删除项的数据结构。栈是一种LIFO （Last-In-First-Out 后进先出）的数据结构，也就是最新的添加的项最早被移除。而栈中项的插入（叫做推入）和删除(称为弹出) 只发生在一个位置 - 栈的顶部。JS 为数组专门提供了push() 和pop() 方法，以便实现类似栈的行为。<br>push()方法 接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度。而pop() 方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                 <span class="comment">// create an array </span></span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);  <span class="comment">// push two items </span></span><br><span class="line">alert(count);                             <span class="comment">// 2         </span></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);  <span class="comment">// push another item on </span></span><br><span class="line">alert(count);                  <span class="comment">// 3           </span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop();  <span class="comment">// get the last item </span></span><br><span class="line">alert(item);              <span class="comment">// "black" </span></span><br><span class="line">alert(colors.length);     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，创建了一个数组以用作栈。首先使用push()将两个字符串推入数组的末尾，并将返回的结果保存在变量count中，然后在推入一个值，而结果仍然保存在count 中。 因为此时数组中包含3项，所以push() 返回3。 在调用pop() 的时候，它会返回数组的最后一项，即字符串black。 此后，数组中仅剩两项。<br>可以将栈方法与其他数组方法连用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>]; </span><br><span class="line">colors.push(<span class="string">"brown"</span>);          <span class="comment">// add another item </span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;           <span class="comment">// add an item </span></span><br><span class="line">alert(colors.length);          <span class="comment">// 4           </span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop();       <span class="comment">// get the last item </span></span><br><span class="line">alert(item);                   <span class="comment">// "black"</span></span><br></pre></td></tr></table></figure>
<p>在此，首先用两个值来初始化一个数组，然后使用push() 添加第三个值，在通过直接在位置3 上赋值来添加第四个值，而在调用pop()的时候，该方法返回了字符串black ，即最后一个添加到数组的值。</p>
<h3 id="Queue-Methods-181-队列方法"><a href="#Queue-Methods-181-队列方法" target="_blank" rel="noopener" class="headerlink" title="Queue Methods 181 队列方法"></a>Queue Methods 181 队列方法</h3><p>栈数据结构的访问规则是LIFO 后进先出， 而队列数据结构的访问规则是FIFO 先进先出。队列在列表的末端添加项，从列表的前端移除项。由于push() 是向数组末端添加项的方法，因此要模拟队列只需从一个数组前端取得项的方法。实现这一操作的数组方法就是shift(),它能够移除数组中的第一项并返回该项。它能够移除数组中的第一项并返回该项，同时数组长度减少1.结合使用shift()和push() 方法，可以像用队列一样使用数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                 <span class="comment">// create an array </span></span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);  <span class="comment">// push two items </span></span><br><span class="line">alert(count);                             <span class="comment">// 2         </span></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);  <span class="comment">// push another item on </span></span><br><span class="line">alert(count);                  <span class="comment">// 3           </span></span><br><span class="line"><span class="keyword">let</span> item = colors.shift();  <span class="comment">// get the first item </span></span><br><span class="line">alert(item);                <span class="comment">// "red" </span></span><br><span class="line">alert(colors.length);       <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这个例子首先使用push() 方法创建了一个包含三种颜色名称的数组。代码中加粗的那一行使用shift()方法从数组中取得了第一项，即red。在移除第一项之后，green就变成了第一项，而black则变成了第二项，数组也就值包含两项了。<br>JS 还未数组提供了一个unshift() 方法，顾名思义，unshift()与shift() 的用途相反，它能在数组最前端添加任意个项并返回新数组的长度。因此同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                    <span class="comment">// create an array </span></span><br><span class="line"><span class="keyword">let</span> count = colors.unshift(<span class="string">"red"</span>, <span class="string">"green"</span>);  <span class="comment">// push two items</span></span><br><span class="line">alert(count);                                <span class="comment">// 2      </span></span><br><span class="line">count = colors.unshift(<span class="string">"black"</span>);  <span class="comment">// push another item on </span></span><br><span class="line">alert(count);                     <span class="comment">// 3           </span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop();  <span class="comment">// get the first item </span></span><br><span class="line">alert(item);              <span class="comment">// "green" </span></span><br><span class="line">alert(colors.length);     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这个例子，创建了一个数组并使用unshift()方法先后推入了3个值，首先是red 和green 然后是black。 数组中各项的顺序为black,red,green。 在调用pop()方法的时候，移除并返回的是最后一项，即green</p>
<h3 id="Reordering-Methods-重排序方法"><a href="#Reordering-Methods-重排序方法" target="_blank" rel="noopener" class="headerlink" title="Reordering Methods 重排序方法"></a>Reordering Methods 重排序方法</h3><p>有两种方法直接处理数组中已有项目的重新排序： reverse()和sort() 。正如期望的那样，reverse()方法会反转数组项的顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line">values.reverse(); </span><br><span class="line">alert(values);  <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure>
<p>这里数组的初始值以及顺序是12345， 而调用数组的reverse()方法后，其值的顺序变成了54321。这个方法的作用相当至关明了，但是不够灵活，因此才有sort()方法<br>默认情况下，sort()方法将项目按升序排列数组想，即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString() 转型方法，然后比较得到的字符串，以确定如何排序。 即使数组中的每一项都是数组，sort()方法比较的也是字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(); </span><br><span class="line">alert(values);  <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>即使本案例中的值顺序没有问题。但sort()方法也会根据测试字符串的结果改变原来的顺序，虽然数值5小于10 ，但是在进行字符串比较的时候，字符串10 会位于5之前。于是数组的顺序就被修改了，不用说这种排序方式在很多情况下都不是最佳方法。因此sort()方法可以接受一个比较函数作为参数，以便我们制定哪个值位于哪个值的前面。<br>比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0。 如果第一个参数应该位于第二个之后，则返回一个整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>此比较函数使用与大多数据类型，可以将其作为参数传递给sort()方法来使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(compare); </span><br><span class="line">alert(values);  <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>当比较函数传递给sort()方法时候，数字将保持正确的顺序，当然如果也可以通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;    <span class="keyword">return</span> <span class="number">1</span>;  &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;    <span class="keyword">return</span> <span class="number">-1</span>;  &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="keyword">return</span> <span class="number">0</span>;  &#125; &#125;           </span><br><span class="line">    <span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">    values.sort(compare); </span><br><span class="line">    alert(values);  <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure>
<p>或者，可以缩短比较功能将其定义为嵌入式箭头函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a &lt; b ? a &gt; b ? <span class="number">-1</span> : <span class="number">0</span>); </span><br><span class="line">alert(values);  <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure>
<p>在此修改的实例中，如果第一个值应该在第二个值之后，则比较函数返回1，如果第一个值应该在第二个值之前，则比较函数返回-1。交换这些意味着较大的值首先出现，并且数组将按降序排序，当然如果指向反转数组中项目的顺序，则reverse() 比排序要快的多。<br>比较函数的简单版本可以用于数值类型和其valueOf()方法返回数值的对象（例如Date对象）无论哪种情况，都可以从第一个值中减去第二个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;  <span class="keyword">return</span> value2 - value1; &#125;</span><br></pre></td></tr></table></figure>
<p>因为比较函数通过返回小于0,0或大于0的数字来工作，所以减法运算符将适当处理所有情况。</p>
<h3 id="Manipulation-Methods-184-操作方法"><a href="#Manipulation-Methods-184-操作方法" target="_blank" rel="noopener" class="headerlink" title="Manipulation Methods 184 操作方法"></a>Manipulation Methods 184 操作方法</h3><p>JS 为操作已经包含在数组中的项提供了很多方法。 其中concat()方法可以基于当前数组中的所有项创建一个新数组。这个方法首先创建数组的副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，他只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单的添加到结果数组的末尾。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);           </span><br><span class="line">alert(colors);   <span class="comment">// ["red", "green","blue"]    </span></span><br><span class="line">alert(colors2);  <span class="comment">// ["red", "green", "blue", "yellow", "black", "brown"]</span></span><br></pre></td></tr></table></figure>
<p>以上代码开始定义了一个包含3个值的数组colors，然后基于colors调用了concat()方法，并传入字符串yellow 和一个包含black 和brown的数组。最终结果数组color2 中包含了red”, “green”, “blue”, “yellow”, “black”, “brown” 至于原来的数组colors 其中的值仍然保持不变。<br>可以通过在参数实例symbol.isConcatSpread 上制定特殊符号来覆盖强制平化默认行为。这将放置concat()方法使结果扁平，相反的将值设置为true 将迫使将类似数组的对象展平</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]; </span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">"black"</span>, <span class="string">"brown"</span>]; </span><br><span class="line"><span class="keyword">let</span> moreNewColors = &#123;  </span><br><span class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,  </span><br><span class="line">    length: <span class="number">2</span>,  </span><br><span class="line">    <span class="number">0</span>: <span class="string">"pink"</span>,  </span><br><span class="line">    <span class="number">1</span>: <span class="string">"cyan"</span> &#125;;</span><br><span class="line">newColors[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Force the array to not be flattened </span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">"yellow"</span>, newColors);</span><br><span class="line"><span class="comment">// 强制不展平数组</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Force the array-like object to be flattened </span></span><br><span class="line"><span class="comment">// 强制将类似数组的对象展平</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colors.concat(moreNewColors);           alert(colors);   <span class="comment">// ["red", "green","blue"]    </span></span><br><span class="line">alert(colors2);  <span class="comment">// ["red", "green", "blue", "yellow", ["black", "brown"]] </span></span><br><span class="line">alert(colors3);  <span class="comment">// ["red", "green", "blue", "pink, "cyan"</span></span><br></pre></td></tr></table></figure>
<h3 id="Search-and-Location-Methods-186"><a href="#Search-and-Location-Methods-186" target="_blank" rel="noopener" class="headerlink" title="Search and Location Methods 186"></a>Search and Location Methods 186</h3><h4 id="Strict-Equivalence-186"><a href="#Strict-Equivalence-186" target="_blank" rel="noopener" class="headerlink" title="Strict Equivalence 186"></a>Strict Equivalence 186</h4><h4 id="Predicate-Search-187"><a href="#Predicate-Search-187" target="_blank" rel="noopener" class="headerlink" title="Predicate Search 187"></a>Predicate Search 187</h4><h3 id="Iterative-Methods-188"><a href="#Iterative-Methods-188" target="_blank" rel="noopener" class="headerlink" title="Iterative Methods 188"></a>Iterative Methods 188</h3><h3 id="Reduction-Methods-189"><a href="#Reduction-Methods-189" target="_blank" rel="noopener" class="headerlink" title="Reduction Methods 189"></a>Reduction Methods 189</h3><h2 id="Typed-Arrays-190"><a href="#Typed-Arrays-190" target="_blank" rel="noopener" class="headerlink" title="Typed Arrays 190"></a>Typed Arrays 190</h2><p>History 190<br>WebGL 190<br>Emergence of Typed Arrays 191<br>Using ArrayBuffers 191<br>DataViews 192<br>ElementType 193<br>Big-Endian and Little-Endian 194<br>Corner Cases 195<br>Typed Arrays 196<br>Typed Array Behavior 197<br>Merging, Copying, and Changing Typed Arrays 198<br>Underflow and Overflow 200 The Map Type 201<br>Basic API 201 Order and Iteration 203<br>Choosing Between Objects and Maps 206<br>Memory Profile 206<br>Insertion Performance 206<br>Lookup Performance 206<br>Delete Performance 206<br>The WeakMap Type 206<br>Basic API 207<br>Weak Keys 208<br>Non-Iterable Keys 209<br>Utility 209<br>Private Variables 209<br>DOM Node Metadata 211<br>The Set Type 211<br>Basic API 211<br>Order and Iteration 213<br>Defining Formal Set Operations 215<br>The WeakSet Type 217<br>Basic API 217<br>Weak Keys 219<br>Non-Iterable Values 219<br>Utility 219<br>Iteration and Spread operators 220<br>Summary </p>
<h1 id="ITERATORS-AND-GENERATORS"><a href="#ITERATORS-AND-GENERATORS" target="_blank" rel="noopener" class="headerlink" title="ITERATORS AND GENERATORS"></a>ITERATORS AND GENERATORS</h1>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="2020/02/08/vue学习/" target="_blank" rel="prev noopener" title="vue学习">
                vue学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Luxin Z</p>
              <p class="site-description motion-element" itemprop="description">用于分享读书笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/" target="_blank" rel="noopener">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#变量，-范围，-和-内存" target="_blank" rel="noopener"><span class="nav-number">1.</span> <span class="nav-text">变量， 范围， 和 内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#primitive-原始值-和-reference-values-引用值" target="_blank" rel="noopener"><span class="nav-number">1.1.</span> <span class="nav-text">primitive 原始值 和 reference values 引用值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynamic-properties-动态属性" target="_blank" rel="noopener"><span class="nav-number">1.1.1.</span> <span class="nav-text">Dynamic properties 动态属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Copying-Values-复制值" target="_blank" rel="noopener"><span class="nav-number">1.1.2.</span> <span class="nav-text">Copying Values 复制值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Argument-Passing-参数传递" target="_blank" rel="noopener"><span class="nav-number">1.1.3.</span> <span class="nav-text">Argument Passing  参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Determining-Type-确定类型" target="_blank" rel="noopener"><span class="nav-number">1.1.4.</span> <span class="nav-text">Determining Type  确定类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EXECUTION-CONTEXT-AND-SCOPE-执行上下和作用域" target="_blank" rel="noopener"><span class="nav-number">1.2.</span> <span class="nav-text">EXECUTION CONTEXT AND SCOPE 执行上下和作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scope-Chain-Augmentatio-延长作用域链" target="_blank" rel="noopener"><span class="nav-number">1.2.1.</span> <span class="nav-text">Scope Chain Augmentatio 延长作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量声明" target="_blank" rel="noopener"><span class="nav-number">1.2.2.</span> <span class="nav-text">变量声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-Scope-Declaration-Using-var-使用var的函数声明范围" target="_blank" rel="noopener"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Function Scope Declaration Using var 使用var的函数声明范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Block-Scope-Declaration-Using-let-使用let的块级声明" target="_blank" rel="noopener"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Block Scope Declaration Using let 使用let的块级声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Constant-Declaration-Using-const-使用const的常量声明" target="_blank" rel="noopener"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Constant Declaration Using const 使用const的常量声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Identifier-Lookup-标识符查询" target="_blank" rel="noopener"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">Identifier Lookup 标识符查询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Garbage-Collection-垃圾收集" target="_blank" rel="noopener"><span class="nav-number">1.3.</span> <span class="nav-text">Garbage Collection 垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mark-and-Sweep-标记清除" target="_blank" rel="noopener"><span class="nav-number">1.3.1.</span> <span class="nav-text">Mark-and-Sweep  标记清除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference-Counting-引用计数" target="_blank" rel="noopener"><span class="nav-number">1.3.2.</span> <span class="nav-text">Reference Counting 引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance" target="_blank" rel="noopener"><span class="nav-number">1.3.3.</span> <span class="nav-text">Performance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Managing-Memory" target="_blank" rel="noopener"><span class="nav-number">1.3.4.</span> <span class="nav-text">Managing Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Performance-Boosts-with-const-and-let-Declarations" target="_blank" rel="noopener"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">Performance Boosts with const and let Declarations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hidden-Classes-and-the-delete-Operation-隐藏类和删除操作" target="_blank" rel="noopener"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">Hidden Classes and the delete Operation 隐藏类和删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Memory-Leaks-内存泄露" target="_blank" rel="noopener"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">Memory Leaks 内存泄露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Static-Allocation-and-Object-Pools-Static-Allocation-and-Object-Pools" target="_blank" rel="noopener"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">Static Allocation and Object Pools Static Allocation and Object Pools</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Summary" target="_blank" rel="noopener"><span class="nav-number">1.3.5.</span> <span class="nav-text">Summary</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Basic-Reference-Type" target="_blank" rel="noopener"><span class="nav-number">2.</span> <span class="nav-text">Basic Reference Type</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Date-Type-日期类型" target="_blank" rel="noopener"><span class="nav-number">2.1.</span> <span class="nav-text">The Date Type 日期类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Inherited-Methods-继承方法" target="_blank" rel="noopener"><span class="nav-number">2.1.1.</span> <span class="nav-text">Inherited Methods 继承方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date-Formatting-Methods-日期格式化方法" target="_blank" rel="noopener"><span class="nav-number">2.1.2.</span> <span class="nav-text">Date-Formatting Methods 日期格式化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date-Time-Component-Methods" target="_blank" rel="noopener"><span class="nav-number">2.1.3.</span> <span class="nav-text">Date&#x2F;Time Component Methods</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-RegExp-Type-正则类型" target="_blank" rel="noopener"><span class="nav-number">2.2.</span> <span class="nav-text">The RegExp Type  正则类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp-Instance-Properties" target="_blank" rel="noopener"><span class="nav-number">2.2.1.</span> <span class="nav-text">RegExp Instance Properties</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp-Instance-Methods-RegExp-实例方法" target="_blank" rel="noopener"><span class="nav-number">2.2.2.</span> <span class="nav-text">RegExp Instance Methods  RegExp 实例方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp-Constructor-Properties-构造函数属性" target="_blank" rel="noopener"><span class="nav-number">2.2.3.</span> <span class="nav-text">RegExp Constructor Properties 构造函数属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern-Limitations" target="_blank" rel="noopener"><span class="nav-number">2.2.4.</span> <span class="nav-text">Pattern Limitations</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Primitive-Wrapper-Types-基本包装类型" target="_blank" rel="noopener"><span class="nav-number">2.3.</span> <span class="nav-text">Primitive Wrapper Types 基本包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Boolean-Type" target="_blank" rel="noopener"><span class="nav-number">2.3.1.</span> <span class="nav-text">The Boolean Type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Number-Type" target="_blank" rel="noopener"><span class="nav-number">2.3.2.</span> <span class="nav-text">The Number Type</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-isInteger-Method-and-Safe-Integers-安全整数" target="_blank" rel="noopener"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">The isInteger() Method and Safe Integers  安全整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-JavaScript-Character-JS-字符" target="_blank" rel="noopener"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">The JavaScript Character  JS 字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-normalize-Method" target="_blank" rel="noopener"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">The normalize() Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-Manipulation-Methods" target="_blank" rel="noopener"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">String-Manipulation Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-Inclusion-Methods-字符串位置方法" target="_blank" rel="noopener"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">String Inclusion Methods  字符串位置方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-Inclusion-Methods" target="_blank" rel="noopener"><span class="nav-number">2.3.2.6.</span> <span class="nav-text">String Inclusion Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-trim-Method" target="_blank" rel="noopener"><span class="nav-number">2.3.2.7.</span> <span class="nav-text">The trim() Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-repeat-Method" target="_blank" rel="noopener"><span class="nav-number">2.3.2.8.</span> <span class="nav-text">The repeat() Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-padStart-and-padEnd-Methods" target="_blank" rel="noopener"><span class="nav-number">2.3.2.9.</span> <span class="nav-text">The padStart() and padEnd() Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-Iterators-and-Destructuring" target="_blank" rel="noopener"><span class="nav-number">2.3.2.10.</span> <span class="nav-text">String Iterators and Destructuring</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-Case-Methods" target="_blank" rel="noopener"><span class="nav-number">2.3.2.11.</span> <span class="nav-text">String Case Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-Pattern-Matching-Methods-字符串的模式匹配方法" target="_blank" rel="noopener"><span class="nav-number">2.3.2.12.</span> <span class="nav-text">String Pattern-Matching Methods  字符串的模式匹配方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-localeCompare-Method" target="_blank" rel="noopener"><span class="nav-number">2.3.2.13.</span> <span class="nav-text">The localeCompare() Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTML-Methods" target="_blank" rel="noopener"><span class="nav-number">2.3.2.14.</span> <span class="nav-text">HTML Methods</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Singleton-Built-in-objects-单体内置对象" target="_blank" rel="noopener"><span class="nav-number">2.4.</span> <span class="nav-text">Singleton Built-in objects  单体内置对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Global-Object" target="_blank" rel="noopener"><span class="nav-number">2.4.1.</span> <span class="nav-text">The Global Object</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URI-Encoding-Methods" target="_blank" rel="noopener"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">URI-Encoding Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-eval-Method" target="_blank" rel="noopener"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">The eval() Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Global-Object-Properties" target="_blank" rel="noopener"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">Global Object Properties</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Window-Object" target="_blank" rel="noopener"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">The Window Object</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Math-Object" target="_blank" rel="noopener"><span class="nav-number">2.4.2.</span> <span class="nav-text">The Math Object</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-Object-Properties" target="_blank" rel="noopener"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">Math Object Properties</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-min-and-max-Methods" target="_blank" rel="noopener"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">The min() and max() Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rounding-Methods" target="_blank" rel="noopener"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">Rounding Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-random-Method" target="_blank" rel="noopener"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">The random() Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Other-Methods" target="_blank" rel="noopener"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">Other Methods</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Summary-1" target="_blank" rel="noopener"><span class="nav-number">2.5.</span> <span class="nav-text">Summary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#COLLECTION-REFERENCE-TYPES" target="_blank" rel="noopener"><span class="nav-number">3.</span> <span class="nav-text">COLLECTION REFERENCE TYPES</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-object-Type" target="_blank" rel="noopener"><span class="nav-number">3.1.</span> <span class="nav-text">The object Type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Array-Type-170" target="_blank" rel="noopener"><span class="nav-number">3.2.</span> <span class="nav-text">The Array Type 170</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Creating-Arrays-170" target="_blank" rel="noopener"><span class="nav-number">3.2.1.</span> <span class="nav-text">Creating Arrays 170</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-Holes-172-数组空" target="_blank" rel="noopener"><span class="nav-number">3.2.2.</span> <span class="nav-text">Array Holes 172  数组空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Indexing-into-Arrays-174" target="_blank" rel="noopener"><span class="nav-number">3.2.3.</span> <span class="nav-text">Indexing into Arrays 174</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Detecting-Arrays-175" target="_blank" rel="noopener"><span class="nav-number">3.2.4.</span> <span class="nav-text">Detecting Arrays 175</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator-Methods-176-迭代器方法" target="_blank" rel="noopener"><span class="nav-number">3.2.5.</span> <span class="nav-text">Iterator Methods 176  迭代器方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Copy-and-Fill-Methods-176" target="_blank" rel="noopener"><span class="nav-number">3.2.6.</span> <span class="nav-text">Copy and Fill Methods 176</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conversion-Methods-179-转换方法" target="_blank" rel="noopener"><span class="nav-number">3.2.7.</span> <span class="nav-text">Conversion Methods 179  转换方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack-Methods-180-栈方法" target="_blank" rel="noopener"><span class="nav-number">3.2.8.</span> <span class="nav-text">Stack Methods 180 栈方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-Methods-181-队列方法" target="_blank" rel="noopener"><span class="nav-number">3.2.9.</span> <span class="nav-text">Queue Methods 181 队列方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reordering-Methods-重排序方法" target="_blank" rel="noopener"><span class="nav-number">3.2.10.</span> <span class="nav-text">Reordering Methods 重排序方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Manipulation-Methods-184-操作方法" target="_blank" rel="noopener"><span class="nav-number">3.2.11.</span> <span class="nav-text">Manipulation Methods 184 操作方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Search-and-Location-Methods-186" target="_blank" rel="noopener"><span class="nav-number">3.2.12.</span> <span class="nav-text">Search and Location Methods 186</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Strict-Equivalence-186" target="_blank" rel="noopener"><span class="nav-number">3.2.12.1.</span> <span class="nav-text">Strict Equivalence 186</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Predicate-Search-187" target="_blank" rel="noopener"><span class="nav-number">3.2.12.2.</span> <span class="nav-text">Predicate Search 187</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterative-Methods-188" target="_blank" rel="noopener"><span class="nav-number">3.2.13.</span> <span class="nav-text">Iterative Methods 188</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reduction-Methods-189" target="_blank" rel="noopener"><span class="nav-number">3.2.14.</span> <span class="nav-text">Reduction Methods 189</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Typed-Arrays-190" target="_blank" rel="noopener"><span class="nav-number">3.3.</span> <span class="nav-text">Typed Arrays 190</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ITERATORS-AND-GENERATORS" target="_blank" rel="noopener"><span class="nav-number">4.</span> <span class="nav-text">ITERATORS AND GENERATORS</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luxin Z</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
