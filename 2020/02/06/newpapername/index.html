<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JS 高级程序设计 读书笔记 | 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="变量， 范围， 和 内存primitive 原始值 和 reference values 引用值 变量中包含两种不同的类型数据 原始值 就是简单的数据，基本数据类型 引用值： 就是由多个值组成的对象   将数据值分配给一个变量之后，JS 必须要确定他的数据类型是原始值还是引用值。 六个原始&#x2F;基本类型 ： undefined ，null , boolean, string, number, symb">
<meta property="og:type" content="article">
<meta property="og:title" content="JS 高级程序设计 读书笔记">
<meta property="og:url" content="2020/02/06/newpapername/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="变量， 范围， 和 内存primitive 原始值 和 reference values 引用值 变量中包含两种不同的类型数据 原始值 就是简单的数据，基本数据类型 引用值： 就是由多个值组成的对象   将数据值分配给一个变量之后，JS 必须要确定他的数据类型是原始值还是引用值。 六个原始&#x2F;基本类型 ： undefined ，null , boolean, string, number, symb">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-02-05T16:27:57.000Z">
<meta property="article:modified_time" content="2020-02-05T16:57:28.317Z">
<meta property="article:author" content="Luxin Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" target="_blank" rel="noopener" id="logo">个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" target="_blank" rel="noopener" id="subtitle">每日笔记</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/" target="_blank" rel="noopener">Home</a>
        
          <a class="main-nav-link" href="/archives" target="_blank" rel="noopener">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" target="_blank" rel="noopener" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="LuXinZ.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-newpapername" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/02/06/newpapername/" target="_blank" rel="noopener" class="article-date">
  <time datetime="2020-02-05T16:27:57.000Z" itemprop="datePublished">2020-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JS 高级程序设计 读书笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="变量，-范围，-和-内存"><a href="#变量，-范围，-和-内存" target="_blank" rel="noopener" class="headerlink" title="变量， 范围， 和 内存"></a>变量， 范围， 和 内存</h1><h2 id="primitive-原始值-和-reference-values-引用值"><a href="#primitive-原始值-和-reference-values-引用值" target="_blank" rel="noopener" class="headerlink" title="primitive 原始值 和 reference values 引用值"></a>primitive 原始值 和 reference values 引用值</h2><ul>
<li>变量中包含两种不同的类型数据<ul>
<li>原始值 就是简单的数据，基本数据类型</li>
<li>引用值： 就是由多个值组成的对象</li>
</ul>
</li>
<li>将数据值分配给一个变量之后，JS 必须要确定他的数据类型是原始值还是引用值。</li>
<li>六个原始/基本类型 ： undefined ，null , boolean, string, number, symbol,<ul>
<li>这些变量是按值访问的，因为你正在操作的就是存储在变量中的实际值</li>
</ul>
</li>
<li>引用值是储存在内存的对象，JS 不允许直接访问内存的位置，一年春不允许直接操作对象的内存空间。当你操作一个对象时候，你实际上是对该对象的引用进行操作，而不是实际的对象本身，因此，可以说这些值是通过引用访问的。<h3 id="Dynamic-properties-动态属性"><a href="#Dynamic-properties-动态属性" target="_blank" rel="noopener" class="headerlink" title="Dynamic properties 动态属性"></a>Dynamic properties 动态属性</h3>原始值和引用值的定义类似：当一个变量创建后并为其分配值。但是执行的操作却大不相同，使用引用值的时候，可以随时添加，更改或者删除属性的方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'Jack'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
这里，创建了一个对象，并存储到变量person 中，接下来，为这个对象添加了一个名为name 的属性，并且为其分配了字符串Jack.从现在起，就可以访问新属性了，知道对象被销毁，或者属性明确地移除<br>但是，原始值不能添加属性，即使这样做不会报错<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Nicholas"</span>; </span><br><span class="line">name.age = <span class="number">27</span>; </span><br><span class="line"><span class="built_in">console</span>.log(name.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
这里，在字符串name定义了一个age 属性，并且为其赋值27，。但是在下一行，属性不存在。<br>所以只有引用值可以定义属性供以后使用。<br>注意： 原始类型的实例化可以使用基本文字形式。如果要是用new关键字，JS 将创建一个Object类型，但是这个行为类似于基本。<br>这是例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">'Jack'</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Matt'</span>)</span><br><span class="line">name1.age = <span class="number">27</span>;</span><br><span class="line">name2.age = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age) ; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age) ; <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1) <span class="comment">// String</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2) <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
可以看出，new之后， 将会变为对象<h3 id="Copying-Values-复制值"><a href="#Copying-Values-复制值" target="_blank" rel="noopener" class="headerlink" title="Copying Values 复制值"></a>Copying Values 复制值</h3>除了存储方式不同之外，原始值和引用值在从一个变量复制到另一个变量时的作用也不同。将原始值从一个变量分配给另一个变量时，值储存在变量对象被创建和复制到新变量的位置。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num1 &#x3D; 5;</span><br><span class="line">let num2 &#x3D; num1;</span><br></pre></td></tr></table></figure>
这里，num1的值是5，当num2 初始化为num1 时，它也获得值5。该值与num1中存储的值完全分开。因为这是那个值的复制。<br>现在每个值都可以单独使用，而没有副作用<br>当引用值从一个变量分配给另一个变量的时候，存储在变量对象上的值也会复制到新变量的位置。区别在于该值实际上是指向在对象存储的堆。一旦操作完成了，两个变量指向完全相同的对象。因此对一个变量的更改会反应在另一个变量上。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.name= <span class="string">'Jack'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name) <span class="comment">// 'Jack'</span></span><br></pre></td></tr></table></figure>
变量boj1 填充到了一个new 实例的对象中，然后将值赋值到obj2,这意味着两个变量都指向相同的对象。当属性名设置在obj1上，这个属性可以从obj2上进行访问，因为他们指向相同的对象。<h3 id="Argument-Passing-参数传递"><a href="#Argument-Passing-参数传递" target="_blank" rel="noopener" class="headerlink" title="Argument Passing  参数传递"></a>Argument Passing  参数传递</h3>JS 中所有函数的参数均是按值传递。这意味着将函数外部的值复制到函数内部的参数中，就像值从一个变量复制到另一变量中。如果值是是原始值，则其行为就像是基本变量的拷贝，如果值是引用值，则其行为就像是引用变量的拷贝。因为变量既可以通过值和引用访问，但是参数只能通过值传递。<br>当参数通过值传递，该值将被复制到局部变量 local variable。当参数通过引用传递，值在内存中的位置是存储在局部变量中，这意味着对局部变量的更改将将反应在函数的外部<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log (count) <span class="comment">// 20 - no change</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
在这里，函数addTen() 有一个参数 num, 这是个局部变量。当调用时，这个变量count作为参数传递。，此变量的值是20，将其赋值到参数num 中然后在addTen() 内部使用。在函数中，参数num的值通过加10进行了更改，但是它没有更改函数外部存在的原始的变量。参数num 和变量 variable 无法互相识别，他们恰巧有相同的价值。如果num 通过引用传递，然后count的值将更改为30，以反映在函数内部所做的更改。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'jack'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person)</span><br><span class="line">consol.log(person.name) <span class="comment">// jack</span></span><br></pre></td></tr></table></figure>
在此代码中，将创建一个对象并储存在变量person 中，然后将对象传递到setName() 方法中，然后将其赋值到obj中。在函数内部，obj和person 都是指向相同的对象、结果是obJ是引用来访问对象的，即使他通过值传递到函数中。 当name属性被设置到函数内部的obj中，此更改将反应在函数的外部。因为它指向的对象存在堆中的全局。当全局更改反应到对象的局部更改时，这意味着参数已经通过引用传递了。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'jack'</span></span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    obj.name = <span class="string">'Rose'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 'Jack'</span></span><br></pre></td></tr></table></figure>
这个例子中与上一个例子中的唯一变化是，在setName() 中添加了两行，将obj重新定义为新的对象并且带有不同的name。当person将值传递到setName() 中，其中的name属性被设置为jack.然后变量obj被设置为新的对象，并且他name的属性被设置Rose。 如果person通过引用传递，这个person将会自动指向Rose的对象。但是当再次访问person.name的时候，这个值还是Jack。这表明，即使参数的值在函数内部更改了，原始引用值仍然保持不变。当obj在函数被覆盖，他将会变成指针指向局部对象。函数执行完成后，这个局部对象会被销毁。<h3 id="Determining-Type-确定类型"><a href="#Determining-Type-确定类型" target="_blank" rel="noopener" class="headerlink" title="Determining Type  确定类型"></a>Determining Type  确定类型</h3>typeof 是确定原始数据类型的最佳方法，但是只是string，number,boolean, undefined. 这些类型<br>如果值是object 和null ，则会返回object、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'Jack'</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>  <span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> u;  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>   <span class="comment">// object</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);   <span class="comment">// string </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i);   <span class="comment">// number </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);   <span class="comment">// boolean console.log(typeof u);   // undefined </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n);   <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o);   <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
尽管typeof 用于原始数据类型，但是很少用于引用数据类型。<br>如果想知道他是什么类型的对象， JS 中提供了instanceof 运算符<br>语法：<br>result = variable  instanceof constructor<br>instanceof 会返回一个true 如果这个变量是给定引用类型give reference type <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// person 是不是对象</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// color 是不是数组</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="comment">// pattern 是是不是正则</span></span><br></pre></td></tr></table></figure>
根据定义，所有引用值都是Object的实例。因此instanceof运算符与引用值和Object构造函数一起一起使用时始终返回true。 同样，如果 instanceof 使用的是基本类型值，它会返回false,因为基本值不是对象<br>当在函数上用typeof的时候会返回function。 <h2 id="EXECUTION-CONTEXT-AND-SCOPE-执行上下和作用域"><a href="#EXECUTION-CONTEXT-AND-SCOPE-执行上下和作用域" target="_blank" rel="noopener" class="headerlink" title="EXECUTION CONTEXT AND SCOPE 执行上下和作用域"></a>EXECUTION CONTEXT AND SCOPE 执行上下和作用域</h2>执行上下文，简称上下文，在JS 中至关重要。变量和函数的执行上下文定义了它可以访问的其他数据和其执行方式。每个执行上下文都有一个关联的变量对象，其所有定义的变量和函数都存在于该对象上。这个对象无法通过代码访问，但在后台被用于处理数据。<br>全局上下文是最外部的上下文。根据JS事先的主主机环境，表示此上下问的对象可能不同。在浏览器中，全局上下文是被称为window 的对象。所以使用var定义的所有全局变量和函数都被作为属性和方法创建在window 对象上。<br>声明使用let和const 在最顶层不会被定义在全局上下文中。但是他们在作用域脸上的解析方式相同。当执行上下文执行完所有代码后，他就会销毁，并且带走其定义的所有变量和函数（全局上下文不会被销毁除非应用程序退出，例如关闭网页和关闭应用程序的时候）<br>每个函数调用自己的执行上下文。每当代码执行流入函数中，函数的上下文就会被推送到上下文堆中。函数执行完成后，堆就会弹出，并且返回控制权到上一个执行上下文。这个功能通过ESMC的程序控制执行流程<br>当代码被执行在上下文中，将创建变量对象的作用域链。作用域链的目的提供对执行上下中有权访问的所有变量和函数进行有序访问。作用域链的前端始终是代码正在执行的上下文的变量对象、如果上下文是函数，就会激活对象用作变量对象。激活对象以一个定义为参数的变量开始。（这对于全局上下文不存在）。链中的下一个变量对象来自包含上下文，而其后的下一个变量对象来自下一个包含上下文。这种模式一直持续到全局上下文找到。全局上下文变量对象一直是作用域链中的最后一个。<br>通过导航作用域链以搜索标识符名称来解析标识符。搜索始终从链的最前面开始，一直进行到最后，直到标识符被找到（如果找不到标识符通常会发生错误。）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (color ===<span class="string">'blue'</span>)&#123;</span><br><span class="line">        color = <span class="string">"red"</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        color = <span class="string">"blue"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor()</span><br></pre></td></tr></table></figure>
函数changeColor()的作用域链包含了两个对象在里面：他自己的变量对象（在其上定义了参数对象）。和全局作用域变量对象、这个变量color是可以在函数内部访问的，因为他可以在作用域链中找到。<br>此外，局部定义变量可以用来与全局变量交换在局部上线文中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> anotherColor =<span class="string">"red"</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor</span><br><span class="line">        <span class="comment">// color, anotherColor, and tempColor are all accessible here </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// color and anotherColor are accessible here, but not tempColor swapColors();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only color is accessible here </span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
此代码包含了三个执行上下文：全局上下文，局部上下文changeColor() , 和局部上下文swapColor()、全局上下文有一个变量，color和一个函数。changeColor(). 局部上下文changeColor() 有一个变量anotherColor 和一个函数命名文swapColor(),但它依然可以访问变量color 从全局上下文中。局部上下文swapColro() 有一个变量tempColor， 它只能在该上下文中访问。无论是全局上下文或者局部上下文swapColors() 都无法访问到tempcolor。 但是，在swapColors() 中，其他两个上下文中的变量是完全可以访问的。因为他是父执行上下文、<br>在这个表格中。矩形代表特定的执行上下文。内部上下文可以访问所有外部上下文中的所有内容通过作用域链。但是外部上不可以访问任何在内部上下文中的内容。这个链接有线性的并且有秩序的。每个上下文可以搜索作用域链中的变量和函数，但是没有上下文可以向下索索作用域链中的另一个执行上下文。作用域链中局部上下文swapColors存在三个对象: swapColors() 变量对象，变量对象来自changeColor() 和 全局变量对象。swapColors() 的局部上下文开始寻找变量和函数名称在它自己变量对象中，在沿着链前进之前。changeColor() 的上下文的作用域链只有两个对象： 是自己变量对象和全局变量对象。这意味着它无法访问swapColor() 的上下文、<br>函数参数被视为变量，并且和其他变量在执行上下文中有相同的访问规则<h3 id="Scope-Chain-Augmentatio-延长作用域链"><a href="#Scope-Chain-Augmentatio-延长作用域链" target="_blank" rel="noopener" class="headerlink" title="Scope Chain Augmentatio 延长作用域链"></a>Scope Chain Augmentatio 延长作用域链</h3>即使执行环境只有两种主要类型：即全局和函数（第三种存在于eval()的调用内），但是还有其他的途径扩展作用域链。某些语句可以在作用域链的连段临时增加一个变量对象，，然后在代码执行后移除此变量对象。有两种情况会发生这种现象，特别是当执行进入以下任意情况时：<br>try-catch 语句中的catch块。<br>with 语句<br>这两个语句豆浆一个变量对象添加到作用域链的最前端。对于with语句，将指定的对象添加到租用与链。对于catch语句，将创建一个新的变量对象并且包含引发错误对象的声明。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function buildUrl()&#123;</span><br><span class="line">    LET qs&#x3D; &quot;?debug&#x3D;true&quot;</span><br><span class="line">    whit(location)&#123;</span><br><span class="line">        let url &#x3D; href + qs</span><br><span class="line">    &#125;</span><br><span class="line">    return url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
whit 语句作用域 location 对象，所以location本身被添加到作用域的前面。buildURL()函数中定义了一个变量qs。当在with语句中引用变量href时候，引用的是location.href。当变量qs被引用的时候，引用的是正在buildUrl()中的定义的变量，该变量在函数环境的变量对象中。在with语句背部，则声明了一个url变量，这个变量成为了函数环境的一个部分，因此可以作为函数的值返回<h3 id="变量声明"><a href="#变量声明" target="_blank" rel="noopener" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="Function-Scope-Declaration-Using-var-使用var的函数声明范围"><a href="#Function-Scope-Declaration-Using-var-使用var的函数声明范围" target="_blank" rel="noopener" class="headerlink" title="Function Scope Declaration Using var 使用var的函数声明范围"></a>Function Scope Declaration Using var 使用var的函数声明范围</h4>使用var声明变量的时候，他会自动的添加到可用的最接近的环境中。在函数中，最近接的环境就是函数局部环境。在with语句中，最接近的就是函数韩静。如果初始化的时候没有事先声明变量，则该变量会自动添加到全局环境中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 无效变量错误</span></span><br></pre></td></tr></table></figure>
这里，函数add()定义了一个局部变量sum， 其中包含了加法的运算结果。虽然结果从函数值返回了，但是变量sum不是可以在函数外部访问的。如果var 这个关键字被省略掉，sum就会变成可以在add()执行完毕后，可以访问的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    sum = num1+ num2</span><br><span class="line">    <span class="keyword">return</span> sum </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">//30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 3-</span></span><br></pre></td></tr></table></figure>
变量sum被初花一个值，但是并没有使用关键字var进行声明。调用add()的时候，sum在全局环境中创建，并且即使代码执行完毕后，也可以在之后的代码中访问<br>在严格模式下，初始化未经声明的变量会导致错误<br>var 声明将置于函数或者全局作用域的顶部，并且位于其中的任何现有代码之前。这种被称为hoisting， 提升。这允许你安全的使用提升的函数在作用域的任何地方，而不需要考虑是否声明了。但是，实际上，这会导致合法但奇怪的代码，其中在变量声明之前就是使用了该变量。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span></span><br><span class="line"><span class="comment">// 等同于 :</span></span><br><span class="line">name = <span class="string">'jack'</span></span><br><span class="line"><span class="keyword">var</span> name</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'jake'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    name = <span class="string">'Jake'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是可以通过在变量声明之前检查自己的变量是否被提升了。你会看到undefined而不是ReferenceError<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'jake'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'jake'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Block-Scope-Declaration-Using-let-使用let的块级声明"><a href="#Block-Scope-Declaration-Using-let-使用let的块级声明" target="_blank" rel="noopener" class="headerlink" title="Block Scope Declaration Using let 使用let的块级声明"></a>Block Scope Declaration Using let 使用let的块级声明</h4>let可以和var相同的方式进行操作，但是它的作用域是块级的。块级作用域的概念是最接近的一组大括号{}。这意味着，if快，while块，function块，甚至独立快将成为用let声明的任何变量的范围。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//  报错，ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//  ReferenceError: b is not defined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">//  ReferenceError: c is not defined,，这个var 也会引发错误</span></span><br><span class="line"><span class="comment">// 这不是对象文字，这是一个独立的快</span></span><br><span class="line"><span class="comment">// js会基于内容识别</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> d</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// ReferenceError: d is not defined</span></span><br></pre></td></tr></table></figure>
与var的行为类似，不能再同一范围内两次声明let。重复的var声明将被忽略，宠物的let声明会引发语法错误syntaxError<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// no errors thrown</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 语法错误： SyntaxError: identifier b has already been declared</span></span><br></pre></td></tr></table></figure>
当在循环体中使用迭代器，let的行为特别有用、使用var的声明迭代器完成后外流循环。这种行为是非常不好的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span> ;j++&gt;)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(j) <span class="comment">// ReferenceError, J没有定义</span></span><br></pre></td></tr></table></figure>
let 在JS中运行的时候是技术提升的。但是由于存在临时性四驱。因此无法使用该变量在其声明的上方。因此let 与 var 的提升方式不同。<h4 id="Constant-Declaration-Using-const-使用const的常量声明"><a href="#Constant-Declaration-Using-const-使用const的常量声明" target="_blank" rel="noopener" class="headerlink" title="Constant Declaration Using const 使用const的常量声明"></a>Constant Declaration Using const 使用const的常量声明</h4>ES6 还引入了const 作为陪伴let，使用const声明的变量必须初始化为某个值。一次声明后，就不能重新分配给新的值了在其声明周期的任何时候。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="comment">//  报错，缺少初始化。</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 3</span></span><br><span class="line">b= <span class="number">4</span> <span class="comment">// TypeError: Assignment to a constant variable</span></span><br></pre></td></tr></table></figure>
除了执行const 规则外，const变量行为与let 一样<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;  <span class="keyword">const</span> a = <span class="number">0</span>; &#125; <span class="built_in">console</span>.log(a);  <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="keyword">const</span> b = <span class="number">1</span>; &#125; <span class="built_in">console</span>.log(b);  <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">const</span> c = <span class="number">2</span>; &#125; <span class="built_in">console</span>.log(c);  <span class="comment">// ReferenceError: c is not defined</span></span><br><span class="line"> </span><br><span class="line">&#123;  <span class="keyword">const</span> d = <span class="number">3</span>; &#125; <span class="built_in">console</span>.log(d);  <span class="comment">// ReferenceError: d is not defined</span></span><br></pre></td></tr></table></figure>
const 声明仅适用于处于顶级的基本类型和对象。换句话说，const变量不能将分配给对象的值重新分配给另一个殷涌智，但是该对象内部的键值不受到保护、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 =&#123;&#125;</span><br><span class="line">o1 = &#123;&#125; <span class="comment">// TypeError: Assignment to a constant variable;</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125; </span><br><span class="line">o2.name = <span class="string">'jake'</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.name)  <span class="comment">// jake</span></span><br></pre></td></tr></table></figure>
如果希望整个对象都变的不可以更改，可以使用Object.freeze，尽管尝试分配属性不会引发错误；他只会默默的失败<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;)</span><br><span class="line">o3.name = <span class="string">'jake'</span></span><br><span class="line"><span class="built_in">console</span>.log(o3.name) ; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
由于const 声明暗示该值是单一类型且不可变的。因此JS 运行编译器时候可以用实际值替换其所有势力，而不用通过变量表查询该变量。V8引擎执行了这样的优化。<h4 id="Identifier-Lookup-标识符查询"><a href="#Identifier-Lookup-标识符查询" target="_blank" rel="noopener" class="headerlink" title="Identifier Lookup 标识符查询"></a>Identifier Lookup 标识符查询</h4>挡在某个环境中为了读取或写入而引用一个标志服，必须通过搜索一确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字相匹配的标识符。如果它在局部连梁中找到了该标识符名称，则搜索就会停止并且设置该变量。如果搜索不到这个变量名字，他会继续沿着作用链向上搜索。（请注意，作用域链中的对象也是具有原型链的，因此搜索可能会包含每个对象的原型链）此过程一直寻找到全局环境的变量对象位置，如果在在此找不到标识符，则说明尚未声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
当调用函数getColor（） 的时候，将引用变量color。此时，将会开始两步搜索。第一步getColor() 的变量对象中搜索一个包含名为color 的标识符。 当找不到该对象的时候，将搜索（从全局环境中）到下一个变量对象，然后在那里找到了名为color 的标识符。因为在该变量对象中定义了颜色，所以搜索结束。<br>在此搜索过程中，引用局部变量自动会停止搜索，不在进入另一个变量对象。这意味着，如果局部环境中的标识符存在相同的名称，则无法引用位于父环境中的标识符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">'red'</span></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">// red</span></span><br></pre></td></tr></table></figure>
使用块级域声明不会改变搜索进程，但是会为为词汇层次结构添加额外的级别。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">'red'</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> color = <span class="string">'green'</span></span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">// green</span></span><br></pre></td></tr></table></figure>
在此修改后的代码中，在getColor() 函数中声明的名为color局部变量，在调用函数的时候，这个变量会被声明。当函数的第二行执行的时候，它知道命名为color的变量必须被使用。搜索从局部环境开始，在找到变量名称为color，值为green。因为找到了变量，所以这个搜索停止了，并且这个局部变量被使用了，这意味着这个函数会返回green。任何位于局部变量color声明之后的代码都不能将都不能访问全局color 变量如果限定其使用window.color。如果一个操作数是一个对象，而另一个不是、valueOf() 方法会被调用，以检索原始值的方法根据原先的规则。<h2 id="Garbage-Collection-垃圾收集"><a href="#Garbage-Collection-垃圾收集" target="_blank" rel="noopener" class="headerlink" title="Garbage Collection 垃圾收集"></a>Garbage Collection 垃圾收集</h2>JS 具有垃圾收集的语言。，这意味着操作环境会负责管理代码执行期间所需要的内存。而在C和C++ 语言中，跟踪内存的使用是一个主要问题，开发人员的一项基本任务就是手工跟踪内存的使用情况。JS 通过自动分配所需的内容并回收不在使用的内存，使得开发人员不必担心内存管理。这种原理很简单：找出将不在使用的变量，释放与其关联的内存。此过程是周期性的，垃圾收集器以指定的时间间隔（或在代码执行中预定义收集时候）运行。垃圾回收的过程是一个近似且不完善的解决方案，因为知道知道是否需要某些内存的一般问题是不确定的，这意味着无法用算法解决。<br>考虑函数中局部变量的正常声明周期。该变量值在函数执行的过程中存在，那时，内存在堆（可能是栈）内存分配，以提供一个该值的储存空间。这个变量被使用在函数内部，然后函数结束。此时，不需要此变量，因为可以回收其内存以供以后使用。在这种情况下，显然不需要该变量。但是并非所有情况都是这样显而易见。垃圾收集器必须跟踪那些变量可以使用那些不可以使用，对不在有用的变量打上标记，以备将来收回其占用的内存。尽管传统上的浏览器使用了连个中策略：用于标识未使用的变量的策略可能会因事先方式而有所不同。但是这些策略通常是 mark-and-sweep 标记清除 和 reference counting 引用计数<h3 id="Mark-and-Sweep-标记清除"><a href="#Mark-and-Sweep-标记清除" target="_blank" rel="noopener" class="headerlink" title="Mark-and-Sweep  标记清除"></a>Mark-and-Sweep  标记清除</h3>JS 中最受欢迎的垃圾回收是标记清除。当变量进入到环境中，例如变量在函数中声明，会将其标记在环境中。从逻辑上讲，环境中的变量永远都不应该释放内存，继续使用它就会可能会在环境中继续执行，当变量离开环境，他也会被标记上脱离环境。<br>可以使用多种方式来标记变量，可以通过反转某个特殊的位来记录变量何时进入了环境。或者在使用一个进入环境的变量列表以及离开环境的变量列表。标记的实现并不重要，关键是理论。、<br>当垃圾收集器运行的时候，它将标记存储在内存中的所有变量（可以使用任何标记方式），然后它将清除环境中的变量和被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将会被视为删除的变量，原因是环境中的变量已经无法访问他们了。然后垃圾收集器完成内存清除工作，销毁那些标记的值并且回收他们所占用的内存空间。<br>从2008年开始，尽管垃圾回收的是时间不同，但是浏览器在其JS 中都使用了标记清除式的垃圾收集策略。<h3 id="Reference-Counting-引用计数"><a href="#Reference-Counting-引用计数" target="_blank" rel="noopener" class="headerlink" title="Reference Counting 引用计数"></a>Reference Counting 引用计数</h3>未完成 163 页<h3 id="Performance"><a href="#Performance" target="_blank" rel="noopener" class="headerlink" title="Performance"></a>Performance</h3>未完成163 页<h3 id="Managing-Memory"><a href="#Managing-Memory" target="_blank" rel="noopener" class="headerlink" title="Managing Memory"></a>Managing Memory</h3>未完成164页<h4 id="Performance-Boosts-with-const-and-let-Declarations"><a href="#Performance-Boosts-with-const-and-let-Declarations" target="_blank" rel="noopener" class="headerlink" title="Performance Boosts with const and let Declarations"></a>Performance Boosts with const and let Declarations</h4>在ES6中引入这些关键字不仅对代码风格有好处，而且对垃圾收集过程也有好处。因为const 和let 的作用域是块而不是函数，所以根据代码的组织方式，这可能会对垃圾回收器发出信号，表明已经分配的变量是符合清除的资格，相对于使用var的时候来说。当会计作用域远早于函数作用域终止时，就会发生这种情况<h4 id="Hidden-Classes-and-the-delete-Operation-隐藏类和删除操作"><a href="#Hidden-Classes-and-the-delete-Operation-隐藏类和删除操作" target="_blank" rel="noopener" class="headerlink" title="Hidden Classes and the delete Operation 隐藏类和删除操作"></a>Hidden Classes and the delete Operation 隐藏类和删除操作</h4>根据您希望JS 运行的位置，有时候值得考虑基于浏览器使用JS引擎的各种性能影响。V8利用隐藏类，当接收后的JS便以为实际的机器代码，如果正在编写对性能很敏感的代码，很重要<br>在运行的时候，V8将关联隐藏的类在对象创建之后，并且跟踪其属性的形状、对象是能够共享相同的隐藏的类会有更高的性能，v8将会对此优化但是并非总是如此<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'Hello'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article()</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article()</span><br></pre></td></tr></table></figure>
在后台，V8将配置两个类实例共享相同的隐藏的类。这是有道理的，因为他们共享一个构造函数和原型。假设将一下代码添加到此代码的末尾。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.author &#x3D; &#39;jake&#39;</span><br></pre></td></tr></table></figure>
现在这两个Article 实例将具有两个不同的隐藏类事项。根据此操作的频率和隐藏类的大小，这可能会对性能产生重要的影响<br>解决方案当时避免分配JS 的ready-fire-aim动态属性，而是在构造函数中声明所有属性。若夏<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'Hello'</span></span><br><span class="line">    <span class="keyword">this</span>.author = opt_author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br></pre></td></tr></table></figure>
现在，这两个实例的行为基本上是相同的（不计算hasOwnProperty的返回值），并且他们还将共享一个隐藏的类，从而有可能提高性能。请记住，尽管使用delete关键字可以生成相同的隐藏类碎片。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'Hello'</span></span><br><span class="line">    <span class="keyword">this</span>.author = <span class="string">'jake'</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">delete</span> a1.author</span><br></pre></td></tr></table></figure>
在此代码端的结尾，即使两个实例使用同一的构造函数，那么他们也不再共享隐藏的类。动态删除属性将产生于动态添加相同的效果。最佳做法要求将不需要的属性设置为null，它将允许隐藏的类保存原样和共享，并且对于删除引用具有相同的作用，以便使垃圾回收器收益。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'hello'</span></span><br><span class="line">    <span class="keyword">this</span>.author = <span class="string">'jake'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1= <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article()</span><br><span class="line">a1.author =<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h4 id="Memory-Leaks-内存泄露"><a href="#Memory-Leaks-内存泄露" target="_blank" rel="noopener" class="headerlink" title="Memory Leaks 内存泄露"></a>Memory Leaks 内存泄露</h4>未完成 166 页<h4 id="Static-Allocation-and-Object-Pools-Static-Allocation-and-Object-Pools"><a href="#Static-Allocation-and-Object-Pools-Static-Allocation-and-Object-Pools" target="_blank" rel="noopener" class="headerlink" title="Static Allocation and Object Pools Static Allocation and Object Pools"></a>Static Allocation and Object Pools Static Allocation and Object Pools</h4>未完成167页 <h3 id="Summary"><a href="#Summary" target="_blank" rel="noopener" class="headerlink" title="Summary"></a>Summary</h3>可以在JS 变量中存储两种类型的值，基本值和引用值。基本值有六个：undefined， null ， string , number, symbol,boolean.</li>
<li>基本值和引用值有如下特征<ul>
<li>基本值是固定大小的，因此存储在堆内存中。</li>
<li>将基本值从一个变量赋值到另一个变量，将创建这个值的第二个拷贝。</li>
<li>引用值是对象，储存在堆内存中。</li>
<li>包含引用值的变量世纪上仅包含指向对象的指针，不包含对象本身</li>
<li>将引用值复制到另一个变量仅仅复制指针，因此两个变量最终都引用同一对象。</li>
<li>typeof 运算符确定值的原始类型，而instanceof运算符用于确定值的引用类型</li>
</ul>
</li>
<li>所有变量（）都存在于操作环境中（也叫做作用域），环境确定变量生命周期和那些代码可以访问它。操作环境可以总结如下：<ul>
<li>操作环境存在全局，成为全局环境，在函数内部和块内部</li>
<li>每次进入新的操作环境中，它都会创建一个作用域链以搜索变量和函数</li>
<li>函数或者块级不仅可以访问作用域中变量还可以访问任何包含环境和全局环境的变量在环境中、</li>
<li>全局环境只能访问变量或者函数在全局环境，不能直接访问数据在任何局部环境中</li>
<li>变量的操作环境有助于确定何时释放内存。</li>
</ul>
</li>
<li>JS是一个具有垃圾回收的变成环境，开发人员无需担心内存的分配和回收。JS 的垃圾回收流程如下<ul>
<li>超出范围的值会被自动表弟并且回收，并且在垃圾回收过程中删除。</li>
<li>主要垃圾收集算法成为 标记清除， 该算法会标记当前未使用的值，然后返回以回收该内存。</li>
<li>另一种算法是引用计数，该算法跟踪特定值有多少个引用，JS 不在使用此算法，但是由于JS 中访问了非本地JS对象，它仍然会影响IE</li>
<li>当代码中存才循环引用的时候，引用计数会导致问题，</li>
<li>接触变量的引用不仅有助于消除循环引用对象，而且对垃圾收集也有好处，为了确保有效的回收内存，应该及时解除不在使用的全局对象，全局对象属性以及循环引用变量的引用。<h1 id="Basic-Reference-Type"><a href="#Basic-Reference-Type" target="_blank" rel="noopener" class="headerlink" title="Basic Reference Type"></a>Basic Reference Type</h1>未完成 171<h2 id="The-Date-Type-日期类型"><a href="#The-Date-Type-日期类型" target="_blank" rel="noopener" class="headerlink" title="The Date Type 日期类型"></a>The Date Type 日期类型</h2>Date() 类型基于JAVA的早期版本，因此，日期类型将日期存储为UTC 自1970年1月1日以来经过的毫秒数。使用此数据储存格式，日期类型可以表示285616之后的日期。<br>若要创建日期对象，使用new运算符以及Date构造函数<br>let now = new Date()<br>使用不带参数的Date构造函数的时候，将会创建对象，并且分配当前的日期和时间。要给予其他日期或者时间创建日期，必须传入日期的毫秒。为了帮助完成此过程，提供了两种方法Date.parse() 和Date.UTC()<br>Date.parse() 方法接受表示日期的字符串参数。它尝试将字符串转换为日期的毫秒数表示。应该支持现在的格式日期。所有实现都必须支持一下日期格式。</li>
</ul>
</li>
<li>month/date/year (例如，5/23/2019)</li>
<li>month_name date, year(such as May 23,2019)</li>
<li>day_of_week month_name date year hours:minutes:seconds time_zone (such as Tue May 23 2019 00:00:00 GMT-0700) </li>
<li>ISO 8601 extended format YYYY-MM-DDTHH:mm:ss.sssZ (such as 2019-0523T00:00:00). This works only in ECMAScript 5–compliant implementations.<br>例如，要为2019年5月23日创建日期对象，可以使用一下代码：<br>let someDate = new Date(Date.parse(‘May 23,2019’))<br>如果传递给Data.parse() 的字符串不能代表一个日期，则其返回NaN。 如果直接传递一个字符串，则Date的构造函数将在调用Date.parse() ，这意味一下代码以前面的实例相同<br>let someDate = new Date(‘May 23, 2019’)<br>这个<br>Date.UTC() 方法也返回日期的毫秒数表示，但是使用与Data.parse()不同的信息构造该值。Date.UTC() 的参数是年，从零开始的月，月份中的一天，和小时，分钟，秒，以及毫秒。在参数中，只有前两个（年和月）是需要的。如果没有提供当月的日期，则假设为1。而所有其他省略的参数都假定为0。<br>这是Date的两个实例，UTC()的作用<br>// January 1 , 2000 at midnight GMT<br>let y2k = new Date(Date.UTC(2000,0))<br>// May 5, 2005 at 5:55:55 PM GMT<br>let allFives = new Date(Date.UTC(2005,4,5,17,55,55))<br>在此实例中创建连个日期，第一个日期是2000年1月1日，以2000年和0个月（即1月）表示。由于其他参数已经填写（将月份中的设置为1，将其他所有内容都设置为0），因此结果是该月的第一天午夜。第二个时期表示2005年5月5日5：55：:55，即是日期和时间仅仅包含5位，创建该日期也需要一些不同的数字，必须将月份设置为4、因为月份是从零开始的，而必须将消失设置为17，因为小时是从0到23标示的，其余的参数符合预期。<br>与Date.parse()一样。Date.UTC() 模仿与Date的构造函数，但是有一个主要的区别。创建日期的和时间在本地时区中，而不在GMT中。但是Date构造函数采用的与Date.UTC()相同的函数，因此如果第一个参数是数字，则够赞函数的假定它是日期的年份。第二个参数是月份，以此类推，可以写成<br>// January 1 , 2000 at midnight in local time<br>let y2k = new Date(2000,0)<br>// May 5 ,2005 at 5:55:55 PM local time<br>let allFives = new Date(2005,4,5,17,55,55)<br>但是两个日期都位于系统设置所确定的本地时区中<br>还提供了Date.now()，该方法返回执行毫秒数代表的日期和时间。使用此方法可以轻松的将Date对象用于代码分析。<br>// get start time<br>let start = Date.now()<br>// call a function<br>doSomething()<br>// get stop time<br>let stop = Date.now(),<br>  result = stop - start;<h3 id="Inherited-Methods-继承方法"><a href="#Inherited-Methods-继承方法" target="_blank" rel="noopener" class="headerlink" title="Inherited Methods 继承方法"></a>Inherited Methods 继承方法</h3>与其他引用类型一样，Date类型会覆盖 toLocaleString().toString()和valueOf()，尽管与之以前的类型不同，每种方法返回不同的内容。Date类型的toLocaleString()方法返回日期和时间以适合浏览器的语言环境的格式。这通常意味着该格式包含时间的AM或者PM，并且不包含任何时区的信息（确切的格式因浏览器而异）。toString 方法通常返回带有时区信息的日期和时间，并且该时间通常以24小时制表示。当en-US 区域设置中表示，PST 午夜2019年2月1日的日期和时间。以下显示toLocaleString() 和toString()格式<br>toLocaleString() - 2/1/2019 12：:00：:00 PM<br>toString() - Thu Feb 1 2019 00：:00：:0 GMT-0800 PST<br>现代浏览器已经融合这两种方法输出相同的字符串，使用旧版的浏览器，浏览器针对每种方法返回的搁置之间存在差异，这些差异意味着toLocalString() 和toString() 仅用于调试目的，而不是用于显示目的<br>Date类型的valueOf() 方法根本不会返回任何字符串，因为它被重写为返回日期的毫秒形式，以便运算符适用于日期值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// 一月一日，2019</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">// 2月1日，2019</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &lt;date2 &gt;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &gt; date2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
日期2019年1月1日早于 2019年2月1日，因此可以说前者少于后者。由于2019年1月1日的毫秒小于2019年2月1日的毫秒表示，因此小于日期运算符在比较日期的时候返回true，从而提供了一种确定日期顺序的简便方法。<h3 id="Date-Formatting-Methods-日期格式化方法"><a href="#Date-Formatting-Methods-日期格式化方法" target="_blank" rel="noopener" class="headerlink" title="Date-Formatting Methods 日期格式化方法"></a>Date-Formatting Methods 日期格式化方法</h3>有几种日期类型方法专门用于将日期格式化为字符串。</li>
<li>toDateString()  以实现特定的格式显示日期的星期，月份，日期和年。</li>
<li>toTimeString() 以实现特定的格式显示小时，分钟，秒和时区</li>
<li>toLocalDateString() 以实现特定格式显示日期的小时，分钟，秒和时区</li>
<li>toUTCString() 以特定格式显示完成UTC日期<br>这些方法输出的，与toLocalString() 和toString() 一样，因浏览器而异，因此不能在用户界面中使用以一致的显示日期<h3 id="Date-Time-Component-Methods"><a href="#Date-Time-Component-Methods" target="_blank" rel="noopener" class="headerlink" title="Date/Time Component Methods"></a>Date/Time Component Methods</h3>175页<br>日期的其余方法，直接处理或者和设置日期的特定部分</li>
</ul>
<h2 id="The-RegExp-Type-正则类型"><a href="#The-RegExp-Type-正则类型" target="_blank" rel="noopener" class="headerlink" title="The RegExp Type  正则类型"></a>The RegExp Type  正则类型</h2><p>通过RegExp类型支持正则表达式，正则表达式易于使用类似于Perl的语法创建<br>let expression = /pattern/flags;<br>表达式的模式部分可以是任何简单或者复杂的正则表达式，包括字符类，两次，分组，预行和向后引用。每个表达式可以具有零个或多个指示该表达式应该如何工作的标志，支持的三个标志表示匹配模式，如下表示：</p>
<ul>
<li>g 表示全局模式，表示将模式应用于所有字符串，而不是在找到一个匹配项后停止</li>
<li>i 表示不区分大小写的模式，这意味着在确定匹配项时将忽略模式和字符串的大小写</li>
<li>m 表示多行模式，意味着该模式将在一行文本的末尾后继续查找匹配项</li>
<li>y 表示粘滞模式，表示模式仅仅查看从lastIndex开始的字符串内容</li>
<li>u 表示已启用Unicode 模式<br>如本例所示，使用模式和这些标志的组合来创建正则表达式以产生不同的结果<br>// 匹配字符串中所有 at 的实例<br>let pattern1 = /at/g<br>// 匹配第一个，bat 或者 cat , 忽略大小写<br>let pattern2 = /[bc]at/i<br>// 匹配三个自怒 以 at 结尾的。忽略大小写<br>let pattern3 = /.at/gi<br>与其他语言中的正则表达式一样，当用作模式的一部分的时候，所有元字符都必须转义，元字符如下<br>([{^$|)]}?*+.<br>每个元字符在正则表达式语法中都有一个或者多个用途，因此当要匹配字符串中的字符的时候，必须用反斜杠将其转移，这里有些例子<br>// 匹配第一个实例 是bat 或者cat ,忽略大小写<br>let pattern1 = /[bc]at/i<br>// 匹配第一个实例是 [bc]at 忽略大小写<br>let  pattern2  = /[bc]at/i<br>// 匹配三个字母 以 at 结尾 忽略大小写<br>let pattern3 = /.at/gi<br>// 匹配所有 实例 .at ， 忽略大小写<br>let pattern4 = /.at/gi<br>再次代码中，pattern1 匹配的把bat 或者cat 的所有实例，无论大小写如何。要直接匹配[bc]at ， 两个方括号都需要使用反斜杠进行转移，如pattern2 中所示。 在pattern3中，点表示任何字符都可以在at之前匹配，如果要匹配 .at 则需要将点转义如pattern4 所示<br>前面的实例都是用文字形式定义了正则表达式，也可以使用RegExp 构造函数来创建正则表达式，该构造函数接收两个参数，要匹配的字符串模式和要应用的可选标志字符串，可以使用文字语法定义的任何正则表达式也可以使用构造函数来定义。、<br>// 匹配第一个 实例 有 bat 或者 cat ,忽略大小写<br>let pattern1 = /[bc]at/i<br>// 使用构造函数<br>let pattern2  = new RegExp(“[bc]at”, ‘i’)<br>在这里，pattern1 和 pattern2 定了相同的正则表达式，注意，RegExp构造函数的两个参数都是字符串（不应将正则表达式文字传递给RegExp 构造函数）。 因为 RegExp 构造函数模式 参数是一个字符串，所以在某些情况下 需要对字符串进行两次转移，所有元字符都必须被两次转义，已经转义的字符串也必须被转义。例如 \n (\字符，当在正则表达式字符串中使用时，通常会在字符串中转义为\变成\)。 下表以文字形式显示了一些模式以及使用 RegExp构造函数所需的等效字符串。<br>记住，使用文字创建正则表达式与使用RegExp构造函数创建正则表达式并不完全相同，正则表达式文字始终共享相同的RegExp实例，而通过构造函数创建的RegExp始终会导致一个新实例。<br>let re = null;<br>for (let i = 0; i &lt;10; i++){<br>  re = /cat/g;<br>  re.test(‘catastroppjo’)<br>}<br>for (let i = 0;i&lt;10; i++){<br>  re = new RegExp(‘cat’,’g’);<br>  re.test(‘catejijijijni’)<br>}<br>在第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp实例。由于实例属性不会重置，所以在循环中再次调用test（）方法会失败。这是因为第一次调用test（）找到了cat,但是第二次调用时从索引为3的字符开始的，所以就找不到他了。由于会测试到字符串末尾，所以下一次在调用test()就由从头开始了<br>第二个循环使用RegExp构造函数在每次循环中创建正则表达式。每次调用test()都会返回true,因为会为每次迭代创建一个新的RegExp实例。<br>也可以赋值现有的正则表达式实例，并可以选择使用构造函数修改其标志<br>const re1 = /cat/g; console.log(re1);  // “/cat/g”</li>
</ul>
<p>const re2 = new RegExp(re1); console.log(re2);  // “/cat/g”</p>
<p>const re3 = new RegExp(re1, “i”); console.log(re3);  // “/cat/i</p>
<h3 id="RegExp-Instance-Properties"><a href="#RegExp-Instance-Properties" target="_blank" rel="noopener" class="headerlink" title="RegExp Instance Properties"></a>RegExp Instance Properties</h3><p>每个RegExp 实例都有以下属性，这些属性可以获取有关模式的信息</p>
<ul>
<li>global 布尔值，表示是否设置了g标志</li>
<li>ignoreCase 布尔值，表示是否设置了i标志</li>
<li>unicode 布尔值，表示是否设置了u标志</li>
<li>sticky 布尔值，指示是否设置了y标志</li>
<li>lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从0开始</li>
<li>multiline 布尔值，表示是否设置了m 标志</li>
<li>source  正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
<li>flags 正则表达式的字符串标志，总是返回该值，以字面量形式制定的那样，而不是传递给构造函数的字符串模式。<br>这些属性有助于识别正则表达式的各个方面，但是他们通常都没有用，因为该信息可在模式声明中找到。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;         </span><br><span class="line"><span class="built_in">console</span>.log(pattern1.global);     <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.ignoreCase); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.multiline);  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);  <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.source);     <span class="comment">// "\[bc\]at" </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.flags);      <span class="comment">// "i"         </span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);         <span class="built_in">console</span>.log(pattern2.global);     <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.multiline);  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);  <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.source);     <span class="comment">// "\[bc\]at" </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.flags);      <span class="comment">// "i"</span></span><br></pre></td></tr></table></figure>
主义，尽管第一个模式使用过的是字面量，第二个模式使用的是RegExp构造函数，每个模式的source 和flags 属性也是等效的。课件source 和flags 属性保存的是规范形式的字符串，即字面量形式所用的字符串。<h3 id="RegExp-Instance-Methods-RegExp-实例方法"><a href="#RegExp-Instance-Methods-RegExp-实例方法" target="_blank" rel="noopener" class="headerlink" title="RegExp Instance Methods  RegExp 实例方法"></a>RegExp Instance Methods  RegExp 实例方法</h3>RegExp 对象的主要方法是 exec() ，该方法是专门为捕获组而设计的。exec() 方法接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；如果没有匹配项的情况下，则返回null。返回的数组尽管是array的实例，但是包含两个附加的属性：index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，任何其他项时与模式中的捕获租匹配的字符串（如果模式中没有捕获组，则该数组值包含一项）<br>let text = ‘mom and dad and baby’<br>let pattern = /mon (and dad ( and baby)?)?/gi<br>let matches = pattern.exec(text)<br>console.log(matches.index) //0<br>console.log(matches.input) // ‘mom and dad and baby’<br>console.log(matches[1]);     // “ and dad and baby” console.log(matches[2]);     // “ and baby”<br>在这个例子中的模式包含两个捕获租。最内部的捕获组匹配”and dad” 或者”and dad and baby”。 当把字符串传入exec()方法后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs 的index 属性值为0。 。数组中的第一个匹配的是整个字符串，第二项包含于第一个捕获租匹配的内容，第三项包含与第二个捕获组匹配的内容。<br>对于exec()方法而言，即使在模式中设置了全局标志g,他每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串多次调用exec()将始终返回第一个匹配项的信息。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat,sat,fat"</span></span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text)</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 0 console.log(matches[0]);          // cat console.log(pattern.lastIndex);   // 0         matches = pattern.exec(text);    console.log(matches.index);       // 0 console.log(matches[0]);          // cat console.log(pattern.lastIndex);   // 0</span></span><br></pre></td></tr></table></figure>
此实例中的模式不是全局模式，因此每次调用exec()都是返回第一个匹配项（”cat”）。在非全局模式下，lastIndex保持不变<br>在模式上设置了g标志之后，对exec()的每次调用都会进一步移入字符串以查找匹配项。<br>let text = “cat, bat, sat, fat”;<br>let pattern = /.at/g;<br>let matches = pattern.exec(text);<br>console.log(matches.index);       // 0<br>console.log(matches[0]);          // cat<br>console.log(pattern.lastIndex);   // 3<br>matches = pattern.exec(text);<br>console.log(matches.index);       // 5<br>console.log(matches[0]);          // bat<br>console.log(pattern.lastIndex);   // 8<br>matches = pattern.exec(text);<br>console.log(matches.index);       // 10<br>console.log(matches[0]);          // sat<br>console.log(pattern.lastIndex);   // 13<br>此模式是全局模式，因此每次调用exec() 都会返回字符串的下一个匹配项，直到到达字符串末尾位置。另请注意的模式的lastIndex属性如何受到影响。在全局模式下，每次调用exec() 后，lastIndex都会增加。lastIndex 跟踪紧接在最后一个匹配项右侧的字符的索引。<br>在模式设置了粘滞y标志后，每次对exec() 的调用都只会在lastIndex处的字符串搜索匹配项。否则就没有其他的地方。黏贴标志将覆盖全局标志。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;    </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/y</span>;         </span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);    </span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// cat </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 3         // There is no match starting at character index 3, so exec() will return null // exec() finding no matches resets lastIndex to 0 </span></span><br><span class="line">matches = pattern.exec(text);    </span><br><span class="line"><span class="built_in">console</span>.log(matches);             <span class="comment">// null </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Advancing lastIndex will allow a sticky regex exec() to find the next match: </span></span><br><span class="line">pattern.lastIndex = <span class="number">5</span>; </span><br><span class="line">matches = pattern.exec(text);    </span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 5 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// bat </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
正则表达式的另一种方法是text()， 它接受一个字符串参数，如果模式与参数相匹配，则返回true， 否则返回false. 当想知道某个模式是否匹配，但是不需要实际匹配的文本的时候，此方法很有用，test() 方法通常用于if 语句中例如：、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"000-00-0000"</span>;    </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;        </span><br><span class="line"> <span class="keyword">if</span> (pattern.test(text)) &#123;  <span class="built_in">console</span>.log(<span class="string">"The pattern was matched."</span>); &#125;</span><br></pre></td></tr></table></figure>
在这个例子中，正则表达式测试特定的数字序列，如果输入的文本与模式相匹配，则会显示一条消息。这功能通常用于验证用户输入，当您只在乎输入是否有效的时候、<br>toLocalString() 和toString() 的继承方法均返回正则表达式的文字表示形式，而不管其创建方式如何<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"gi"</span>); <span class="built_in">console</span>.log(pattern.toString());      <span class="comment">// /\[bc\]at/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.toLocaleString());  <span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure>
在此示例中的模式是使用RegExp构造函数创建的，toLocaleString()和toString() 方法仍然会向它是字面量形式创建一样显示其字符串表示。<br>正则表达式的valueOf()方法返回正则表达式本身。<h3 id="RegExp-Constructor-Properties-构造函数属性"><a href="#RegExp-Constructor-Properties-构造函数属性" target="_blank" rel="noopener" class="headerlink" title="RegExp Constructor Properties 构造函数属性"></a>RegExp Constructor Properties 构造函数属性</h3>RegExp 构造函数具有多个属性。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问他们。欢聚话说，这些属性分别有一个长属性名和一个短属性名<br>input  $_  最近一次要匹配的字符串<br>lastMatch $&amp; 最近一次的匹配项。<h3 id="Pattern-Limitations"><a href="#Pattern-Limitations" target="_blank" rel="noopener" class="headerlink" title="Pattern Limitations"></a>Pattern Limitations</h3><h2 id="Primitive-Wrapper-Types"><a href="#Primitive-Wrapper-Types" target="_blank" rel="noopener" class="headerlink" title="Primitive Wrapper Types"></a>Primitive Wrapper Types</h2><h3 id="The-Boolean-Type"><a href="#The-Boolean-Type" target="_blank" rel="noopener" class="headerlink" title="The Boolean Type"></a>The Boolean Type</h3><h3 id="The-Number-Type-·"><a href="#The-Number-Type-·" target="_blank" rel="noopener" class="headerlink" title="The Number Type ·"></a>The Number Type <strong>·</strong></h3><h3 id="The-isInteger-Method-and-Safe-Integers"><a href="#The-isInteger-Method-and-Safe-Integers" target="_blank" rel="noopener" class="headerlink" title="The isInteger() Method and Safe Integers"></a>The isInteger() Method and Safe Integers</h3><h2 id="The-String-Type"><a href="#The-String-Type" target="_blank" rel="noopener" class="headerlink" title="The String Type"></a>The String Type</h2><h3 id="The-JavaScript-Character"><a href="#The-JavaScript-Character" target="_blank" rel="noopener" class="headerlink" title="The JavaScript Character"></a>The JavaScript Character</h3><h3 id="The-normalize-Method"><a href="#The-normalize-Method" target="_blank" rel="noopener" class="headerlink" title="The normalize() Method"></a>The normalize() Method</h3><h3 id="String-Manipulation-Methods"><a href="#String-Manipulation-Methods" target="_blank" rel="noopener" class="headerlink" title="String-Manipulation Methods"></a>String-Manipulation Methods</h3><h3 id="String-Location-Methods"><a href="#String-Location-Methods" target="_blank" rel="noopener" class="headerlink" title="String Location Methods"></a>String Location Methods</h3><h3 id="String-Inclusion-Methods"><a href="#String-Inclusion-Methods" target="_blank" rel="noopener" class="headerlink" title="String Inclusion Methods"></a>String Inclusion Methods</h3><h3 id="The-trim-Method"><a href="#The-trim-Method" target="_blank" rel="noopener" class="headerlink" title="The trim() Method"></a>The trim() Method</h3><h3 id="The-repeat-Method"><a href="#The-repeat-Method" target="_blank" rel="noopener" class="headerlink" title="The repeat() Method"></a>The repeat() Method</h3><h3 id="The-padStart-and-padEnd-Methods"><a href="#The-padStart-and-padEnd-Methods" target="_blank" rel="noopener" class="headerlink" title="The padStart() and padEnd() Methods"></a>The padStart() and padEnd() Methods</h3><h3 id="String-Iterators-and-Destructuring"><a href="#String-Iterators-and-Destructuring" target="_blank" rel="noopener" class="headerlink" title="String Iterators and Destructuring"></a>String Iterators and Destructuring</h3><h3 id="String-Case-Methods"><a href="#String-Case-Methods" target="_blank" rel="noopener" class="headerlink" title="String Case Methods"></a>String Case Methods</h3><h3 id="String-Pattern-Matching-Methods"><a href="#String-Pattern-Matching-Methods" target="_blank" rel="noopener" class="headerlink" title="String Pattern-Matching Methods"></a>String Pattern-Matching Methods</h3><h3 id="The-localeCompare-Method"><a href="#The-localeCompare-Method" target="_blank" rel="noopener" class="headerlink" title="The localeCompare() Method"></a>The localeCompare() Method</h3><h3 id="HTML-Methods"><a href="#HTML-Methods" target="_blank" rel="noopener" class="headerlink" title="HTML Methods"></a>HTML Methods</h3><h2 id="Singleton-Built-in-objects"><a href="#Singleton-Built-in-objects" target="_blank" rel="noopener" class="headerlink" title="Singleton Built-in objects"></a>Singleton Built-in objects</h2><h3 id="The-Global-Object"><a href="#The-Global-Object" target="_blank" rel="noopener" class="headerlink" title="The Global Object"></a>The Global Object</h3><h4 id="URI-Encoding-Methods"><a href="#URI-Encoding-Methods" target="_blank" rel="noopener" class="headerlink" title="URI-Encoding Methods"></a>URI-Encoding Methods</h4><h4 id="The-eval-Method"><a href="#The-eval-Method" target="_blank" rel="noopener" class="headerlink" title="The eval() Method"></a>The eval() Method</h4><h4 id="Global-Object-Properties"><a href="#Global-Object-Properties" target="_blank" rel="noopener" class="headerlink" title="Global Object Properties"></a>Global Object Properties</h4><h4 id="The-Window-Object"><a href="#The-Window-Object" target="_blank" rel="noopener" class="headerlink" title="The Window Object"></a>The Window Object</h4><h3 id="The-Math-Object"><a href="#The-Math-Object" target="_blank" rel="noopener" class="headerlink" title="The Math Object"></a>The Math Object</h3><h4 id="Math-Object-Properties"><a href="#Math-Object-Properties" target="_blank" rel="noopener" class="headerlink" title="Math Object Properties"></a>Math Object Properties</h4><h4 id="The-min-and-max-Methods"><a href="#The-min-and-max-Methods" target="_blank" rel="noopener" class="headerlink" title="The min() and max() Methods"></a>The min() and max() Methods</h4><h4 id="Rounding-Methods"><a href="#Rounding-Methods" target="_blank" rel="noopener" class="headerlink" title="Rounding Methods"></a>Rounding Methods</h4><h4 id="The-random-Method"><a href="#The-random-Method" target="_blank" rel="noopener" class="headerlink" title="The random() Method"></a>The random() Method</h4><h4 id="Other-Methods"><a href="#Other-Methods" target="_blank" rel="noopener" class="headerlink" title="Other Methods"></a>Other Methods</h4><h2 id="Summary-1"><a href="#Summary-1" target="_blank" rel="noopener" class="headerlink" title="Summary"></a>Summary</h2></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="2020/02/06/newpapername/" data-id="ck6a7c1wq0000lwvmbjgrdnx4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="archives/2020/02/" target="_blank" rel="noopener">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2020/02/06/newpapername/" target="_blank" rel="noopener">JS 高级程序设计 读书笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Luxin Z<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" target="_blank" rel="noopener" class="mobile-nav-link">Home</a>
  
    <a href="/archives" target="_blank" rel="noopener" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="fancybox/jquery.fancybox.css">

  
<script src="fancybox/jquery.fancybox.pack.js"></script>




<script src="js/script.js"></script>




  </div>
</body>
</html>