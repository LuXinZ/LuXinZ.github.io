<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="用于分享读书笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="用于分享读书笔记">
<meta property="og:locale" content="zh">
<meta property="article:author" content="Luxin Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="LuXinZ.github.io/"/>





  <title>个人博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" target="_blank"  class="brand" rel="start noopener">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每日笔记</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" target="_blank" rel="section noopener">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" target="_blank" rel="section noopener">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/14/算法1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/14/算法1/" target="_blank" rel="noopener" itemprop="url">算法1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-14T12:54:35+08:00">
                2020-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最快最简答你的排序-桶排序"><a href="#最快最简答你的排序-桶排序" target="_blank" rel="noopener" class="headerlink" title="最快最简答你的排序  - 桶排序"></a>最快最简答你的排序  - 桶排序</h1><p>小明的班上只有5个同学，这5个同学分别考了5分，3分，5分，2分，和8分。 满分是10分。 接下来将分数进行从大到小排序。 排序后是 8 5 5 3 2 。 让计算机随机读入5个数然后将这5个数字从大大小输出<br>我们生命一个大小为11 的数组 ，现在已经有11个变量了编号从a[0] 到a[11]。 刚开始的时候，我们将a[0] 到 a[11] 都初始化为0，表示这些分数还没有人得过。例如a[0]等于0就表示还没有人得过0分，同理a[1] 等于0 就表示目前还没有人得过1分。、<br>下面开始处理每一个人的分数，第一个人的分数是5分，难么我们就将相对应的a[5]的值在原来的基础增加1 ，即a[5] 的值从0改为1， 表示5分出现了一次。<br>第二个人的分数是3分，我们就把相对应的a[3] 的值在原来的基础上增加1，即将a[3]的值从0 改为1 ，表示3 分出现过一次。<br>注意啦，第三个人的分数是5分，所以a[5] 的值需要在此基础上在增加1 ，即将a[5]的值从1 改为2 ，表示5分出现过了两次。<br>a[0]到a[10] 中的数值其实就是0分到10分每个分数出现的此处，接下来，我们只需要将出现过的分数打印出来就可以了，出现几次就打印几次。</p>
<h1 id="冒泡排序"><a href="#冒泡排序" target="_blank" rel="noopener" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的基本思想是： 每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。<br>例如我们需要将 12 35 99 18 76 这5个数从大到小的排序，既然是从大到小排序，也就是越小的越靠后。<br>首先比较第一位和第二位的大小，现在第一位是12， 第二位是35，发现12 比35 要小，因为我们希望越小越靠后嘛，因此需要交换这两个数的位置，交换之后这5个数的顺序是 35 12 99 18 76<br>按照刚才的方法，继续比较第二位和第三位的大小，第二位是12，第三位是99。 12比99 要小，因此需要交换这两个数字的位置，交换之后这5个数的顺序是 35 9 12 18 76<br>最后，比较第四位和第五位，4次比较之后5个数的顺序是 35 99 18 76 12<br>经过四次比较之后我们发现最小的一个数已经就位了，现在来回忆一下刚才的比较过程，每次都是比较相邻的两个数，如果后面的数比前面的数大，则交换这两个数的位置，一直比较下去直到最后两个数比较完毕后，最小的数就在最后一个了，就如同是一个气泡，一步一步往后翻滚，直到最后一位。所以这个排序的方法的名字叫做冒泡排序。<br>我们的排序只将5个数最小的一个归位了，每将一个数归位我们将其称为一趟，下面重复刚才的过程，将剩下的4个数字归位。<br>冒泡排序的原理是： 每一趟只能确定将一个数归位。即第一趟只能确定末位上的数，即第五位，归位。 第二趟只能将倒数第二位（第四位）归位，第三趟只能将倒数第三位的数归位，而现在前面还有两个位置上的数没有归位，因此我们仍然需要进行第四趟<br>第四趟只需要比较第一位和第二位的大小，因为后面三个位置上的数归位了，现在第一位是99，第二位是76，，无需交换，这5个数的顺序不变仍然是99 76 35 18 12。 到此排序完美结束了，5个数已经有4个数归位，那最后一个数也只能放在第一位了。<br>最后我们总结一下，如果有n个数进行排序，只需要将n-1个数归位，也就是说要进行n-1趟操作，而每一趟都需要从第一位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，知道最后一个尚未归位的数，已经归位的数无需在比较<br>冒泡排序的核心部分是双重嵌套循环不难看出冒泡排序的时间复杂度是O(N2)。这是一个非常高的时间复杂度。、</p>
<h1 id="最常用的排序-快速排序。"><a href="#最常用的排序-快速排序。" target="_blank" rel="noopener" class="headerlink" title="最常用的排序- 快速排序。"></a>最常用的排序- 快速排序。</h1><p>上一节的冒泡排序可以说是我们学习的第一个真正的排序算法，并且解决了桶排序浪费空间的问题，但在算法的执行效率上却牺牲了很多，它的时间复杂度达到了O(N2)。<br>假设我们现在对 6 1 2 7 9 3 4 5 10 8 这10个数进行排序。首先在这个序列中随便找一个数作为基准数。为了方便，就让第一个数6作为基准数吧，接下来，需要将这个序列汇总所有比基准数大的数放在6的右边，比基准数小的数放在6的左边。类似下面这种排序。<br>3 1 2 5 4 6 9 7 10 8<br>在初始状态下，数字6在序列的第一位，我们的目标是将6挪到序列中间的某个位置，假设这个位置是k，现在就需要寻找这个k,并且以第k位为分界点，左边的数都小于6， 右边的数都大于6.<br>方法其实很简单，分别从初始序列 6 1 2 7 9 3 4 5 10 8 两端开始探测，先从右往左找一个小于6的数，在从左往右找一个大于6的数字。然后交换他们，这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字哨兵i和哨兵j。 刚开始的时候让哨兵i指向序列的最左边，即i=1 ，指向数字6即j=10，指向数字8<br>首先哨兵j开始触动，因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，哨兵j一步一步地向左移动，j– ,知道找到一个小于6的数字停下来，接下来哨兵i在一步一步向右移动i++， 直到找到一个大于6的数停下来，最后哨兵j停在了数字5前面，哨兵i停在了数字7前面。<br>现在交换哨兵i和哨兵j所指向的元素的值，交换之后的序列如下。<br>6 1 2 【5】 9 3 4 【7】 10 8<br>到此第一次交换结束，接下来哨兵j继续向左移动，再次友情提示，每次必须是哨兵j先触发，她发现了4，之后听了下来，哨兵i也继续向右挪动，它发现了9之后停了下来。此时再次进行交换，交换之后序列如下<br>6 1 2 5 【4】 3 【9】 7 10 8<br>第二次交换结束，探测继续，哨兵j继续向左移动，它发现了3 之后又听了下来，哨兵i 继续 向右移动，此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到了3面前，说明此时探测结束，我们将基准数6和3 交换，交换之后的序列如下。<br>【3】 1 2 5 4 【6】 9 7 10 8<br>到此第一轮探测真正结束，此时以基准数6为分界点，6左边的数都小于等于6。6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找到小于基准数的数。而哨兵i的使命就是要找到大于基准数的数。直到i和j碰头为止。<br>现在基数6已经归位，它正好处在序列的第六位。此时我们已经将原来的序列，以6为分界点拆分成两个序列，左边的序列是 3 1 2 5 4 ，右边的序列是 9 7 10 8 。 接下来还需要分别处理这两个序列，因为6左边和右边的序列目前还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。<br>现在先来处理6左边的序列<br>左边的序列是 3 1 2 5 4。 请将这个序列以3 为基准数进行调整，是的3左边的数都小于等于3 ，3 右边的数都大于等于3<br>如果模拟的没有错，调整完毕之后的序列的顺序应该会是<br>2 1 3 5 4<br>ok， 现在3 已经归位，接下来需要处理3 左边的序列 2 1 和右边的序列 5 4 。 对序列 2 1 以 2 为基准进行调整，处理完毕之后的序列为1 2 ， 到此2 已经归位，序列1 只有一个数，也不需要进行任何处理。 至此我们对序列 2  1 已经全部处理完毕 ，得到的序列是 1 2 。 序列 5 4 的处理也按照此方法，最后得到的序列如下。<br>1 2 3  4 5 6 9 7 10 8<br>对于系列<br>到此排序完全结束，快速排序的每一轮处理其实就是将这一轮的基准数归位，知道所有的数都归位为止，排序就结束了。<br>快速排序之所以比较快，是因为相比冒泡排序，每次交换都是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全放到右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就打得多了，因此总的比较和交换次数就少了，速度自然提高了，当然在最欢的情况下，扔可能是相邻的两个数进行了交换，因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2) 它的平均时间复杂度为O（NlogN）。 其实快速排序是基于一种叫做二分的思想。</p>
<h1 id="小哼买书"><a href="#小哼买书" target="_blank" rel="noopener" class="headerlink" title="小哼买书"></a>小哼买书</h1><p>输入有 2 行，第 1 行为一个正整数，表示有 n 个同学参与调查（n≤100）。第 2 行有 n 个用空格隔开的正整数，为每本图书的 ISBN号（假设图书的 ISBN号在 1~1000之间）。<br>输出也是 2行，第 1行为一个正整数 k，表示需要买多少本书。第 2行为 k个用空格隔 开的正整数，为从小到大已排好序的需要购买的图书的 ISBN号。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/13/面试题大图上传功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/13/面试题大图上传功能/" target="_blank" rel="noopener" itemprop="url">面试题大图上传功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-13T20:03:33+08:00">
                2020-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/08/vue学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/08/vue学习/" target="_blank" rel="noopener" itemprop="url">vue学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T13:37:41+08:00">
                2020-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/06/JS 高级程序设计 读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/06/JS 高级程序设计 读书笔记/" target="_blank" rel="noopener" itemprop="url">JS 高级程序设计 读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-06T00:27:57+08:00">
                2020-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="变量，-范围，-和-内存"><a href="#变量，-范围，-和-内存" target="_blank" rel="noopener" class="headerlink" title="变量， 范围， 和 内存"></a>变量， 范围， 和 内存</h1><h2 id="primitive-原始值-和-reference-values-引用值"><a href="#primitive-原始值-和-reference-values-引用值" target="_blank" rel="noopener" class="headerlink" title="primitive 原始值 和 reference values 引用值"></a>primitive 原始值 和 reference values 引用值</h2><ul>
<li>变量中包含两种不同的类型数据<ul>
<li>原始值 就是简单的数据，基本数据类型</li>
<li>引用值： 就是由多个值组成的对象</li>
</ul>
</li>
<li>将数据值分配给一个变量之后，JS 必须要确定他的数据类型是原始值还是引用值。</li>
<li>六个原始/基本类型 ： undefined ，null , boolean, string, number, symbol,<ul>
<li>这些变量是按值访问的，因为你正在操作的就是存储在变量中的实际值</li>
</ul>
</li>
<li>引用值是储存在内存的对象，JS 不允许直接访问内存的位置，一年春不允许直接操作对象的内存空间。当你操作一个对象时候，你实际上是对该对象的引用进行操作，而不是实际的对象本身，因此，可以说这些值是通过引用访问的。<h3 id="Dynamic-properties-动态属性"><a href="#Dynamic-properties-动态属性" target="_blank" rel="noopener" class="headerlink" title="Dynamic properties 动态属性"></a>Dynamic properties 动态属性</h3>原始值和引用值的定义类似：当一个变量创建后并为其分配值。但是执行的操作却大不相同，使用引用值的时候，可以随时添加，更改或者删除属性的方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'Jack'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
这里，创建了一个对象，并存储到变量person 中，接下来，为这个对象添加了一个名为name 的属性，并且为其分配了字符串Jack.从现在起，就可以访问新属性了，知道对象被销毁，或者属性明确地移除<br>但是，原始值不能添加属性，即使这样做不会报错<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Nicholas"</span>; </span><br><span class="line">name.age = <span class="number">27</span>; </span><br><span class="line"><span class="built_in">console</span>.log(name.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
这里，在字符串name定义了一个age 属性，并且为其赋值27，。但是在下一行，属性不存在。<br>所以只有引用值可以定义属性供以后使用。<br>注意： 原始类型的实例化可以使用基本文字形式。如果要是用new关键字，JS 将创建一个Object类型，但是这个行为类似于基本。<br>这是例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">'Jack'</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Matt'</span>)</span><br><span class="line">name1.age = <span class="number">27</span>;</span><br><span class="line">name2.age = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age) ; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age) ; <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1) <span class="comment">// String</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2) <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
可以看出，new之后， 将会变为对象<h3 id="Copying-Values-复制值"><a href="#Copying-Values-复制值" target="_blank" rel="noopener" class="headerlink" title="Copying Values 复制值"></a>Copying Values 复制值</h3>除了存储方式不同之外，原始值和引用值在从一个变量复制到另一个变量时的作用也不同。将原始值从一个变量分配给另一个变量时，值储存在变量对象被创建和复制到新变量的位置。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num1 &#x3D; 5;</span><br><span class="line">let num2 &#x3D; num1;</span><br></pre></td></tr></table></figure>
这里，num1的值是5，当num2 初始化为num1 时，它也获得值5。该值与num1中存储的值完全分开。因为这是那个值的复制。<br>现在每个值都可以单独使用，而没有副作用<br>当引用值从一个变量分配给另一个变量的时候，存储在变量对象上的值也会复制到新变量的位置。区别在于该值实际上是指向在对象存储的堆。一旦操作完成了，两个变量指向完全相同的对象。因此对一个变量的更改会反应在另一个变量上。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.name= <span class="string">'Jack'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name) <span class="comment">// 'Jack'</span></span><br></pre></td></tr></table></figure>
变量boj1 填充到了一个new 实例的对象中，然后将值赋值到obj2,这意味着两个变量都指向相同的对象。当属性名设置在obj1上，这个属性可以从obj2上进行访问，因为他们指向相同的对象。<h3 id="Argument-Passing-参数传递"><a href="#Argument-Passing-参数传递" target="_blank" rel="noopener" class="headerlink" title="Argument Passing  参数传递"></a>Argument Passing  参数传递</h3>JS 中所有函数的参数均是按值传递。这意味着将函数外部的值复制到函数内部的参数中，就像值从一个变量复制到另一变量中。如果值是是原始值，则其行为就像是基本变量的拷贝，如果值是引用值，则其行为就像是引用变量的拷贝。因为变量既可以通过值和引用访问，但是参数只能通过值传递。<br>当参数通过值传递，该值将被复制到局部变量 local variable。当参数通过引用传递，值在内存中的位置是存储在局部变量中，这意味着对局部变量的更改将将反应在函数的外部<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log (count) <span class="comment">// 20 - no change</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
在这里，函数addTen() 有一个参数 num, 这是个局部变量。当调用时，这个变量count作为参数传递。，此变量的值是20，将其赋值到参数num 中然后在addTen() 内部使用。在函数中，参数num的值通过加10进行了更改，但是它没有更改函数外部存在的原始的变量。参数num 和变量 variable 无法互相识别，他们恰巧有相同的价值。如果num 通过引用传递，然后count的值将更改为30，以反映在函数内部所做的更改。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'jack'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person)</span><br><span class="line">consol.log(person.name) <span class="comment">// jack</span></span><br></pre></td></tr></table></figure>
在此代码中，将创建一个对象并储存在变量person 中，然后将对象传递到setName() 方法中，然后将其赋值到obj中。在函数内部，obj和person 都是指向相同的对象、结果是obJ是引用来访问对象的，即使他通过值传递到函数中。 当name属性被设置到函数内部的obj中，此更改将反应在函数的外部。因为它指向的对象存在堆中的全局。当全局更改反应到对象的局部更改时，这意味着参数已经通过引用传递了。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'jack'</span></span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    obj.name = <span class="string">'Rose'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 'Jack'</span></span><br></pre></td></tr></table></figure>
这个例子中与上一个例子中的唯一变化是，在setName() 中添加了两行，将obj重新定义为新的对象并且带有不同的name。当person将值传递到setName() 中，其中的name属性被设置为jack.然后变量obj被设置为新的对象，并且他name的属性被设置Rose。 如果person通过引用传递，这个person将会自动指向Rose的对象。但是当再次访问person.name的时候，这个值还是Jack。这表明，即使参数的值在函数内部更改了，原始引用值仍然保持不变。当obj在函数被覆盖，他将会变成指针指向局部对象。函数执行完成后，这个局部对象会被销毁。<h3 id="Determining-Type-确定类型"><a href="#Determining-Type-确定类型" target="_blank" rel="noopener" class="headerlink" title="Determining Type  确定类型"></a>Determining Type  确定类型</h3>typeof 是确定原始数据类型的最佳方法，但是只是string，number,boolean, undefined. 这些类型<br>如果值是object 和null ，则会返回object、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'Jack'</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>  <span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> u;  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>   <span class="comment">// object</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);   <span class="comment">// string </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i);   <span class="comment">// number </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);   <span class="comment">// boolean console.log(typeof u);   // undefined </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n);   <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o);   <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
尽管typeof 用于原始数据类型，但是很少用于引用数据类型。<br>如果想知道他是什么类型的对象， JS 中提供了instanceof 运算符<br>语法：<br>result = variable  instanceof constructor<br>instanceof 会返回一个true 如果这个变量是给定引用类型give reference type <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// person 是不是对象</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// color 是不是数组</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="comment">// pattern 是是不是正则</span></span><br></pre></td></tr></table></figure>
根据定义，所有引用值都是Object的实例。因此instanceof运算符与引用值和Object构造函数一起一起使用时始终返回true。 同样，如果 instanceof 使用的是基本类型值，它会返回false,因为基本值不是对象<br>当在函数上用typeof的时候会返回function。 <h2 id="EXECUTION-CONTEXT-AND-SCOPE-执行上下和作用域"><a href="#EXECUTION-CONTEXT-AND-SCOPE-执行上下和作用域" target="_blank" rel="noopener" class="headerlink" title="EXECUTION CONTEXT AND SCOPE 执行上下和作用域"></a>EXECUTION CONTEXT AND SCOPE 执行上下和作用域</h2>执行上下文，简称上下文，在JS 中至关重要。变量和函数的执行上下文定义了它可以访问的其他数据和其执行方式。每个执行上下文都有一个关联的变量对象，其所有定义的变量和函数都存在于该对象上。这个对象无法通过代码访问，但在后台被用于处理数据。<br>全局上下文是最外部的上下文。根据JS事先的主主机环境，表示此上下问的对象可能不同。在浏览器中，全局上下文是被称为window 的对象。所以使用var定义的所有全局变量和函数都被作为属性和方法创建在window 对象上。<br>声明使用let和const 在最顶层不会被定义在全局上下文中。但是他们在作用域脸上的解析方式相同。当执行上下文执行完所有代码后，他就会销毁，并且带走其定义的所有变量和函数（全局上下文不会被销毁除非应用程序退出，例如关闭网页和关闭应用程序的时候）<br>每个函数调用自己的执行上下文。每当代码执行流入函数中，函数的上下文就会被推送到上下文堆中。函数执行完成后，堆就会弹出，并且返回控制权到上一个执行上下文。这个功能通过ESMC的程序控制执行流程<br>当代码被执行在上下文中，将创建变量对象的作用域链。作用域链的目的提供对执行上下中有权访问的所有变量和函数进行有序访问。作用域链的前端始终是代码正在执行的上下文的变量对象、如果上下文是函数，就会激活对象用作变量对象。激活对象以一个定义为参数的变量开始。（这对于全局上下文不存在）。链中的下一个变量对象来自包含上下文，而其后的下一个变量对象来自下一个包含上下文。这种模式一直持续到全局上下文找到。全局上下文变量对象一直是作用域链中的最后一个。<br>通过导航作用域链以搜索标识符名称来解析标识符。搜索始终从链的最前面开始，一直进行到最后，直到标识符被找到（如果找不到标识符通常会发生错误。）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (color ===<span class="string">'blue'</span>)&#123;</span><br><span class="line">        color = <span class="string">"red"</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        color = <span class="string">"blue"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor()</span><br></pre></td></tr></table></figure>
函数changeColor()的作用域链包含了两个对象在里面：他自己的变量对象（在其上定义了参数对象）。和全局作用域变量对象、这个变量color是可以在函数内部访问的，因为他可以在作用域链中找到。<br>此外，局部定义变量可以用来与全局变量交换在局部上线文中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> anotherColor =<span class="string">"red"</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor</span><br><span class="line">        <span class="comment">// color, anotherColor, and tempColor are all accessible here </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// color and anotherColor are accessible here, but not tempColor swapColors();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only color is accessible here </span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
此代码包含了三个执行上下文：全局上下文，局部上下文changeColor() , 和局部上下文swapColor()、全局上下文有一个变量，color和一个函数。changeColor(). 局部上下文changeColor() 有一个变量anotherColor 和一个函数命名文swapColor(),但它依然可以访问变量color 从全局上下文中。局部上下文swapColro() 有一个变量tempColor， 它只能在该上下文中访问。无论是全局上下文或者局部上下文swapColors() 都无法访问到tempcolor。 但是，在swapColors() 中，其他两个上下文中的变量是完全可以访问的。因为他是父执行上下文、<br>在这个表格中。矩形代表特定的执行上下文。内部上下文可以访问所有外部上下文中的所有内容通过作用域链。但是外部上不可以访问任何在内部上下文中的内容。这个链接有线性的并且有秩序的。每个上下文可以搜索作用域链中的变量和函数，但是没有上下文可以向下索索作用域链中的另一个执行上下文。作用域链中局部上下文swapColors存在三个对象: swapColors() 变量对象，变量对象来自changeColor() 和 全局变量对象。swapColors() 的局部上下文开始寻找变量和函数名称在它自己变量对象中，在沿着链前进之前。changeColor() 的上下文的作用域链只有两个对象： 是自己变量对象和全局变量对象。这意味着它无法访问swapColor() 的上下文、<br>函数参数被视为变量，并且和其他变量在执行上下文中有相同的访问规则<h3 id="Scope-Chain-Augmentatio-延长作用域链"><a href="#Scope-Chain-Augmentatio-延长作用域链" target="_blank" rel="noopener" class="headerlink" title="Scope Chain Augmentatio 延长作用域链"></a>Scope Chain Augmentatio 延长作用域链</h3>即使执行环境只有两种主要类型：即全局和函数（第三种存在于eval()的调用内），但是还有其他的途径扩展作用域链。某些语句可以在作用域链的连段临时增加一个变量对象，，然后在代码执行后移除此变量对象。有两种情况会发生这种现象，特别是当执行进入以下任意情况时：<br>try-catch 语句中的catch块。<br>with 语句<br>这两个语句豆浆一个变量对象添加到作用域链的最前端。对于with语句，将指定的对象添加到租用与链。对于catch语句，将创建一个新的变量对象并且包含引发错误对象的声明。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function buildUrl()&#123;</span><br><span class="line">    LET qs&#x3D; &quot;?debug&#x3D;true&quot;</span><br><span class="line">    whit(location)&#123;</span><br><span class="line">        let url &#x3D; href + qs</span><br><span class="line">    &#125;</span><br><span class="line">    return url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
whit 语句作用域 location 对象，所以location本身被添加到作用域的前面。buildURL()函数中定义了一个变量qs。当在with语句中引用变量href时候，引用的是location.href。当变量qs被引用的时候，引用的是正在buildUrl()中的定义的变量，该变量在函数环境的变量对象中。在with语句背部，则声明了一个url变量，这个变量成为了函数环境的一个部分，因此可以作为函数的值返回<h3 id="变量声明"><a href="#变量声明" target="_blank" rel="noopener" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="Function-Scope-Declaration-Using-var-使用var的函数声明范围"><a href="#Function-Scope-Declaration-Using-var-使用var的函数声明范围" target="_blank" rel="noopener" class="headerlink" title="Function Scope Declaration Using var 使用var的函数声明范围"></a>Function Scope Declaration Using var 使用var的函数声明范围</h4>使用var声明变量的时候，他会自动的添加到可用的最接近的环境中。在函数中，最近接的环境就是函数局部环境。在with语句中，最接近的就是函数韩静。如果初始化的时候没有事先声明变量，则该变量会自动添加到全局环境中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 无效变量错误</span></span><br></pre></td></tr></table></figure>
这里，函数add()定义了一个局部变量sum， 其中包含了加法的运算结果。虽然结果从函数值返回了，但是变量sum不是可以在函数外部访问的。如果var 这个关键字被省略掉，sum就会变成可以在add()执行完毕后，可以访问的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    sum = num1+ num2</span><br><span class="line">    <span class="keyword">return</span> sum </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">//30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 3-</span></span><br></pre></td></tr></table></figure>
变量sum被初花一个值，但是并没有使用关键字var进行声明。调用add()的时候，sum在全局环境中创建，并且即使代码执行完毕后，也可以在之后的代码中访问<br>在严格模式下，初始化未经声明的变量会导致错误<br>var 声明将置于函数或者全局作用域的顶部，并且位于其中的任何现有代码之前。这种被称为hoisting， 提升。这允许你安全的使用提升的函数在作用域的任何地方，而不需要考虑是否声明了。但是，实际上，这会导致合法但奇怪的代码，其中在变量声明之前就是使用了该变量。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span></span><br><span class="line"><span class="comment">// 等同于 :</span></span><br><span class="line">name = <span class="string">'jack'</span></span><br><span class="line"><span class="keyword">var</span> name</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'jake'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    name = <span class="string">'Jake'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是可以通过在变量声明之前检查自己的变量是否被提升了。你会看到undefined而不是ReferenceError<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'jake'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'jake'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Block-Scope-Declaration-Using-let-使用let的块级声明"><a href="#Block-Scope-Declaration-Using-let-使用let的块级声明" target="_blank" rel="noopener" class="headerlink" title="Block Scope Declaration Using let 使用let的块级声明"></a>Block Scope Declaration Using let 使用let的块级声明</h4>let可以和var相同的方式进行操作，但是它的作用域是块级的。块级作用域的概念是最接近的一组大括号{}。这意味着，if快，while块，function块，甚至独立快将成为用let声明的任何变量的范围。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//  报错，ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//  ReferenceError: b is not defined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">//  ReferenceError: c is not defined,，这个var 也会引发错误</span></span><br><span class="line"><span class="comment">// 这不是对象文字，这是一个独立的快</span></span><br><span class="line"><span class="comment">// js会基于内容识别</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> d</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// ReferenceError: d is not defined</span></span><br></pre></td></tr></table></figure>
与var的行为类似，不能再同一范围内两次声明let。重复的var声明将被忽略，宠物的let声明会引发语法错误syntaxError<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// no errors thrown</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 语法错误： SyntaxError: identifier b has already been declared</span></span><br></pre></td></tr></table></figure>
当在循环体中使用迭代器，let的行为特别有用、使用var的声明迭代器完成后外流循环。这种行为是非常不好的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span> ;j++&gt;)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(j) <span class="comment">// ReferenceError, J没有定义</span></span><br></pre></td></tr></table></figure>
let 在JS中运行的时候是技术提升的。但是由于存在临时性四驱。因此无法使用该变量在其声明的上方。因此let 与 var 的提升方式不同。<h4 id="Constant-Declaration-Using-const-使用const的常量声明"><a href="#Constant-Declaration-Using-const-使用const的常量声明" target="_blank" rel="noopener" class="headerlink" title="Constant Declaration Using const 使用const的常量声明"></a>Constant Declaration Using const 使用const的常量声明</h4>ES6 还引入了const 作为陪伴let，使用const声明的变量必须初始化为某个值。一次声明后，就不能重新分配给新的值了在其声明周期的任何时候。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="comment">//  报错，缺少初始化。</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 3</span></span><br><span class="line">b= <span class="number">4</span> <span class="comment">// TypeError: Assignment to a constant variable</span></span><br></pre></td></tr></table></figure>
除了执行const 规则外，const变量行为与let 一样<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;  <span class="keyword">const</span> a = <span class="number">0</span>; &#125; <span class="built_in">console</span>.log(a);  <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="keyword">const</span> b = <span class="number">1</span>; &#125; <span class="built_in">console</span>.log(b);  <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">const</span> c = <span class="number">2</span>; &#125; <span class="built_in">console</span>.log(c);  <span class="comment">// ReferenceError: c is not defined</span></span><br><span class="line"> </span><br><span class="line">&#123;  <span class="keyword">const</span> d = <span class="number">3</span>; &#125; <span class="built_in">console</span>.log(d);  <span class="comment">// ReferenceError: d is not defined</span></span><br></pre></td></tr></table></figure>
const 声明仅适用于处于顶级的基本类型和对象。换句话说，const变量不能将分配给对象的值重新分配给另一个殷涌智，但是该对象内部的键值不受到保护、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 =&#123;&#125;</span><br><span class="line">o1 = &#123;&#125; <span class="comment">// TypeError: Assignment to a constant variable;</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125; </span><br><span class="line">o2.name = <span class="string">'jake'</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.name)  <span class="comment">// jake</span></span><br></pre></td></tr></table></figure>
如果希望整个对象都变的不可以更改，可以使用Object.freeze，尽管尝试分配属性不会引发错误；他只会默默的失败<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;)</span><br><span class="line">o3.name = <span class="string">'jake'</span></span><br><span class="line"><span class="built_in">console</span>.log(o3.name) ; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
由于const 声明暗示该值是单一类型且不可变的。因此JS 运行编译器时候可以用实际值替换其所有势力，而不用通过变量表查询该变量。V8引擎执行了这样的优化。<h4 id="Identifier-Lookup-标识符查询"><a href="#Identifier-Lookup-标识符查询" target="_blank" rel="noopener" class="headerlink" title="Identifier Lookup 标识符查询"></a>Identifier Lookup 标识符查询</h4>挡在某个环境中为了读取或写入而引用一个标志服，必须通过搜索一确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字相匹配的标识符。如果它在局部连梁中找到了该标识符名称，则搜索就会停止并且设置该变量。如果搜索不到这个变量名字，他会继续沿着作用链向上搜索。（请注意，作用域链中的对象也是具有原型链的，因此搜索可能会包含每个对象的原型链）此过程一直寻找到全局环境的变量对象位置，如果在在此找不到标识符，则说明尚未声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
当调用函数getColor（） 的时候，将引用变量color。此时，将会开始两步搜索。第一步getColor() 的变量对象中搜索一个包含名为color 的标识符。 当找不到该对象的时候，将搜索（从全局环境中）到下一个变量对象，然后在那里找到了名为color 的标识符。因为在该变量对象中定义了颜色，所以搜索结束。<br>在此搜索过程中，引用局部变量自动会停止搜索，不在进入另一个变量对象。这意味着，如果局部环境中的标识符存在相同的名称，则无法引用位于父环境中的标识符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">'red'</span></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">// red</span></span><br></pre></td></tr></table></figure>
使用块级域声明不会改变搜索进程，但是会为为词汇层次结构添加额外的级别。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">'red'</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> color = <span class="string">'green'</span></span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()) <span class="comment">// green</span></span><br></pre></td></tr></table></figure>
在此修改后的代码中，在getColor() 函数中声明的名为color局部变量，在调用函数的时候，这个变量会被声明。当函数的第二行执行的时候，它知道命名为color的变量必须被使用。搜索从局部环境开始，在找到变量名称为color，值为green。因为找到了变量，所以这个搜索停止了，并且这个局部变量被使用了，这意味着这个函数会返回green。任何位于局部变量color声明之后的代码都不能将都不能访问全局color 变量如果限定其使用window.color。如果一个操作数是一个对象，而另一个不是、valueOf() 方法会被调用，以检索原始值的方法根据原先的规则。<h2 id="Garbage-Collection-垃圾收集"><a href="#Garbage-Collection-垃圾收集" target="_blank" rel="noopener" class="headerlink" title="Garbage Collection 垃圾收集"></a>Garbage Collection 垃圾收集</h2>JS 具有垃圾收集的语言。，这意味着操作环境会负责管理代码执行期间所需要的内存。而在C和C++ 语言中，跟踪内存的使用是一个主要问题，开发人员的一项基本任务就是手工跟踪内存的使用情况。JS 通过自动分配所需的内容并回收不在使用的内存，使得开发人员不必担心内存管理。这种原理很简单：找出将不在使用的变量，释放与其关联的内存。此过程是周期性的，垃圾收集器以指定的时间间隔（或在代码执行中预定义收集时候）运行。垃圾回收的过程是一个近似且不完善的解决方案，因为知道知道是否需要某些内存的一般问题是不确定的，这意味着无法用算法解决。<br>考虑函数中局部变量的正常声明周期。该变量值在函数执行的过程中存在，那时，内存在堆（可能是栈）内存分配，以提供一个该值的储存空间。这个变量被使用在函数内部，然后函数结束。此时，不需要此变量，因为可以回收其内存以供以后使用。在这种情况下，显然不需要该变量。但是并非所有情况都是这样显而易见。垃圾收集器必须跟踪那些变量可以使用那些不可以使用，对不在有用的变量打上标记，以备将来收回其占用的内存。尽管传统上的浏览器使用了连个中策略：用于标识未使用的变量的策略可能会因事先方式而有所不同。但是这些策略通常是 mark-and-sweep 标记清除 和 reference counting 引用计数<h3 id="Mark-and-Sweep-标记清除"><a href="#Mark-and-Sweep-标记清除" target="_blank" rel="noopener" class="headerlink" title="Mark-and-Sweep  标记清除"></a>Mark-and-Sweep  标记清除</h3>JS 中最受欢迎的垃圾回收是标记清除。当变量进入到环境中，例如变量在函数中声明，会将其标记在环境中。从逻辑上讲，环境中的变量永远都不应该释放内存，继续使用它就会可能会在环境中继续执行，当变量离开环境，他也会被标记上脱离环境。<br>可以使用多种方式来标记变量，可以通过反转某个特殊的位来记录变量何时进入了环境。或者在使用一个进入环境的变量列表以及离开环境的变量列表。标记的实现并不重要，关键是理论。、<br>当垃圾收集器运行的时候，它将标记存储在内存中的所有变量（可以使用任何标记方式），然后它将清除环境中的变量和被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将会被视为删除的变量，原因是环境中的变量已经无法访问他们了。然后垃圾收集器完成内存清除工作，销毁那些标记的值并且回收他们所占用的内存空间。<br>从2008年开始，尽管垃圾回收的是时间不同，但是浏览器在其JS 中都使用了标记清除式的垃圾收集策略。<h3 id="Reference-Counting-引用计数"><a href="#Reference-Counting-引用计数" target="_blank" rel="noopener" class="headerlink" title="Reference Counting 引用计数"></a>Reference Counting 引用计数</h3>未完成 163 页<h3 id="Performance"><a href="#Performance" target="_blank" rel="noopener" class="headerlink" title="Performance"></a>Performance</h3>未完成163 页<h3 id="Managing-Memory"><a href="#Managing-Memory" target="_blank" rel="noopener" class="headerlink" title="Managing Memory"></a>Managing Memory</h3>未完成164页<h4 id="Performance-Boosts-with-const-and-let-Declarations"><a href="#Performance-Boosts-with-const-and-let-Declarations" target="_blank" rel="noopener" class="headerlink" title="Performance Boosts with const and let Declarations"></a>Performance Boosts with const and let Declarations</h4>在ES6中引入这些关键字不仅对代码风格有好处，而且对垃圾收集过程也有好处。因为const 和let 的作用域是块而不是函数，所以根据代码的组织方式，这可能会对垃圾回收器发出信号，表明已经分配的变量是符合清除的资格，相对于使用var的时候来说。当会计作用域远早于函数作用域终止时，就会发生这种情况<h4 id="Hidden-Classes-and-the-delete-Operation-隐藏类和删除操作"><a href="#Hidden-Classes-and-the-delete-Operation-隐藏类和删除操作" target="_blank" rel="noopener" class="headerlink" title="Hidden Classes and the delete Operation 隐藏类和删除操作"></a>Hidden Classes and the delete Operation 隐藏类和删除操作</h4>根据您希望JS 运行的位置，有时候值得考虑基于浏览器使用JS引擎的各种性能影响。V8利用隐藏类，当接收后的JS便以为实际的机器代码，如果正在编写对性能很敏感的代码，很重要<br>在运行的时候，V8将关联隐藏的类在对象创建之后，并且跟踪其属性的形状、对象是能够共享相同的隐藏的类会有更高的性能，v8将会对此优化但是并非总是如此<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'Hello'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article()</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article()</span><br></pre></td></tr></table></figure>
在后台，V8将配置两个类实例共享相同的隐藏的类。这是有道理的，因为他们共享一个构造函数和原型。假设将一下代码添加到此代码的末尾。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.author &#x3D; &#39;jake&#39;</span><br></pre></td></tr></table></figure>
现在这两个Article 实例将具有两个不同的隐藏类事项。根据此操作的频率和隐藏类的大小，这可能会对性能产生重要的影响<br>解决方案当时避免分配JS 的ready-fire-aim动态属性，而是在构造函数中声明所有属性。若夏<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'Hello'</span></span><br><span class="line">    <span class="keyword">this</span>.author = opt_author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br></pre></td></tr></table></figure>
现在，这两个实例的行为基本上是相同的（不计算hasOwnProperty的返回值），并且他们还将共享一个隐藏的类，从而有可能提高性能。请记住，尽管使用delete关键字可以生成相同的隐藏类碎片。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'Hello'</span></span><br><span class="line">    <span class="keyword">this</span>.author = <span class="string">'jake'</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">delete</span> a1.author</span><br></pre></td></tr></table></figure>
在此代码端的结尾，即使两个实例使用同一的构造函数，那么他们也不再共享隐藏的类。动态删除属性将产生于动态添加相同的效果。最佳做法要求将不需要的属性设置为null，它将允许隐藏的类保存原样和共享，并且对于删除引用具有相同的作用，以便使垃圾回收器收益。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">'hello'</span></span><br><span class="line">    <span class="keyword">this</span>.author = <span class="string">'jake'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1= <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article()</span><br><span class="line">a1.author =<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h4 id="Memory-Leaks-内存泄露"><a href="#Memory-Leaks-内存泄露" target="_blank" rel="noopener" class="headerlink" title="Memory Leaks 内存泄露"></a>Memory Leaks 内存泄露</h4>未完成 166 页<h4 id="Static-Allocation-and-Object-Pools-Static-Allocation-and-Object-Pools"><a href="#Static-Allocation-and-Object-Pools-Static-Allocation-and-Object-Pools" target="_blank" rel="noopener" class="headerlink" title="Static Allocation and Object Pools Static Allocation and Object Pools"></a>Static Allocation and Object Pools Static Allocation and Object Pools</h4>未完成167页 <h3 id="Summary"><a href="#Summary" target="_blank" rel="noopener" class="headerlink" title="Summary"></a>Summary</h3>可以在JS 变量中存储两种类型的值，基本值和引用值。基本值有六个：undefined， null ， string , number, symbol,boolean.</li>
<li>基本值和引用值有如下特征<ul>
<li>基本值是固定大小的，因此存储在堆内存中。</li>
<li>将基本值从一个变量赋值到另一个变量，将创建这个值的第二个拷贝。</li>
<li>引用值是对象，储存在堆内存中。</li>
<li>包含引用值的变量世纪上仅包含指向对象的指针，不包含对象本身</li>
<li>将引用值复制到另一个变量仅仅复制指针，因此两个变量最终都引用同一对象。</li>
<li>typeof 运算符确定值的原始类型，而instanceof运算符用于确定值的引用类型</li>
</ul>
</li>
<li>所有变量（）都存在于操作环境中（也叫做作用域），环境确定变量生命周期和那些代码可以访问它。操作环境可以总结如下：<ul>
<li>操作环境存在全局，成为全局环境，在函数内部和块内部</li>
<li>每次进入新的操作环境中，它都会创建一个作用域链以搜索变量和函数</li>
<li>函数或者块级不仅可以访问作用域中变量还可以访问任何包含环境和全局环境的变量在环境中、</li>
<li>全局环境只能访问变量或者函数在全局环境，不能直接访问数据在任何局部环境中</li>
<li>变量的操作环境有助于确定何时释放内存。</li>
</ul>
</li>
<li>JS是一个具有垃圾回收的变成环境，开发人员无需担心内存的分配和回收。JS 的垃圾回收流程如下<ul>
<li>超出范围的值会被自动表弟并且回收，并且在垃圾回收过程中删除。</li>
<li>主要垃圾收集算法成为 标记清除， 该算法会标记当前未使用的值，然后返回以回收该内存。</li>
<li>另一种算法是引用计数，该算法跟踪特定值有多少个引用，JS 不在使用此算法，但是由于JS 中访问了非本地JS对象，它仍然会影响IE</li>
<li>当代码中存才循环引用的时候，引用计数会导致问题，</li>
<li>接触变量的引用不仅有助于消除循环引用对象，而且对垃圾收集也有好处，为了确保有效的回收内存，应该及时解除不在使用的全局对象，全局对象属性以及循环引用变量的引用。<h1 id="Basic-Reference-Type"><a href="#Basic-Reference-Type" target="_blank" rel="noopener" class="headerlink" title="Basic Reference Type"></a>Basic Reference Type</h1>未完成 171<h2 id="The-Date-Type-日期类型"><a href="#The-Date-Type-日期类型" target="_blank" rel="noopener" class="headerlink" title="The Date Type 日期类型"></a>The Date Type 日期类型</h2>Date() 类型基于JAVA的早期版本，因此，日期类型将日期存储为UTC 自1970年1月1日以来经过的毫秒数。使用此数据储存格式，日期类型可以表示285616之后的日期。<br>若要创建日期对象，使用new运算符以及Date构造函数<br>let now = new Date()<br>使用不带参数的Date构造函数的时候，将会创建对象，并且分配当前的日期和时间。要给予其他日期或者时间创建日期，必须传入日期的毫秒。为了帮助完成此过程，提供了两种方法Date.parse() 和Date.UTC()<br>Date.parse() 方法接受表示日期的字符串参数。它尝试将字符串转换为日期的毫秒数表示。应该支持现在的格式日期。所有实现都必须支持一下日期格式。</li>
</ul>
</li>
<li>month/date/year (例如，5/23/2019)</li>
<li>month_name date, year(such as May 23,2019)</li>
<li>day_of_week month_name date year hours:minutes:seconds time_zone (such as Tue May 23 2019 00:00:00 GMT-0700) </li>
<li>ISO 8601 extended format YYYY-MM-DDTHH:mm:ss.sssZ (such as 2019-0523T00:00:00). This works only in ECMAScript 5–compliant implementations.<br>例如，要为2019年5月23日创建日期对象，可以使用一下代码：<br>let someDate = new Date(Date.parse(‘May 23,2019’))<br>如果传递给Data.parse() 的字符串不能代表一个日期，则其返回NaN。 如果直接传递一个字符串，则Date的构造函数将在调用Date.parse() ，这意味一下代码以前面的实例相同<br>let someDate = new Date(‘May 23, 2019’)<br>这个<br>Date.UTC() 方法也返回日期的毫秒数表示，但是使用与Data.parse()不同的信息构造该值。Date.UTC() 的参数是年，从零开始的月，月份中的一天，和小时，分钟，秒，以及毫秒。在参数中，只有前两个（年和月）是需要的。如果没有提供当月的日期，则假设为1。而所有其他省略的参数都假定为0。<br>这是Date的两个实例，UTC()的作用<br>// January 1 , 2000 at midnight GMT<br>let y2k = new Date(Date.UTC(2000,0))<br>// May 5, 2005 at 5:55:55 PM GMT<br>let allFives = new Date(Date.UTC(2005,4,5,17,55,55))<br>在此实例中创建连个日期，第一个日期是2000年1月1日，以2000年和0个月（即1月）表示。由于其他参数已经填写（将月份中的设置为1，将其他所有内容都设置为0），因此结果是该月的第一天午夜。第二个时期表示2005年5月5日5：55：:55，即是日期和时间仅仅包含5位，创建该日期也需要一些不同的数字，必须将月份设置为4、因为月份是从零开始的，而必须将消失设置为17，因为小时是从0到23标示的，其余的参数符合预期。<br>与Date.parse()一样。Date.UTC() 模仿与Date的构造函数，但是有一个主要的区别。创建日期的和时间在本地时区中，而不在GMT中。但是Date构造函数采用的与Date.UTC()相同的函数，因此如果第一个参数是数字，则够赞函数的假定它是日期的年份。第二个参数是月份，以此类推，可以写成<br>// January 1 , 2000 at midnight in local time<br>let y2k = new Date(2000,0)<br>// May 5 ,2005 at 5:55:55 PM local time<br>let allFives = new Date(2005,4,5,17,55,55)<br>但是两个日期都位于系统设置所确定的本地时区中<br>还提供了Date.now()，该方法返回执行毫秒数代表的日期和时间。使用此方法可以轻松的将Date对象用于代码分析。<br>// get start time<br>let start = Date.now()<br>// call a function<br>doSomething()<br>// get stop time<br>let stop = Date.now(),<br>  result = stop - start;<h3 id="Inherited-Methods-继承方法"><a href="#Inherited-Methods-继承方法" target="_blank" rel="noopener" class="headerlink" title="Inherited Methods 继承方法"></a>Inherited Methods 继承方法</h3>与其他引用类型一样，Date类型会覆盖 toLocaleString().toString()和valueOf()，尽管与之以前的类型不同，每种方法返回不同的内容。Date类型的toLocaleString()方法返回日期和时间以适合浏览器的语言环境的格式。这通常意味着该格式包含时间的AM或者PM，并且不包含任何时区的信息（确切的格式因浏览器而异）。toString 方法通常返回带有时区信息的日期和时间，并且该时间通常以24小时制表示。当en-US 区域设置中表示，PST 午夜2019年2月1日的日期和时间。以下显示toLocaleString() 和toString()格式<br>toLocaleString() - 2/1/2019 12：:00：:00 PM<br>toString() - Thu Feb 1 2019 00：:00：:0 GMT-0800 PST<br>现代浏览器已经融合这两种方法输出相同的字符串，使用旧版的浏览器，浏览器针对每种方法返回的搁置之间存在差异，这些差异意味着toLocalString() 和toString() 仅用于调试目的，而不是用于显示目的<br>Date类型的valueOf() 方法根本不会返回任何字符串，因为它被重写为返回日期的毫秒形式，以便运算符适用于日期值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// 一月一日，2019</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">// 2月1日，2019</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &lt;date2 &gt;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &gt; date2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
日期2019年1月1日早于 2019年2月1日，因此可以说前者少于后者。由于2019年1月1日的毫秒小于2019年2月1日的毫秒表示，因此小于日期运算符在比较日期的时候返回true，从而提供了一种确定日期顺序的简便方法。<h3 id="Date-Formatting-Methods-日期格式化方法"><a href="#Date-Formatting-Methods-日期格式化方法" target="_blank" rel="noopener" class="headerlink" title="Date-Formatting Methods 日期格式化方法"></a>Date-Formatting Methods 日期格式化方法</h3>有几种日期类型方法专门用于将日期格式化为字符串。</li>
<li>toDateString()  以实现特定的格式显示日期的星期，月份，日期和年。</li>
<li>toTimeString() 以实现特定的格式显示小时，分钟，秒和时区</li>
<li>toLocalDateString() 以实现特定格式显示日期的小时，分钟，秒和时区</li>
<li>toUTCString() 以特定格式显示完成UTC日期<br>这些方法输出的，与toLocalString() 和toString() 一样，因浏览器而异，因此不能在用户界面中使用以一致的显示日期<h3 id="Date-Time-Component-Methods"><a href="#Date-Time-Component-Methods" target="_blank" rel="noopener" class="headerlink" title="Date/Time Component Methods"></a>Date/Time Component Methods</h3>175页<br>日期的其余方法，直接处理或者和设置日期的特定部分</li>
</ul>
<h2 id="The-RegExp-Type-正则类型"><a href="#The-RegExp-Type-正则类型" target="_blank" rel="noopener" class="headerlink" title="The RegExp Type  正则类型"></a>The RegExp Type  正则类型</h2><p>通过RegExp类型支持正则表达式，正则表达式易于使用类似于Perl的语法创建<br>let expression = /pattern/flags;<br>表达式的模式部分可以是任何简单或者复杂的正则表达式，包括字符类，两次，分组，预行和向后引用。每个表达式可以具有零个或多个指示该表达式应该如何工作的标志，支持的三个标志表示匹配模式，如下表示：</p>
<ul>
<li>g 表示全局模式，表示将模式应用于所有字符串，而不是在找到一个匹配项后停止</li>
<li>i 表示不区分大小写的模式，这意味着在确定匹配项时将忽略模式和字符串的大小写</li>
<li>m 表示多行模式，意味着该模式将在一行文本的末尾后继续查找匹配项</li>
<li>y 表示粘滞模式，表示模式仅仅查看从lastIndex开始的字符串内容</li>
<li>u 表示已启用Unicode 模式<br>如本例所示，使用模式和这些标志的组合来创建正则表达式以产生不同的结果<br>// 匹配字符串中所有 at 的实例<br>let pattern1 = /at/g<br>// 匹配第一个，bat 或者 cat , 忽略大小写<br>let pattern2 = /[bc]at/i<br>// 匹配三个自怒 以 at 结尾的。忽略大小写<br>let pattern3 = /.at/gi<br>与其他语言中的正则表达式一样，当用作模式的一部分的时候，所有元字符都必须转义，元字符如下<br>([{^$|)]}?*+.<br>每个元字符在正则表达式语法中都有一个或者多个用途，因此当要匹配字符串中的字符的时候，必须用反斜杠将其转移，这里有些例子<br>// 匹配第一个实例 是bat 或者cat ,忽略大小写<br>let pattern1 = /[bc]at/i<br>// 匹配第一个实例是 [bc]at 忽略大小写<br>let  pattern2  = /[bc]at/i<br>// 匹配三个字母 以 at 结尾 忽略大小写<br>let pattern3 = /.at/gi<br>// 匹配所有 实例 .at ， 忽略大小写<br>let pattern4 = /.at/gi<br>再次代码中，pattern1 匹配的把bat 或者cat 的所有实例，无论大小写如何。要直接匹配[bc]at ， 两个方括号都需要使用反斜杠进行转移，如pattern2 中所示。 在pattern3中，点表示任何字符都可以在at之前匹配，如果要匹配 .at 则需要将点转义如pattern4 所示<br>前面的实例都是用文字形式定义了正则表达式，也可以使用RegExp 构造函数来创建正则表达式，该构造函数接收两个参数，要匹配的字符串模式和要应用的可选标志字符串，可以使用文字语法定义的任何正则表达式也可以使用构造函数来定义。、<br>// 匹配第一个 实例 有 bat 或者 cat ,忽略大小写<br>let pattern1 = /[bc]at/i<br>// 使用构造函数<br>let pattern2  = new RegExp(“[bc]at”, ‘i’)<br>在这里，pattern1 和 pattern2 定了相同的正则表达式，注意，RegExp构造函数的两个参数都是字符串（不应将正则表达式文字传递给RegExp 构造函数）。 因为 RegExp 构造函数模式 参数是一个字符串，所以在某些情况下 需要对字符串进行两次转移，所有元字符都必须被两次转义，已经转义的字符串也必须被转义。例如 \n (\字符，当在正则表达式字符串中使用时，通常会在字符串中转义为\变成\)。 下表以文字形式显示了一些模式以及使用 RegExp构造函数所需的等效字符串。<br>记住，使用文字创建正则表达式与使用RegExp构造函数创建正则表达式并不完全相同，正则表达式文字始终共享相同的RegExp实例，而通过构造函数创建的RegExp始终会导致一个新实例。<br>let re = null;<br>for (let i = 0; i &lt;10; i++){<br>  re = /cat/g;<br>  re.test(‘catastroppjo’)<br>}<br>for (let i = 0;i&lt;10; i++){<br>  re = new RegExp(‘cat’,’g’);<br>  re.test(‘catejijijijni’)<br>}<br>在第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp实例。由于实例属性不会重置，所以在循环中再次调用test（）方法会失败。这是因为第一次调用test（）找到了cat,但是第二次调用时从索引为3的字符开始的，所以就找不到他了。由于会测试到字符串末尾，所以下一次在调用test()就由从头开始了<br>第二个循环使用RegExp构造函数在每次循环中创建正则表达式。每次调用test()都会返回true,因为会为每次迭代创建一个新的RegExp实例。<br>也可以赋值现有的正则表达式实例，并可以选择使用构造函数修改其标志<br>const re1 = /cat/g; console.log(re1);  // “/cat/g”</li>
</ul>
<p>const re2 = new RegExp(re1); console.log(re2);  // “/cat/g”</p>
<p>const re3 = new RegExp(re1, “i”); console.log(re3);  // “/cat/i</p>
<h3 id="RegExp-Instance-Properties"><a href="#RegExp-Instance-Properties" target="_blank" rel="noopener" class="headerlink" title="RegExp Instance Properties"></a>RegExp Instance Properties</h3><p>每个RegExp 实例都有以下属性，这些属性可以获取有关模式的信息</p>
<ul>
<li>global 布尔值，表示是否设置了g标志</li>
<li>ignoreCase 布尔值，表示是否设置了i标志</li>
<li>unicode 布尔值，表示是否设置了u标志</li>
<li>sticky 布尔值，指示是否设置了y标志</li>
<li>lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从0开始</li>
<li>multiline 布尔值，表示是否设置了m 标志</li>
<li>source  正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
<li>flags 正则表达式的字符串标志，总是返回该值，以字面量形式制定的那样，而不是传递给构造函数的字符串模式。<br>这些属性有助于识别正则表达式的各个方面，但是他们通常都没有用，因为该信息可在模式声明中找到。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;         </span><br><span class="line"><span class="built_in">console</span>.log(pattern1.global);     <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.ignoreCase); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.multiline);  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);  <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.source);     <span class="comment">// "\[bc\]at" </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.flags);      <span class="comment">// "i"         </span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);         <span class="built_in">console</span>.log(pattern2.global);     <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.multiline);  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);  <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.source);     <span class="comment">// "\[bc\]at" </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.flags);      <span class="comment">// "i"</span></span><br></pre></td></tr></table></figure>
主义，尽管第一个模式使用过的是字面量，第二个模式使用的是RegExp构造函数，每个模式的source 和flags 属性也是等效的。课件source 和flags 属性保存的是规范形式的字符串，即字面量形式所用的字符串。<h3 id="RegExp-Instance-Methods-RegExp-实例方法"><a href="#RegExp-Instance-Methods-RegExp-实例方法" target="_blank" rel="noopener" class="headerlink" title="RegExp Instance Methods  RegExp 实例方法"></a>RegExp Instance Methods  RegExp 实例方法</h3>RegExp 对象的主要方法是 exec() ，该方法是专门为捕获组而设计的。exec() 方法接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；如果没有匹配项的情况下，则返回null。返回的数组尽管是array的实例，但是包含两个附加的属性：index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，任何其他项时与模式中的捕获租匹配的字符串（如果模式中没有捕获组，则该数组值包含一项）<br>let text = ‘mom and dad and baby’<br>let pattern = /mon (and dad ( and baby)?)?/gi<br>let matches = pattern.exec(text)<br>console.log(matches.index) //0<br>console.log(matches.input) // ‘mom and dad and baby’<br>console.log(matches[1]);     // “ and dad and baby” console.log(matches[2]);     // “ and baby”<br>在这个例子中的模式包含两个捕获租。最内部的捕获组匹配”and dad” 或者”and dad and baby”。 当把字符串传入exec()方法后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs 的index 属性值为0。 。数组中的第一个匹配的是整个字符串，第二项包含于第一个捕获租匹配的内容，第三项包含与第二个捕获组匹配的内容。<br>对于exec()方法而言，即使在模式中设置了全局标志g,他每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串多次调用exec()将始终返回第一个匹配项的信息。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat,sat,fat"</span></span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text)</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 0 console.log(matches[0]);          // cat console.log(pattern.lastIndex);   // 0         matches = pattern.exec(text);    console.log(matches.index);       // 0 console.log(matches[0]);          // cat console.log(pattern.lastIndex);   // 0</span></span><br></pre></td></tr></table></figure>
此实例中的模式不是全局模式，因此每次调用exec()都是返回第一个匹配项（”cat”）。在非全局模式下，lastIndex保持不变<br>在模式上设置了g标志之后，对exec()的每次调用都会进一步移入字符串以查找匹配项。<br>let text = “cat, bat, sat, fat”;<br>let pattern = /.at/g;<br>let matches = pattern.exec(text);<br>console.log(matches.index);       // 0<br>console.log(matches[0]);          // cat<br>console.log(pattern.lastIndex);   // 3<br>matches = pattern.exec(text);<br>console.log(matches.index);       // 5<br>console.log(matches[0]);          // bat<br>console.log(pattern.lastIndex);   // 8<br>matches = pattern.exec(text);<br>console.log(matches.index);       // 10<br>console.log(matches[0]);          // sat<br>console.log(pattern.lastIndex);   // 13<br>此模式是全局模式，因此每次调用exec() 都会返回字符串的下一个匹配项，直到到达字符串末尾位置。另请注意的模式的lastIndex属性如何受到影响。在全局模式下，每次调用exec() 后，lastIndex都会增加。lastIndex 跟踪紧接在最后一个匹配项右侧的字符的索引。<br>在模式设置了粘滞y标志后，每次对exec() 的调用都只会在lastIndex处的字符串搜索匹配项。否则就没有其他的地方。黏贴标志将覆盖全局标志。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;    </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/y</span>;         </span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);    </span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// cat </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 3         // There is no match starting at character index 3, so exec() will return null // exec() finding no matches resets lastIndex to 0 </span></span><br><span class="line">matches = pattern.exec(text);    </span><br><span class="line"><span class="built_in">console</span>.log(matches);             <span class="comment">// null </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Advancing lastIndex will allow a sticky regex exec() to find the next match: </span></span><br><span class="line">pattern.lastIndex = <span class="number">5</span>; </span><br><span class="line">matches = pattern.exec(text);    </span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 5 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// bat </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
正则表达式的另一种方法是text()， 它接受一个字符串参数，如果模式与参数相匹配，则返回true， 否则返回false. 当想知道某个模式是否匹配，但是不需要实际匹配的文本的时候，此方法很有用，test() 方法通常用于if 语句中例如：、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"000-00-0000"</span>;    </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;        </span><br><span class="line"> <span class="keyword">if</span> (pattern.test(text)) &#123;  <span class="built_in">console</span>.log(<span class="string">"The pattern was matched."</span>); &#125;</span><br></pre></td></tr></table></figure>
在这个例子中，正则表达式测试特定的数字序列，如果输入的文本与模式相匹配，则会显示一条消息。这功能通常用于验证用户输入，当您只在乎输入是否有效的时候、<br>toLocalString() 和toString() 的继承方法均返回正则表达式的文字表示形式，而不管其创建方式如何<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"gi"</span>); <span class="built_in">console</span>.log(pattern.toString());      <span class="comment">// /\[bc\]at/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.toLocaleString());  <span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure>
在此示例中的模式是使用RegExp构造函数创建的，toLocaleString()和toString() 方法仍然会向它是字面量形式创建一样显示其字符串表示。<br>正则表达式的valueOf()方法返回正则表达式本身。<h3 id="RegExp-Constructor-Properties-构造函数属性"><a href="#RegExp-Constructor-Properties-构造函数属性" target="_blank" rel="noopener" class="headerlink" title="RegExp Constructor Properties 构造函数属性"></a>RegExp Constructor Properties 构造函数属性</h3>RegExp 构造函数具有多个属性。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问他们。欢聚话说，这些属性分别有一个长属性名和一个短属性名<br>input  $_  最近一次要匹配的字符串<br>lastMatch $&amp; 最近一次的匹配项。<br>lastParen &amp;+ 最近一次匹配的补货组<br>leftContext $` input 字符串中lastMatch之前的文本<br>rightContext $’ input 字符串中lastMatch 之后的文本<br>使用这些属性可以从exec()或者text() 执行的操作中提取出更具体的信息<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"this has been a short summer"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input);         <span class="comment">// this has been a short summer  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext);   <span class="comment">// this has been a        </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext);  <span class="comment">// summer </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch);     <span class="comment">// short  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastParen);     <span class="comment">// s </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
这段代码创建了一个模式，匹配任何一个字符后跟hort, 而且把第一个字符放在一个捕获租中。<br>各种属性用法如下：<br>input 属性返回了原始字符串<br>leftContext 属性返回了单词short 之前的字符串，而rightContext 属性返回了short 之后的字符串<br>lastMatch 属性返回最近一次与整个正则表达式匹配的字符串。 即short<br>lastParen 属性返回最近一次匹配的捕获租，即例子中的s<br>这些长属性名都可以用相应的短属性名来代替，只不过短属性名大都不是有效的标识符，因此必须通过方括号语法来访问他们<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"this has been a short summer"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>;         <span class="comment">/* * Note: Opera doesn't short property names. * Internet Explorer doesn't support multiline. */</span>    </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_);         <span class="comment">// this has been a short summer  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]);      <span class="comment">// this has been a        </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]);      <span class="comment">// summer  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]);      <span class="comment">// short  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]);      <span class="comment">// s  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
除了上面的几个属性之外，还有多大9个用于储存捕获租的构造函数属性。访问这些属性RegExp.$1,RegExp.$2,RegExp.$3,…RegExp.$9, 分别用于存储第一，第二。。到第九个匹配的捕获组。在调用exec() 和test() 方法时候，这些属性会被自动填充。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"this has been a short summer"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(..)or(.)/g</span>;  </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);   <span class="comment">// sh  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);   <span class="comment">// t &#125;</span></span><br></pre></td></tr></table></figure>
这里创建了包含两个捕获组的模式，并用该模式测试了一个字符串，即使test()方法值返回一个布尔值。但RegExp构造函数的属性$1和$2 也会被匹配相应的捕获组的字符串自动填充<br>这些构造函数属性，都不是任何web标准的一部分，避免使用<h3 id="Pattern-Limitations"><a href="#Pattern-Limitations" target="_blank" rel="noopener" class="headerlink" title="Pattern Limitations"></a>Pattern Limitations</h3>p185 未写完<h2 id="Primitive-Wrapper-Types-基本包装类型"><a href="#Primitive-Wrapper-Types-基本包装类型" target="_blank" rel="noopener" class="headerlink" title="Primitive Wrapper Types 基本包装类型"></a>Primitive Wrapper Types 基本包装类型</h2>为了便于操作基本类型值，还提供了3个特殊的引用类型： Boolean,Number, String 这些类型与本章介绍的其他引用类型相似，但是同时也具有各自的基本类型相应的特殊行为。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"some text"</span></span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
这个例子变量s1包含了一个字符串，字符串当然是基本类型值。而下一行调用了s1的substring() 方法，并将返回的结果保存在了s2中。基本类型值不是对象，因而从逻辑上讲他们不应该有方法。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问s1的时候，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串的时候，后台都会自动完成以下的处理。</li>
</ul>
<ol>
<li>创建String 类型的一个实例</li>
<li>在实例上调用指定的方法</li>
<li>销毁这个实例。<br>可以想到以下三个代码中使用的三个步骤。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>)</span><br><span class="line">s1 = <span class="literal">null</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">此行为允许原始字符串充当对象。。而且上面三个步骤也适用于 Boolean 和number 类型对应的布尔值和数字值</span></span><br><span class="line"><span class="string">引用类型与基本包装类型的主要区别就是对象的生存期。使用new 运算符创建的引用类型实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型值添加属性和方法。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">"some text"</span></span><br><span class="line">s1.color = <span class="string">"red"</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.color) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
在此，第二行代码试图为字符串s1添加一个color 属性，但是当第三行代码在此访问s1的时候，其color 属性不见了。问题的原因就是第二行创建的String 对象在执行第三行代码的时候已经被销毁了，第三行代码又创建自己的String对象，而该对象没有color 属性。<br>当然，可以显式地调用Boolean ，number 和string 。不过，应该在绝对必要的情况下在这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例条用typeof 会返回object ，而所有基本包装类型的对象都会被转换为布尔值true<br>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
把字符串传给object 构造函数，就会创建string的实例，而传入数值参数会得到number的实例，传入布尔值参数就会得到Boolean的实例。<br>使用new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">"25"</span></span><br><span class="line"><span class="keyword">let</span> number = <span class="built_in">Number</span>(value) <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number) <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value) <span class="comment">// constructor</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj) <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
在这个例子中，变量number 中保存的基本类型的值25，而变量obj中保存的是Number的实例<br>尽管不建议显式地创建基本包装类型的对象，但他们操作基本类型的能力还是相当重要的，而每个基本包装类型都提供了操作相应值的便捷方法。<h3 id="The-Boolean-Type"><a href="#The-Boolean-Type" target="_blank" rel="noopener" class="headerlink" title="The Boolean Type"></a>The Boolean Type</h3>Boolean 类型是与布尔值相对应的引用类型。要创建Boolean 对象，可以像下面嗲用Boolean 构造函数并传入true 或false 值<br>let booleanObject  = new Boolean(true)<br>Boolean 类型的实例重写了valueOf() 方法，返回基本类型值true 或者false。 重写toString() 方法，返回字符串true 和false 、 可是，Boolean 对象的用处不大， 因为他经常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用Boolean对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// true         </span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>; </span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
在这个例子中，我们使用false值创建了一个Boolean 对象，然后将这个对象与基本类型值true构成了逻辑表达式，在布尔运算中，false &amp;&amp; true 等于 false， 可是，实例中的这行代码是对falseObject 而不是对它的值false 进行求值。布尔表达式中的所有对象都会被转换为true ，因此 falseObject 对象在布尔表达式中代表的true。 结果true &amp;&amp; true 当然就等于true了<br>基本类型与引用类型的布尔值还有两个区别。首先typeof操作符对基本类型返回Boolean。而对引用类型返回object，其次由于Boolean对象是Boolean类型的实例，所以使用instanceof 操作符测试boolean 对象返回true ，而此时基本类型的布尔值则返回false。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject);        <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue);         <span class="comment">// boolean </span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="The-Number-Type"><a href="#The-Number-Type" target="_blank" rel="noopener" class="headerlink" title="The Number Type"></a>The Number Type</h3>number 类型是数字值的引用类型，要创建number 对象，可以在调用number构造函数时向中传递相应的数值。<br>let numberObject = new Number(10)<br>与Boolean 类型一样，number 类型也重写了valueOf() ,toLocaleString() 和toString() 方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。toString() 方法可以选择接受一个参数，该参数用于表示数字的技术，告诉他返回即几进制数值的字符串形式。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toString());    <span class="comment">// "10"</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));   <span class="comment">// "1010" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));   <span class="comment">// "12" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>));  <span class="comment">// "10" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>));  <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
除了继承的方法之外，number类型还提供了一些用于将数值格式化为字符串的方法。<br>toFixed() 方法会按照指定的小数位返回数值的字符串表示。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)) <span class="comment">// "10.00"</span></span><br></pre></td></tr></table></figure>
这里给toFixed() 方法传入了数值2 ，意思就是显示几位小数。于是这个方法就返回”10.00”,即以0填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10.005</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
toFixed()的舍入特性，是的很适合处理货币值。多个浮点值之间的算数运算可能不会产生确切的结果，例如0.1+0.2 =0.30000004<br>另外一种方法是toExponential() ， 该方法返回以指数表示法（也成为e表示法），表示的数值的字符串形式。与toFixed() 一样，toExponential () 也接受一个参数，而且该参数同样也是指定输出结果中的小数位数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num =<span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.lgo(num,toExponential(<span class="number">1</span>))  <span class="comment">// "1.0e+1"</span></span><br></pre></td></tr></table></figure>
此代码输出了1.0e+1 不过这么小的数值一般不必使用e表示法，如果想得到表示某个数值的最合适的格式，就应该是用toPrecision()方法<br>toPrecision() 方法返回数字的固定大小格式，也可能返回指数格式，具体规则是看哪种格式最合适。这种方法接受一个参数，即表示数值的所有数字的位数。（不包括指数部分。）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>));  <span class="comment">// "1e+2" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>));  <span class="comment">// "99" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>));  <span class="comment">// "99.0"</span></span><br></pre></td></tr></table></figure>
在实例中，第一个任务是用一个数字来表示99，结果是1e+2 ，否则成为100. 由于99不能只用一个数字来准确表示，因此该方法四舍五入为100，这样就可以使用一位数来表示它了。而接下来的用两位数表示99，当然还是99。最后，在想以三位数表示99的时候，toPrecision() 方法返回了99.0 实际上，toPrecision() 会根据要处理的数值决定到底是调用toFixed() 还是调用toExponential() 。而这三个方法都可以通过向上或者向下舍入，做到以最准确的形式来表示带正确小数位的值。<br>与Boolean对象类似，number 对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化number 类型，而原因与显式创建Boolean对象一样，就是在使用typeof 和instanceof操作符测试基本类型数值与引用类型数值时候，得到的结果完全不同，<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">let</span> numberValue = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObject);       <span class="comment">// "object" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberValue);        <span class="comment">// "number" </span></span><br><span class="line"><span class="built_in">console</span>.log(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
在使用typeof 操作符测试基本类型数值的时候，始终会返回number， 而在测试number对象的时候，则会返回object， 类似的number对象是number 类型的实例，而基本类型的数值则不是。<h4 id="The-isInteger-Method-and-Safe-Integers-安全整数"><a href="#The-isInteger-Method-and-Safe-Integers-安全整数" target="_blank" rel="noopener" class="headerlink" title="The isInteger() Method and Safe Integers  安全整数"></a>The isInteger() Method and Safe Integers  安全整数</h4>ES6中引入了Number.isInteger() 方法能够辨别数字值是否存储为整数，当十进制0可能掩盖该数字是否已浮点格式储存的时候，此功能很有用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1</span>));     <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.00</span>));  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.01</span>));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
IEEE 754 数字格式具有不同的数值范围，在该范围内二进制值可以恰好表示一个整数值。此数字范围从Number.MIN_SAFE_INTEGER -2^53 + 1 到  Number.MAX_SAFE_INTEGER  2^53 - 1. 在此范围之外，可以尝试存储整数，但是此编码格式意味着此二进制也可能别名为完全不同的数字。要确定数字是否在此范围内，可以使用Number.isSafeInteger() 方法轻松检查。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">-1</span> * (<span class="number">2</span> ** <span class="number">53</span>)));      <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">-1</span> * (<span class="number">2</span> ** <span class="number">53</span>) + <span class="number">1</span>));  <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span> ** <span class="number">53</span>));             <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger((<span class="number">2</span> ** <span class="number">53</span>) - <span class="number">1</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">### The String Type</span></span><br><span class="line"><span class="string">String 类型 是字符串的对象包装类型，可以使用string 构造函数来创建</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"helle world"</span>)</span><br></pre></td></tr></table></figure>
String对象的方法在所有基本的字符串值中访问到。其中继承的valueOf(), toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。<br>String类型的每个实例都包含一个属性，即length， 该属性指示字符串中的字符数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.length) <span class="comment">//11</span></span><br></pre></td></tr></table></figure>
本示例输出11 ， 即hello world 中的字符串，清楚一，即使字符串中包含双字节字符（不是占一个字节的ASCII字符），每个字符也仍然算一个字符。<br>String类型提供了很多方法，用于辅助完成对字符串的解析和操作。<h4 id="The-JavaScript-Character-JS-字符"><a href="#The-JavaScript-Character-JS-字符" target="_blank" rel="noopener" class="headerlink" title="The JavaScript Character  JS 字符"></a>The JavaScript Character  JS 字符</h4>JS 字符串由16位代码单元组成，对于大多数字符，每个16位代码单元将对应一个字符。length属性就是指示字符串内出现了多少个16位代码单元<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"abcde"</span></span><br><span class="line"><span class="built_in">console</span>.log(message.length) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
此外，charAt() 以单字符字符串的形式返回给定位置的那个字符，该索引由方法的整数参数指定。具体来说，此方法在制定的索引出找到16位代码单元，并返回与该代码单元向对应的字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"abcde"</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>)) <span class="comment">// c</span></span><br></pre></td></tr></table></figure>
JS 字符串使用两种Unicode 编码的混合策略： USC-2和UTF-16 ,对于可以用16位编码的字符，这两种编码实际上是相同的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"abcde"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Unicode "Latin small letter C" is U+0063 </span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));  <span class="comment">// 99</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Decimal 99 === Hexadecimal 63 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99</span> === <span class="number">0x63</span>);            <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
fromCharCode() 方法用于根据其UTF-16代码单元形式在字符串中创建字符。此方法接受任意数量的数字，并返回连接到字符串中的等效字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode "Latin small letter A" is U+0061 </span></span><br><span class="line"><span class="comment">// Unicode "Latin small letter B" is U+0062 </span></span><br><span class="line"><span class="comment">// Unicode "Latin small letter C" is U+0063 </span></span><br><span class="line"><span class="comment">// Unicode "Latin small letter D" is U+0064 </span></span><br><span class="line"><span class="comment">// Unicode "Latin small letter E" is U+0065</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>));  <span class="comment">// "abcde"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 0x0061 === 97 </span></span><br><span class="line"><span class="comment">// 0x0062 === 98 </span></span><br><span class="line"><span class="comment">// 0x0063 === 99 </span></span><br><span class="line"><span class="comment">// 0x0064 === 100 </span></span><br><span class="line"><span class="comment">// 0x0065 === 101</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>));          <span class="comment">// "abcde"</span></span><br></pre></td></tr></table></figure>
对于u+0000到 u+FFFF范围，length,charAt(), charCodeAt() 和fromCharCode() 的行为俊宇期待的一样，这是因为每个字符都代表16字节表示，并且这些方法都是以16位代码为单位进行操作。只要字符编码大小和代码单位大小之间存在奇偶校验，这些方法就可以按预期运行。<br>191页<h4 id="The-normalize-Method"><a href="#The-normalize-Method" target="_blank" rel="noopener" class="headerlink" title="The normalize() Method"></a>The normalize() Method</h4>193 页<h4 id="String-Manipulation-Methods"><a href="#String-Manipulation-Methods" target="_blank" rel="noopener" class="headerlink" title="String-Manipulation Methods"></a>String-Manipulation Methods</h4>有几种方法可以操纵字符串的值，这些方法中的第一个是concat()， 用于将一或多个字符串拼接起来，并返回连接字符串作为结果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">"world"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// "hello world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
在这个例子中，在stringValue上调用concat() 方法的结果是 hello world。 即stringValue的值保持不变，concat() 方法接受任意数量的参数，也就是说可以通过它拼接任意多个字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello "</span>; </span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(result);       <span class="comment">// "hello world!" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue);  <span class="comment">// "hello</span></span><br></pre></td></tr></table></figure>
这个例子将world 和！ 拼接到了hello 末尾，尽管concat() 是专门用来拼接字符串的方法，但时间中使用的更多还是加号操作符，而且加号操作符在大多数情况下都比使用concat() 方法要简便易行。<br>JS 还提供了三种基于子字符创建新字符串的方法： slice(),substr(),substring() 这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一个或者两个参数，第一个参数指定子字符串的开始位置，第二个参数表示字符串到哪里结束。具体来说slice() 和substring() 的第二个参数指定的是子字符最后一个字符后面的位置。对于substr() 的第二个参数指定的则是返回字符个数。如果没有个这些方法传递第二个参数，则将字符串的长度作为结束位置，与concat()一样，slice()， substr()，substring() 也不会修改字符串本身的值，他们只是返回一个基本类型的字符串值，对原始字符串没有任何影响<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>));        <span class="comment">// "lo world" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>));    <span class="comment">// "lo world" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>));       <span class="comment">// "lo world" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>));     <span class="comment">// "lo w" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>));  <span class="comment">// "lo w" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>));    <span class="comment">// "lo worl"</span></span><br></pre></td></tr></table></figure>
在此实例中，slice(),substr() 和substring() 以相同的方式使用，并且在大多数情况返回相同的值。在只制定一个参数3 的情况下，这三个方法都返回lo world ，因为hello 中的第二个l处于位置3 ，而在制定两个参数3 和7的情况下，slice() 和substring() 返回low (world中的o处于位置7因此结果不包含o) 但substr() 返回lo worl 因为它的第二个参数指定的是要返回的字符个数。<br>当参数为负数的时候，这些方法会有不同的行为，对于slice() 方法会将将传入的负值与字符串的长度相加，substr() 方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。 最后substring() 方法会把所有负值参数都转换为0 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">-3</span>));         <span class="comment">//rld</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">-3</span>));     <span class="comment">// hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">-3</span>));        <span class="comment">// rld</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">-4</span>));      <span class="comment">// lo w</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>, <span class="number">-4</span>));  <span class="comment">// hel</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">-4</span>));   <span class="comment">// ''</span></span><br></pre></td></tr></table></figure>
这个例子清晰的表明了三种方法之间的区别，当时用单个负参数调用slice()和substr() 的时候，他们作用的相同。发生这种情况是因为-3 被转换为7.从而有效的调用了slice(7) 和substr(7)。 另一方面，由于-3 转换为0 ， substring()方法返回整个字符串。<br>当第二个参数为负的时候，这三种方法的行为都会有所不同，slice() 方法将第二个参数转换为7，从而使调用等效于slice(3,7) 因此返回了lo w. 对于substring()方法会把第二个参数转换0, 是调用变成了substring(3,0) 。 而由于这个方法会将较小的数作为开始位置，将较大的数作为结束位置。因此最终相当于调用了substring(0,3) 。substr() 也会将第二个参数转换为0 ，也就意味着返回包含零个字符的字符串，也就是一个空字符串。  <h4 id="String-Inclusion-Methods-字符串位置方法"><a href="#String-Inclusion-Methods-字符串位置方法" target="_blank" rel="noopener" class="headerlink" title="String Inclusion Methods  字符串位置方法"></a>String Inclusion Methods  字符串位置方法</h4>有两种可以从字符串查找子字符串的方法，indexOf() 和lastIndexOf() 。 这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置（如果没有找到该字符串，则返回-1）。两者之间的区别在于indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法从字符串的末尾开始寻找<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">"o"</span>));      <span class="comment">// 4 </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">"o"</span>));  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
在这里 字符串o的首次出现是在位置4，即hello 的o 。 最后一次出现的位置是7，即world中的o。 如果o在这个字符串中仅出现了一次，那么indexOf和lastIndexOf() 返回相同的位置。<br>每个方法都接受一个可选的第二个参数，该参数指示从字符串中开始搜索的位置，这意味着indexOf() 方法将从该位置开始搜索，并且朝着字符串的结尾移动，而忽略起始位置之前的所有内容。而lastIndexOf() 从指定的位置向前搜索，忽略该位置之后的所有字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">"o"</span>,<span class="number">6</span>)) <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">"o"</span>,<span class="number">6</span>)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
在将第二个参数6传递给这两个方法之后，得到了与前面例子相反的结果。这一次由于indexOf()是从位置6 字母w 开始向后搜索，结果在位置7找到了o , 因此它返回7. 而lastIndexOf() 是从位置6开始向前搜索。结果找到了hello 中的o ,因此它返回4 。在使用第二个参数的情况下，可以通过循环调用indexOf() 或者lastIndexOf()来找到所有匹配的字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"Lorem ipsum dolor sit amet, consectetur adipisicing elit"</span>; <span class="keyword">let</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"><span class="keyword">let</span> pos = stringValue.indexOf(<span class="string">"e"</span>);         </span><br><span class="line"><span class="keyword">while</span>(pos &gt; <span class="number">-1</span>) &#123;  </span><br><span class="line">    positions.push(pos);  </span><br><span class="line">    pos = stringValue.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>); &#125;  </span><br><span class="line"><span class="built_in">console</span>.log(positions);  <span class="comment">// "3,24,32,35,52"</span></span><br></pre></td></tr></table></figure>
这个例子通过不断增加indexOf() 方法开始查找的位置，遍历了一个长字符串。在循环之外，首先找了e 在字符串中的初始位置； 而进入循环后，则每次都给indexOf() 传递上一次的位置+1，这样就确保了每次新搜索都从上一次找到的子字符串的后面开始，每次搜索返回的位置一次被保存在数组positions 中、 以便于将来使用。<h4 id="String-Inclusion-Methods"><a href="#String-Inclusion-Methods" target="_blank" rel="noopener" class="headerlink" title="String Inclusion Methods"></a>String Inclusion Methods</h4>ES6 添加了三种其他方法来确定一个字符串是否包含在另一个字符串中：startsWith(),endsWith() 和includes() 。 所有方法都在字符串中搜索给定的子字符串，并返回一个布尔值，用来指示是否包括该字符串。 他们之间的区别在于startsWith() 检查从索引0 开始的匹配项，endWith() 检查从索引（string.length-substring.length） 开始的匹配项，includes()检查整个字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"foobarbaz"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"foo"</span>));  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"bar"</span>));  <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"baz"</span>));    <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"bar"</span>));    <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"bar"</span>));    <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"qux"</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
startWith() 和includes() 方法接受一个可选的第二个参数，该参数指示从字符串中开始搜索的位置，这意味着这些将该位置开始搜索，并朝字符串的结尾移动，而忽略起始位置之前的所有内容。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"foobarbaz"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"foo"</span>));     <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"foo"</span>, <span class="number">1</span>));  <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"bar"</span>));       <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"bar"</span>, <span class="number">4</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
EndWith() 方法接受一个可选的第二个参数，该参数指示应视为字符串结尾的位置，如果没有提供这个值，则默认使用字符串的长度，当提第二个参数的时候，该方法会将字符串视为仅仅包含这些字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"foobarbaz"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"bar"</span>));     <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"bar"</span>, <span class="number">6</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="The-trim-Method"><a href="#The-trim-Method" target="_blank" rel="noopener" class="headerlink" title="The trim() Method"></a>The trim() Method</h4>ECMA在所有字符串上都具有trim() 方法，这个方法会创建一个字符串的副本，删除前置以及后缀的所有空格，然后返回结果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"  hello world  "</span>; </span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.trim(); </span><br><span class="line"><span class="built_in">console</span>.log(stringValue);         <span class="comment">// "  hello world  " </span></span><br><span class="line"><span class="built_in">console</span>.log(trimmedStringValue);  <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>
由于trim()返回的是字符串的副本，所以原始字符串的前置以及后缀空格会保持不变。trimLeft()和trimRight() 方法，分别用于删除字符串开头和末尾的空格。<h4 id="The-repeat-Method"><a href="#The-repeat-Method" target="_blank" rel="noopener" class="headerlink" title="The repeat() Method"></a>The repeat() Method</h4>所有字符串都具有repeat()方法，repeat() 方法接受单个整数参数计算，复制字符串计数时间，并连接所有副本。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"na "</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.repeat(<span class="number">16</span>) + <span class="string">"batman"</span>); <span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure>
<h4 id="The-padStart-and-padEnd-Methods"><a href="#The-padStart-and-padEnd-Methods" target="_blank" rel="noopener" class="headerlink" title="The padStart() and padEnd() Methods"></a>The padStart() and padEnd() Methods</h4>padStart() 和padEnd() 方法将复制一个字符串，如果字符串的长度小于制定的长度，则在字符串的任一侧添加填充以将其扩展到指定长度。第一个参数是所需的长度，第二个参数是添加为填充的可选字符串。如果没有提供，将使用U+0020 空格字符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"foo"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">6</span>));       <span class="comment">// "   foo" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">9</span>, <span class="string">"."</span>));  <span class="comment">// "......foo" </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">6</span>));         <span class="comment">// "foo   " </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">9</span>, <span class="string">"."</span>));    <span class="comment">// "foo......"</span></span><br></pre></td></tr></table></figure>
可选参数不限于单个字符，如果提供了多个字符的字符串，则该方法量使用串联的填充，并将其截断为确切的长度。此外，如果长度小于或等于字符串长度，则该操作实际上是空操作。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"foo"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">8</span>, <span class="string">"bar"</span>));  <span class="comment">// "barbafoo" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">2</span>));         <span class="comment">// "foo" </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">8</span>, <span class="string">"bar"</span>));    <span class="comment">// "foobarba" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">2</span>));           <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<h4 id="String-Iterators-and-Destructuring"><a href="#String-Iterators-and-Destructuring" target="_blank" rel="noopener" class="headerlink" title="String Iterators and Destructuring"></a>String Iterators and Destructuring</h4>189页<h4 id="String-Case-Methods"><a href="#String-Case-Methods" target="_blank" rel="noopener" class="headerlink" title="String Case Methods"></a>String Case Methods</h4>下一组方法涉及大小写转换。四种方法执行大小写转换：toLowerCase(), toLocaleLowerCase(), toUpperCase(), toLocaleUpperCase() . toLocaleLowerCase和toLocaleUpperCase 需要在特定的语言中使用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleUpperCase());  <span class="comment">// "HELLO WORLD" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toUpperCase());        <span class="comment">// "HELLO WORLD" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleLowerCase());  <span class="comment">// "hello world" </span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLowerCase());        <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>
以上代码嗲用了toLocaleUpperCase() 和toUpperCase() 都返回了 HELLO WORLD, 就像调用toLocaleLowerCase() 和toLowerCase() 都返回hello world 一样。 一般来说，在不知道自己的代码将在哪种语言环境下运行的情况下，还是针对地区的方法更稳妥一些。一般来说，在不知道自己的代码将在哪种语言环境下运行的情况下，还是针对地区的方法更稳妥一些。<h4 id="String-Pattern-Matching-Methods-字符串的模式匹配方法"><a href="#String-Pattern-Matching-Methods-字符串的模式匹配方法" target="_blank" rel="noopener" class="headerlink" title="String Pattern-Matching Methods  字符串的模式匹配方法"></a>String Pattern-Matching Methods  字符串的模式匹配方法</h4>字符串类型定义了几个用于在字符串中匹配模式的方法，这些方法中的第一个是match(),在字符串上嗲用这个方法，本质上与调用RegExp的exec() 方法相同。match() 方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;    </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;         <span class="comment">// same as pattern.exec(text) </span></span><br><span class="line"><span class="keyword">let</span> matches = text.match(pattern); </span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// "cat" </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
match() 方法返回了一个数组，如果是调用RegExp对象的exec() 方法并传递本例中的字符串作为参数，那么也会得到与此相同的数组，数组的第一项是与整个模式匹配的字符串，之后的每一项保存着与正则表达式中的捕获数组匹配的字符串。</li>
</ol>
<p>200页</p>
<h4 id="The-localeCompare-Method"><a href="#The-localeCompare-Method" target="_blank" rel="noopener" class="headerlink" title="The localeCompare() Method"></a>The localeCompare() Method</h4><p>202 页</p>
<h4 id="HTML-Methods"><a href="#HTML-Methods" target="_blank" rel="noopener" class="headerlink" title="HTML Methods"></a>HTML Methods</h4><p>203页</p>
<h2 id="Singleton-Built-in-objects-单体内置对象"><a href="#Singleton-Built-in-objects-单体内置对象" target="_blank" rel="noopener" class="headerlink" title="Singleton Built-in objects  单体内置对象"></a>Singleton Built-in objects  单体内置对象</h2><p>203</p>
<h3 id="The-Global-Object"><a href="#The-Global-Object" target="_blank" rel="noopener" class="headerlink" title="The Global Object"></a>The Global Object</h3><p>203</p>
<h4 id="URI-Encoding-Methods"><a href="#URI-Encoding-Methods" target="_blank" rel="noopener" class="headerlink" title="URI-Encoding Methods"></a>URI-Encoding Methods</h4><h4 id="The-eval-Method"><a href="#The-eval-Method" target="_blank" rel="noopener" class="headerlink" title="The eval() Method"></a>The eval() Method</h4><p>205页</p>
<h4 id="Global-Object-Properties"><a href="#Global-Object-Properties" target="_blank" rel="noopener" class="headerlink" title="Global Object Properties"></a>Global Object Properties</h4><p>206页</p>
<h4 id="The-Window-Object"><a href="#The-Window-Object" target="_blank" rel="noopener" class="headerlink" title="The Window Object"></a>The Window Object</h4><p>207页</p>
<h3 id="The-Math-Object"><a href="#The-Math-Object" target="_blank" rel="noopener" class="headerlink" title="The Math Object"></a>The Math Object</h3><p>207页</p>
<h4 id="Math-Object-Properties"><a href="#Math-Object-Properties" target="_blank" rel="noopener" class="headerlink" title="Math Object Properties"></a>Math Object Properties</h4><h4 id="The-min-and-max-Methods"><a href="#The-min-and-max-Methods" target="_blank" rel="noopener" class="headerlink" title="The min() and max() Methods"></a>The min() and max() Methods</h4><h4 id="Rounding-Methods"><a href="#Rounding-Methods" target="_blank" rel="noopener" class="headerlink" title="Rounding Methods"></a>Rounding Methods</h4><h4 id="The-random-Method"><a href="#The-random-Method" target="_blank" rel="noopener" class="headerlink" title="The random() Method"></a>The random() Method</h4><h4 id="Other-Methods"><a href="#Other-Methods" target="_blank" rel="noopener" class="headerlink" title="Other Methods"></a>Other Methods</h4><h2 id="Summary-1"><a href="#Summary-1" target="_blank" rel="noopener" class="headerlink" title="Summary"></a>Summary</h2><h1 id="COLLECTION-REFERENCE-TYPES"><a href="#COLLECTION-REFERENCE-TYPES" target="_blank" rel="noopener" class="headerlink" title="COLLECTION REFERENCE TYPES"></a>COLLECTION REFERENCE TYPES</h1><h2 id="The-object-Type"><a href="#The-object-Type" target="_blank" rel="noopener" class="headerlink" title="The object Type"></a>The object Type</h2><p>到目前为止，大多数的引用类型值都是Object 类型，这是JS中最常用的类型之一，尽管object的实例不具备多少功能，但他们非常适合在应用程序中存储和传输数据<br>创建object实例的方式有两种，第一种是使用new操作符后跟object构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span></span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用对象字面量表示法，对面字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span></span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，左边的花括号 { 表示对象字面量的开始，因为它出现在了表达式上下文中。JS 中的表达式上下文值的是能够返回一个值（表达式）。赋值操作符表示后面是一个 值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个语句上下文中，例如跟在if 语句条件的后面，则表示一个语句块的开始。<br>然后我们定义了name属性，之后就是一个冒号，在后面是这个属性的值。 在对象字面量中，使用逗号来分隔不同的属性，因此”Nicholas” 后面是一个逗号但是在age属性的值29后面不能添加逗号，因为age是这个对象的最后一个属性<br>在使用对象字面量语法的时候，属性名也可以使用字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    <span class="string">"age"</span>: <span class="number">29</span>,  </span><br><span class="line">    <span class="number">5</span>: <span class="literal">true</span> </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子会创建一个对象，包含三个属性，name age 和 5， 但这里的数值属性名会自动转换为字符串。<br>另外，使用对象字面量语法的时候，如果留空其花括号，则可以定义质保函默认属性和方法的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;  <span class="comment">// same as new Object() </span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>虽然可以使用前面介绍的任意一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉，实际上，对象字面量也是向函数传递大量可选参数的首选方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">""</span>;             </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args.name == <span class="string">"string"</span>)&#123;    </span><br><span class="line">        output += <span class="string">"Name: "</span> + args.name + <span class="string">"\n"</span>;  &#125;             </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args.age == <span class="string">"number"</span>) &#123;    </span><br><span class="line">        output += <span class="string">"Age: "</span> + args.age + <span class="string">"\n"</span>;  &#125;             </span><br><span class="line">    alert(output); &#125;           </span><br><span class="line">    displayInfo(&#123;   <span class="attr">name</span>: <span class="string">"Nicholas"</span>,   <span class="attr">age</span>: <span class="number">29</span> &#125;);          </span><br><span class="line">    displayInfo(&#123;  <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，displayInfo() 接受一个名为args 的参数，该参数可能带有一个名为name 或者age 的属性。也可能这两个属性都有或者都没有。在这个函数内部，我们通过typeof 操作符来检测每个属性是否存在，然后在基于相应的属性来构建一条要显示的消息。然后，我们调用了两次这个函数，每次都使用一个对象字面量来制定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。<br>尽管访问对象属性时使用的都是点表示法，这是很多面相对象语言中通用的语法。不过在JS 也可以使用方括号表示法来访问对象的属性。在使用方括号语法的时候，应该将要访问的属性以字符串的形式放在方括号中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person&#123;<span class="string">"name"</span>&#125;) <span class="comment">// NICHOLAS</span></span><br><span class="line">alert(person.name) <span class="comment">// NICHOLAS</span></span><br></pre></td></tr></table></figure>
<p>从功能上看，这两种访问对象属性的方法没有任何区别，但是方括号语法的主要优点是可以通过变量来访问属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">"name"</span></span><br><span class="line">alert&#123;person[propertyName]&#125; <span class="comment">// Nicholas</span></span><br></pre></td></tr></table></figure>
<p>当属性名称包含可能是语法错误，或关键字的字符时候，也可以使用括号表示法<br>person[“first name”] = “Nicholas”<br>由于first name 中包含一个空格，所以不能使用点表示法来访问他，然而，属性名中可以是包含非字母非数字的，这时候就可以方括号来访问他们</p>
<h2 id="The-Array-Type-170"><a href="#The-Array-Type-170" target="_blank" rel="noopener" class="headerlink" title="The Array Type 170"></a>The Array Type 170</h2><p>在Object 类型之外，Array类型恐怕是JS 中最常用的类型了。而且，js中的数组与其他多数语言中的数组有着很大的区别。虽然JS 数组与其他语言中的数组都是数据的有序列表，但是不同的是，JS数组的每一项可以保存任何类型的数据，也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象。数组的大小是可以动态掉秤的，既可以随着数据的添加自动增长以容纳新的数据。</p>
<h3 id="Creating-Arrays-170"><a href="#Creating-Arrays-170" target="_blank" rel="noopener" class="headerlink" title="Creating Arrays 170"></a>Creating Arrays 170</h3><p>创建数组的基本方式有两种，第一种是使用Array构造函数<br>let colors = new Array()<br>如果乳腺知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length 属性的值。 例如，下面的代码将创建length值为20的数组。<br>let colors = new Array(20)<br>也可以像Array 构造函数传递数组中应该包含的项。以下代码创建了一个包含3个字符串值的数组<br>let colors = new Array(“red”,”blue”,”green”)<br>给构造函数传递一个值也可以创建数组，但这个时候问题就复杂一点了，因为如果传递的是数值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// 创建一个包含3项的数组</span></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>) <span class="comment">// 创建一个包含一项，即字符串Greg的数组</span></span><br></pre></td></tr></table></figure>
<p>另外，在使用构造函数的时候也可以省略new操作符，<br>let colors = Array(3) //<br>let names = Array(“Greg”)<br>创建数组的第二种基本方式是使用数组字面量表示法，数组字面量由一堆包含数组项的方括号表示，多个数组项之前以逗号隔开。<br>let colors = [“red”,”blue”,”green”] // 创建一个数组包含3个字符串。<br>let name = [] // 创建一个空数组<br>let values = [1,2,] // 不要这样，这样会创建一个包含2项<br> 在此代码中第一行创建了一个包含3个字符串的数组，第二行使用一对空方括号创建了一个空数组。第三行展示了在数组字面量的最后一项添加逗号的结果： values 回城为一个包含2项且值分别为1和2 的数组。<br> 数组构造函数在ES6中还引入了两个额外的静态方法来创建数组，from()和of() 。 from() 用于将类似数组的构造转换为数组的实例。而of() 用于将参数集合转换为数组实例。<br> Array.from() 的第一个参数是 arrayLike 对象，该对象是可迭代或者具有属性长度和索引元素的任何对象。这种类型可以大量使用。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Strings will be broken up into an array of single characters alert</span></span><br><span class="line"> (<span class="built_in">Array</span>.from(<span class="string">"Matt"</span>));  <span class="comment">// ["M", "a", "t", "t"]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Sets and Maps can be converted into an new array instance using from() </span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="number">1</span>, <span class="number">2</span>)                   </span><br><span class="line">                    .set(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="number">1</span>)                   </span><br><span class="line">                    .add(<span class="number">2</span>)                   </span><br><span class="line">                    .add(<span class="number">3</span>)                   </span><br><span class="line">                    .add(<span class="number">4</span>);</span><br><span class="line">alert(<span class="built_in">Array</span>.from(m));  <span class="comment">// [[1, 2], [3, 4]] </span></span><br><span class="line">alert(<span class="built_in">Array</span>.from(s));  <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"> <span class="comment">// Array.from() performs a shallow copy of an existing array </span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1);</span><br><span class="line">alert(a1);         <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line">alert(a1 === a2);  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Any iterable object can be used </span></span><br><span class="line"><span class="keyword">const</span> iter = &#123;  </span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;    </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;    </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;     </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;    </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">  &#125; &#125;; </span><br><span class="line">alert(<span class="built_in">Array</span>.from(iter));  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// The arguments object can now easily be casted into an array: </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgsArray</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>); &#125; </span><br><span class="line">alert(getArgsArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// from() will happily use a custom object with required properties </span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123;  <span class="number">0</span>: <span class="number">1</span>,  <span class="number">1</span>: <span class="number">2</span>,   <span class="number">2</span>: <span class="number">3</span>,  <span class="number">3</span>: <span class="number">4</span>,  <span class="attr">length</span>: <span class="number">4</span> &#125;; </span><br><span class="line">alert(<span class="built_in">Array</span>.from(arrayLikeObject));  <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><br> Array.from () 还接受第二个可选的map函数参数，这样无需先创建中间数组就可以增加新数组的值，如果使用Array.from() 。 map() 进行了相同操作，变回出现这种情况。第三个可选参数指定map函数内部的this的，覆盖的this值不适用于箭头函数。、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1, x =&gt; x**<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> a3 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x**<span class="keyword">this</span>.exponent&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;); </span><br><span class="line">alert(a2);  <span class="comment">// [1, 4, 9, 16] alert(a3);  // [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>
<p>Array.of 会将参数列表转换为数组，这可以代替异常笨拙的Array.prototype.slice.call(arguments) 将参数对象转换为数组的ES6之前的通用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// [1,2,3,4]</span></span><br><span class="line">alert(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>))<span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-Holes-172-数组空"><a href="#Array-Holes-172-数组空" target="_blank" rel="noopener" class="headerlink" title="Array Holes 172  数组空"></a>Array Holes 172  数组空</h3><p>使用数组字面量初始化数组可以使用顺序逗号来创建空洞。 js 将逗号之间的索引处的值视为一个孔，并且ES6规范了如何处理这些孔。<br>可能会如下创建数组孔</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [,,,,,];  <span class="comment">// Creates an array with 5 items </span></span><br><span class="line">alert(options.length);    <span class="comment">// 5 </span></span><br><span class="line">alert(options);           <span class="comment">// [,,,,,]</span></span><br></pre></td></tr></table></figure>
<p>ES6中引用的方法和迭代器的行为与早期JS 版本中存在的方法不同，ES6的添加将把这些孔普遍视为值为undefined的现有条目。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123;  </span><br><span class="line">    alert(option === <span class="literal">undefined</span>); &#125; </span><br><span class="line">    <span class="comment">// false </span></span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Array</span>.from([,,,]);  <span class="comment">// Array of 3 holes created with ES6's Array.from() </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> a) &#123;  </span><br><span class="line">    alert(val === <span class="literal">undefined</span>); &#125; </span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// true </span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="built_in">Array</span>.of(...[,,,]));  <span class="comment">// [undefined, undefined, undefined]</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> options.entries()) &#123;  </span><br><span class="line">    alert(value); &#125; </span><br><span class="line">    <span class="comment">// 1 </span></span><br><span class="line">    <span class="comment">// undefined </span></span><br><span class="line">    <span class="comment">// undefined </span></span><br><span class="line">    <span class="comment">// undefined </span></span><br><span class="line">    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>相反，ES6之前可用的方法往往会忽略这些漏洞，尽管确切的行为可能在方法之间略有不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// map() will skip the holes entirely </span></span><br><span class="line">alert(options.map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">6</span>));  <span class="comment">// [6, undefined, undefined, undefined, 6]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// join() treats holes as empty strings </span></span><br><span class="line">alert(options.join(<span class="string">'-'</span>));     <span class="comment">// "1----5"</span></span><br></pre></td></tr></table></figure>
<h3 id="Indexing-into-Arrays-174"><a href="#Indexing-into-Arrays-174" target="_blank" rel="noopener" class="headerlink" title="Indexing into Arrays 174"></a>Indexing into Arrays 174</h3><p>要读取和设置数值，请使用方括号并提供响应值的基于0的数字索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// define an array of strings </span></span><br><span class="line">alert(colors[<span class="number">0</span>]);                       <span class="comment">// display the first item </span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">"black"</span>;                    <span class="comment">// change the third item </span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"brown"</span>;                    <span class="comment">// add a fourth item</span></span><br></pre></td></tr></table></figure>
<p>方括号中的索引表示要访问的值，如果索引小于数组中的项数，则返回对应项的值，就像这个例子中的colors[0] 会显示red 一样。设置数组的值也使用相同的语法，但会替换指定位置的值。如果设置某个值的索引超过了数组现有项数，如这个例子中的colors[3]所示，数组就会自动增加到该索引加1的长度。<br>数组中的项数保存在其length属性中，这个属性始终会返回0或者更大的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line"><span class="keyword">let</span> names = [];                         <span class="comment">// creates an empty array           </span></span><br><span class="line">alert(colors.length);  <span class="comment">// 3 </span></span><br><span class="line">alert(names.length);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>数组的length属性很有特点，它不是只读的，因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">colors.length = <span class="number">2</span>; </span><br><span class="line">alert(colors[<span class="number">2</span>]);  <span class="comment">// undefine</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的数组colors 一开始有3个值，将其length属性设置为2 会移除最后一项（位置为2的哪一项），结果在访问colors[2]就会显示undefined了，如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">colors.length = <span class="number">4</span>; </span><br><span class="line">alert(colors[<span class="number">3</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>虽然colors 数组包含3个项，但把它的length属性设置成了4。 这个数组不存在位置3 ，所以访问这个位置的值就得到了特殊值undefined<br>利用length属性也可以方便的在数组末尾添加新项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">colors[colors.length] = <span class="string">"black"</span>;        <span class="comment">// add a color (position 3) </span></span><br><span class="line">colors[colors.length] = <span class="string">"brown"</span>;        <span class="comment">// add another color (position 4)</span></span><br></pre></td></tr></table></figure>
<p>由于数组的最后一项的索引始终是length-1, 因此下一个新项的位置就是length。每当数组末尾添加一项后，其length 属性都会自动更新以反映这一变化。欢聚话说，上面例子第二行中的colors[colors.length] 为位置3 添加了一个值，最后一行的colors[colors.length]则为位置4添加了一个值，当吧一个值放在超出当前数组大小的位置上的时候，数组就会重新计算其长度值，即长度值等于最后一项的索引加1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">"black"</span>;                   <span class="comment">// add a color (position 99) </span></span><br><span class="line">alert(colors.length);                   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，向colors数组的位置99插入一个值，结果数组新长度length就是100（99+1） ，而位置3 到位置98 实际上都是不存在的。</p>
<h3 id="Detecting-Arrays-175"><a href="#Detecting-Arrays-175" target="_blank" rel="noopener" class="headerlink" title="Detecting Arrays 175"></a>Detecting Arrays 175</h3><p>经典的ECMA问题是确定某个对象是不是数组的经典问题。对于一个网页或者一个全局作用域而言，使用instanceof 操作符就能得到满意的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123; </span><br><span class="line">     <span class="comment">// do something on the array &#125;</span></span><br></pre></td></tr></table></figure>
<p>instanceof 的一个问题在于，它假定只有一个全局执行环境，如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数，如果你从一个框架箱另一个框架传入一个数组。那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数<br>为了解决这个问题，JS 提供了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123; </span><br><span class="line">     <span class="comment">// do something on the array &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Iterator-Methods-176-迭代器方法"><a href="#Iterator-Methods-176-迭代器方法" target="_blank" rel="noopener" class="headerlink" title="Iterator Methods 176  迭代器方法"></a>Iterator Methods 176  迭代器方法</h3><p>在ES6中，数组原型上公开了三种新方法，可以检查数组的内容：keys(), values(), 和 entries()。 keys()将返回数组索引的迭代器。values() 将返回数组元素的迭代器， entries() 将返回索引/值对的迭代器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"qux"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Because these methods return iterators, you can funnel their contents </span></span><br><span class="line"><span class="comment">// into array instances using Array.from() </span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="built_in">Array</span>.from(a.keys()); </span><br><span class="line"><span class="keyword">const</span> aValues = <span class="built_in">Array</span>.from(a.values()); </span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="built_in">Array</span>.from(a.entries());</span><br><span class="line"> </span><br><span class="line">alert(aKeys);     <span class="comment">// [0, 1, 2, 3] </span></span><br><span class="line">alert(aValues);   <span class="comment">// ["foo", "bar", "baz", "qux"] </span></span><br><span class="line">alert(aEntries);  <span class="comment">// [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]</span></span><br></pre></td></tr></table></figure>
<p>ES6 结构意味着现在很容易在循环内拆分键值对</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"qux"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.entries()) [ </span><br><span class="line">     alert(idx);  </span><br><span class="line">     alert(element); &#125; </span><br><span class="line">     <span class="comment">// 0 </span></span><br><span class="line">     <span class="comment">// foo </span></span><br><span class="line">     <span class="comment">// 1 </span></span><br><span class="line">     <span class="comment">// bar </span></span><br><span class="line">     <span class="comment">// 2 </span></span><br><span class="line">     <span class="comment">// baz </span></span><br><span class="line">     <span class="comment">// 3 </span></span><br><span class="line">     <span class="comment">// qux</span></span><br></pre></td></tr></table></figure>
<h3 id="Copy-and-Fill-Methods-176"><a href="#Copy-and-Fill-Methods-176" target="_blank" rel="noopener" class="headerlink" title="Copy and Fill Methods 176"></a>Copy and Fill Methods 176</h3><p>ES6 的新增功能是fill() 和copyWithin() 这两种方法。他们分别允许数组内批量填充和复制。两种方法都有类似的函数签名，因为他们允许使用包含的开始索引和包含的结束索引来制定现有数组实例中的范围，使用此方法的数组将永远不会调整大小。<br>fill() 方法允许将相同的值插入到现有数组的全部或者一部分中。制定可选的歧视索引将指示填充从该索引开始，除非提供了终止索引,否则填充将继续到数组的末尾。负索引从数组末尾开始解释，另一的思考方式是，福索引具有添加到他们的数组长度以计算正索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// Fill the entire array with 5 </span></span><br><span class="line">zeroes.fill(<span class="number">5</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [5, 5, 5, 5, 5] </span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);  <span class="comment">// reset</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill all indices &gt;=3 with 6 </span></span><br><span class="line">zeroes.fill(<span class="number">6</span>, <span class="number">3</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 6, 6] </span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);  <span class="comment">// reset</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill all indices &gt;= 1 and &lt; 3 with 7 </span></span><br><span class="line">zeroes.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 7, 7, 0, 0]; </span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);  <span class="comment">// reset</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill all indices &gt;=1 and &lt; 4 with 8 </span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1) </span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4) </span></span><br><span class="line">zeroes.fill(<span class="number">8</span>, <span class="number">-4</span>, <span class="number">-1</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 8, 8, 8, 0];</span></span><br></pre></td></tr></table></figure>
<p>fill() 默默的忽略超出数组边界，长度为0或者倒退的范围。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill with too low indices is noop </span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, <span class="number">-10</span>, <span class="number">-6</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill with too high indices is noop </span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill with reversed indices is noop </span></span><br><span class="line">zeroes.fill(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill with partial index overlap is best effort </span></span><br><span class="line">zeroes.fill(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>) </span><br><span class="line">alert(zeroes);   <span class="comment">// [0, 0, 0, 4, 4]</span></span><br></pre></td></tr></table></figure>
<p>与fill() 不同，copyWithin() 会执行一些数组迭代浅拷贝，并覆盖从提供的索引处开始的现有值，但是他对开始和结束索引使用的相同的约定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,    </span><br><span class="line">reset = <span class="function"><span class="params">()</span> =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; reset();</span><br><span class="line"><span class="comment">// 将从索引0 开始ints 内容复制到索引5开始的值。 </span></span><br><span class="line"><span class="comment">// 在到达数组的末尾的时候停止</span></span><br><span class="line"><span class="comment">// 索引或者目标索引。</span></span><br><span class="line">ints.copyWithin(<span class="number">5</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] </span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将以索引5开始的ints内容复制到，以索引0开始的值</span></span><br><span class="line">ints.copyWithin(<span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9] </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将从索引0开始到索引3结束的内容复制到值</span></span><br><span class="line"><span class="comment">// 从索引4开始</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// JS 引擎将在之前插入执行之范围的完整拷贝</span></span><br><span class="line"><span class="comment">// 所以在复制过程中没有覆盖的危险.</span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]  </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 支持否定索引的行为与该否定索引的fill()相同</span></span><br><span class="line"><span class="comment">// 相对于数组末尾计算索引</span></span><br><span class="line">ints.copyWithin(<span class="number">-4</span>, <span class="number">-7</span>, <span class="number">-3</span>); </span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>CopyWithin () 默默的忽略超出数组边界，长度为0 ，或者倒退的范围。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,    </span><br><span class="line">reset = <span class="function"><span class="params">()</span> =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy with too low indices is noop </span></span><br><span class="line">ints.copyWithin(<span class="number">1</span>, <span class="number">-15</span>, <span class="number">-12</span>); </span><br><span class="line">alert(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line">reset()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy with too high indices is noop </span></span><br><span class="line">ints.copyWithin(<span class="number">1</span>, <span class="number">12</span>, <span class="number">15</span>); </span><br><span class="line">alert(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy with reversed indices is noop </span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line">alert(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line">reset();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy with partial index overlap is best effort </span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>) </span><br><span class="line">alert(ints);   <span class="comment">// [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];</span></span><br></pre></td></tr></table></figure>
<h3 id="Conversion-Methods-179-转换方法"><a href="#Conversion-Methods-179-转换方法" target="_blank" rel="noopener" class="headerlink" title="Conversion Methods 179  转换方法"></a>Conversion Methods 179  转换方法</h3><p>所有的对象都具有toLocaleString(), toString() 和valueOf方法。其中，嗲用数组的toString() 和valueOf() 返回相同的值。结果是一个逗号分隔的字符串，其中包含数组中每个值的等效字符串。也就是说，为了创建这个字符串会嗲用数组每一项的toString()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// creates an array with three strings </span></span><br><span class="line">alert(colors.toString());  <span class="comment">// red,blue,green </span></span><br><span class="line">alert(colors.valueOf());   <span class="comment">// red,blue,green </span></span><br><span class="line">alert(colors);             <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure>
<p>在这里，首先显式的调用了toString() 方法和valueOf() 方法，以便返回数组的字符串表示，每个值的字符串表示拼接在了一起，中间以逗号分隔。最后一行将数值直接传递到alert() 中，因为alert() 需要一个字符串，所以它在后台调用toString() 来获得与直接调用toString() 的时候相同的结果。<br>toLocalString()方法可能最终返回与toString() 和valueOf() 方法相同的值，但也不是如此，当调用数组的toLocaleString()方法的时候，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的每一项的toLocaleString()方法，而不是toString() 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = &#123;  </span><br><span class="line">    toLocaleString() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nikolaos"</span>;  &#125;,    </span><br><span class="line">    toString() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span>;  &#125; &#125;;           </span><br><span class="line"><span class="keyword">let</span> person2 = &#123;  </span><br><span class="line">    toLocaleString() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Grigorios"</span>;  &#125;,    </span><br><span class="line">    toString() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Greg"</span>;  &#125; &#125;;           </span><br><span class="line"><span class="keyword">let</span> people = [person1, person2]; </span><br><span class="line">alert(people);                   <span class="comment">// Nicholas,Greg </span></span><br><span class="line">alert(people.toString());        <span class="comment">// Nicholas,Greg </span></span><br><span class="line">alert(people.toLocaleString());  <span class="comment">// Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure>
<p>此处定义了两个对象 person1 和person2。 而且还分别为每个对象定义了一个toString() 方法和一个toLocaleString(), 这两个方法返回不同值。然后创建一个包含前面定义的两个对象的数组。在将数组传递给alert() 的时候，输出的结果是Nicholas, Greg 。因为调用了数组的每一项的toString() 方法，同样这与下一行显示调用toString()方法得到的结果相同。而当调用数组的toLocaleString() 方法的时候，输出结果是Nikolaos,grigorios。 原因是调用了数组每一项的toLocaleString()方法。<br>数组继承的toLocaleString() , toString() 和valueOf() 方法，在默认情况下都会以逗号分隔字符串的形式返回数组项。而如果使用join(),则可以使用不同的分隔符来构建这个字符串。join()方法只接受一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]; </span><br><span class="line">alert(colors.join(<span class="string">","</span>));    <span class="comment">// red,green,blue </span></span><br><span class="line">alert(colors.join(<span class="string">"||"</span>));   <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure>
<p>在这里，使用join()方法重现了toSting() 方法的输出。在传递逗号的情况下，得到了以逗号分隔的数值组。而在最后一行代码中，我们传递了双竖线符号，结果就得到了字符串red||green||blue。 如果不给join()方法传入任何值，或者传入undefined，则使用逗号作为分隔符、</p>
<h3 id="Stack-Methods-180-栈方法"><a href="#Stack-Methods-180-栈方法" target="_blank" rel="noopener" class="headerlink" title="Stack Methods 180 栈方法"></a>Stack Methods 180 栈方法</h3><p>JS 数组也提供了一种让数组的行为类似于其他数据结构的方法。具体来说，数组可以表现的像栈一样，后者是一种可以限制插入的和删除项的数据结构。栈是一种LIFO （Last-In-First-Out 后进先出）的数据结构，也就是最新的添加的项最早被移除。而栈中项的插入（叫做推入）和删除(称为弹出) 只发生在一个位置 - 栈的顶部。JS 为数组专门提供了push() 和pop() 方法，以便实现类似栈的行为。<br>push()方法 接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度。而pop() 方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                 <span class="comment">// create an array </span></span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);  <span class="comment">// push two items </span></span><br><span class="line">alert(count);                             <span class="comment">// 2         </span></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);  <span class="comment">// push another item on </span></span><br><span class="line">alert(count);                  <span class="comment">// 3           </span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop();  <span class="comment">// get the last item </span></span><br><span class="line">alert(item);              <span class="comment">// "black" </span></span><br><span class="line">alert(colors.length);     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，创建了一个数组以用作栈。首先使用push()将两个字符串推入数组的末尾，并将返回的结果保存在变量count中，然后在推入一个值，而结果仍然保存在count 中。 因为此时数组中包含3项，所以push() 返回3。 在调用pop() 的时候，它会返回数组的最后一项，即字符串black。 此后，数组中仅剩两项。<br>可以将栈方法与其他数组方法连用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>]; </span><br><span class="line">colors.push(<span class="string">"brown"</span>);          <span class="comment">// add another item </span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;           <span class="comment">// add an item </span></span><br><span class="line">alert(colors.length);          <span class="comment">// 4           </span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop();       <span class="comment">// get the last item </span></span><br><span class="line">alert(item);                   <span class="comment">// "black"</span></span><br></pre></td></tr></table></figure>
<p>在此，首先用两个值来初始化一个数组，然后使用push() 添加第三个值，在通过直接在位置3 上赋值来添加第四个值，而在调用pop()的时候，该方法返回了字符串black ，即最后一个添加到数组的值。</p>
<h3 id="Queue-Methods-181-队列方法"><a href="#Queue-Methods-181-队列方法" target="_blank" rel="noopener" class="headerlink" title="Queue Methods 181 队列方法"></a>Queue Methods 181 队列方法</h3><p>栈数据结构的访问规则是LIFO 后进先出， 而队列数据结构的访问规则是FIFO 先进先出。队列在列表的末端添加项，从列表的前端移除项。由于push() 是向数组末端添加项的方法，因此要模拟队列只需从一个数组前端取得项的方法。实现这一操作的数组方法就是shift(),它能够移除数组中的第一项并返回该项。它能够移除数组中的第一项并返回该项，同时数组长度减少1.结合使用shift()和push() 方法，可以像用队列一样使用数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                 <span class="comment">// create an array </span></span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);  <span class="comment">// push two items </span></span><br><span class="line">alert(count);                             <span class="comment">// 2         </span></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);  <span class="comment">// push another item on </span></span><br><span class="line">alert(count);                  <span class="comment">// 3           </span></span><br><span class="line"><span class="keyword">let</span> item = colors.shift();  <span class="comment">// get the first item </span></span><br><span class="line">alert(item);                <span class="comment">// "red" </span></span><br><span class="line">alert(colors.length);       <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这个例子首先使用push() 方法创建了一个包含三种颜色名称的数组。代码中加粗的那一行使用shift()方法从数组中取得了第一项，即red。在移除第一项之后，green就变成了第一项，而black则变成了第二项，数组也就值包含两项了。<br>JS 还未数组提供了一个unshift() 方法，顾名思义，unshift()与shift() 的用途相反，它能在数组最前端添加任意个项并返回新数组的长度。因此同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                    <span class="comment">// create an array </span></span><br><span class="line"><span class="keyword">let</span> count = colors.unshift(<span class="string">"red"</span>, <span class="string">"green"</span>);  <span class="comment">// push two items</span></span><br><span class="line">alert(count);                                <span class="comment">// 2      </span></span><br><span class="line">count = colors.unshift(<span class="string">"black"</span>);  <span class="comment">// push another item on </span></span><br><span class="line">alert(count);                     <span class="comment">// 3           </span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop();  <span class="comment">// get the first item </span></span><br><span class="line">alert(item);              <span class="comment">// "green" </span></span><br><span class="line">alert(colors.length);     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这个例子，创建了一个数组并使用unshift()方法先后推入了3个值，首先是red 和green 然后是black。 数组中各项的顺序为black,red,green。 在调用pop()方法的时候，移除并返回的是最后一项，即green</p>
<h3 id="Reordering-Methods-重排序方法"><a href="#Reordering-Methods-重排序方法" target="_blank" rel="noopener" class="headerlink" title="Reordering Methods 重排序方法"></a>Reordering Methods 重排序方法</h3><p>有两种方法直接处理数组中已有项目的重新排序： reverse()和sort() 。正如期望的那样，reverse()方法会反转数组项的顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line">values.reverse(); </span><br><span class="line">alert(values);  <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure>
<p>这里数组的初始值以及顺序是12345， 而调用数组的reverse()方法后，其值的顺序变成了54321。这个方法的作用相当至关明了，但是不够灵活，因此才有sort()方法<br>默认情况下，sort()方法将项目按升序排列数组想，即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString() 转型方法，然后比较得到的字符串，以确定如何排序。 即使数组中的每一项都是数组，sort()方法比较的也是字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(); </span><br><span class="line">alert(values);  <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>即使本案例中的值顺序没有问题。但sort()方法也会根据测试字符串的结果改变原来的顺序，虽然数值5小于10 ，但是在进行字符串比较的时候，字符串10 会位于5之前。于是数组的顺序就被修改了，不用说这种排序方式在很多情况下都不是最佳方法。因此sort()方法可以接受一个比较函数作为参数，以便我们制定哪个值位于哪个值的前面。<br>比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0。 如果第一个参数应该位于第二个之后，则返回一个整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>此比较函数使用与大多数据类型，可以将其作为参数传递给sort()方法来使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(compare); </span><br><span class="line">alert(values);  <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>当比较函数传递给sort()方法时候，数字将保持正确的顺序，当然如果也可以通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;    <span class="keyword">return</span> <span class="number">1</span>;  &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;    <span class="keyword">return</span> <span class="number">-1</span>;  &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="keyword">return</span> <span class="number">0</span>;  &#125; &#125;           </span><br><span class="line">    <span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">    values.sort(compare); </span><br><span class="line">    alert(values);  <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure>
<p>或者，可以缩短比较功能将其定义为嵌入式箭头函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a &lt; b ? a &gt; b ? <span class="number">-1</span> : <span class="number">0</span>); </span><br><span class="line">alert(values);  <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure>
<p>在此修改的实例中，如果第一个值应该在第二个值之后，则比较函数返回1，如果第一个值应该在第二个值之前，则比较函数返回-1。交换这些意味着较大的值首先出现，并且数组将按降序排序，当然如果指向反转数组中项目的顺序，则reverse() 比排序要快的多。<br>比较函数的简单版本可以用于数值类型和其valueOf()方法返回数值的对象（例如Date对象）无论哪种情况，都可以从第一个值中减去第二个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;  <span class="keyword">return</span> value2 - value1; &#125;</span><br></pre></td></tr></table></figure>
<p>因为比较函数通过返回小于0,0或大于0的数字来工作，所以减法运算符将适当处理所有情况。</p>
<h3 id="Manipulation-Methods-184-操作方法"><a href="#Manipulation-Methods-184-操作方法" target="_blank" rel="noopener" class="headerlink" title="Manipulation Methods 184 操作方法"></a>Manipulation Methods 184 操作方法</h3><p>JS 为操作已经包含在数组中的项提供了很多方法。 其中concat()方法可以基于当前数组中的所有项创建一个新数组。这个方法首先创建数组的副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，他只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单的添加到结果数组的末尾。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);           </span><br><span class="line">alert(colors);   <span class="comment">// ["red", "green","blue"]    </span></span><br><span class="line">alert(colors2);  <span class="comment">// ["red", "green", "blue", "yellow", "black", "brown"]</span></span><br></pre></td></tr></table></figure>
<p>以上代码开始定义了一个包含3个值的数组colors，然后基于colors调用了concat()方法，并传入字符串yellow 和一个包含black 和brown的数组。最终结果数组color2 中包含了red”, “green”, “blue”, “yellow”, “black”, “brown” 至于原来的数组colors 其中的值仍然保持不变。<br>可以通过在参数实例symbol.isConcatSpread 上制定特殊符号来覆盖强制平化默认行为。这将放置concat()方法使结果扁平，相反的将值设置为true 将迫使将类似数组的对象展平</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]; </span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">"black"</span>, <span class="string">"brown"</span>]; </span><br><span class="line"><span class="keyword">let</span> moreNewColors = &#123;  </span><br><span class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,  </span><br><span class="line">    length: <span class="number">2</span>,  </span><br><span class="line">    <span class="number">0</span>: <span class="string">"pink"</span>,  </span><br><span class="line">    <span class="number">1</span>: <span class="string">"cyan"</span> &#125;;</span><br><span class="line">newColors[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Force the array to not be flattened </span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">"yellow"</span>, newColors);</span><br><span class="line"><span class="comment">// 强制不展平数组</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Force the array-like object to be flattened </span></span><br><span class="line"><span class="comment">// 强制将类似数组的对象展平</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colors.concat(moreNewColors);           alert(colors);   <span class="comment">// ["red", "green","blue"]    </span></span><br><span class="line">alert(colors2);  <span class="comment">// ["red", "green", "blue", "yellow", ["black", "brown"]] </span></span><br><span class="line">alert(colors3);  <span class="comment">// ["red", "green", "blue", "pink, "cyan"</span></span><br></pre></td></tr></table></figure>
<p>下一个方法是slice()，它能够基于当前数组中的一或多个项创建一个新的数组。slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数制定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。主义slice()方法不会影响原有数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.slice(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> colors3 = colors.slice(<span class="number">1</span>, <span class="number">4</span>);           </span><br><span class="line">alert(colors2);  <span class="comment">// green,blue,yellow,purple </span></span><br><span class="line">alert(colors3);  <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，开始定义的数组colors 包含5项,调用slice()并且传入1会得到一个包含4项的新数组，因为是从位置1 开始复制，所以会包含green 而不会包含red。这个新数组colors2 中包含的是green,blue,yellow 和purple。 接着我们再次调用slice() 并且传入了1和4表示复制从位置1 开始到位置3 结束。结果数组colors3中包含了green,blue 和yellow。<br>接下来介绍splice() 方法，这个方法恐怕要算是最强大的数组方法了，他有很多种用法，splice() 的主要用途是向数组的中部插入项，但使用这种方法的方法则有如下三种。</p>
<ul>
<li>删除： 可以删除任意数量的项，只需要制定两个参数： 要删除的第一项的位置，和要删除的项数 例如 splice(0,2) 会删除数组中的前两项。</li>
<li>插入：可以向制定位置插入任意数量的项，只需要提供3个参数：起始位置，0（要删除的项数），和要插入的项。如果要插入多个项，可以在传入，第四，第五，以致任意多个项。例如，splice(2,0,”red”,”green”) 会从数组的位置2，删除0个项，然后插入red和green</li>
<li>替换：可以向制定位置插入任意数量的项，同时删除任意数量的项，只需要制定3个参数：起始位置，要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如splice(2,1,”red”,”green”) 会删除当前数组位置2 的项，然后在从位置2开始插入red,和green。<br>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]; </span><br><span class="line"><span class="keyword">let</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">// remove the first item </span></span><br><span class="line">alert(colors);                     <span class="comment">// green,blue </span></span><br><span class="line">alert(removed);                    <span class="comment">// red - one item array           </span></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>);  <span class="comment">// insert two items at position 1 </span></span><br><span class="line">alert(colors);                                      <span class="comment">// green,yellow,orange,blue </span></span><br><span class="line">alert(removed);                                     <span class="comment">// empty array           </span></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>);  <span class="comment">// insert two values, remove one </span></span><br><span class="line">alert(colors);                                   <span class="comment">// green,red,purple,orange,blue </span></span><br><span class="line">alert(removed);                                  <span class="comment">// yellow - one item array</span></span><br></pre></td></tr></table></figure>
上面的例子首先定义了一个包含3项的数组colors。第一次调用splice()方法只是删除了这个数组的第一项。之后colors还包含了green和blue两项。第二次调用splice()方法的时候在位置1 插入了两项。结果colors中包含green，yellow,orange,blue。 这一次操作没有删除项，因此返回了一个空数组。最后一次调用spice()方法删除了位置1处的一项，然后又插入了red和purple。在完成以上操作之后，数组colors中包含的是green,red,purple,orange和blue<h3 id="Search-and-Location-Methods-186-搜索和定位方法、"><a href="#Search-and-Location-Methods-186-搜索和定位方法、" target="_blank" rel="noopener" class="headerlink" title="Search and Location Methods 186 搜索和定位方法、"></a>Search and Location Methods 186 搜索和定位方法、</h3>提供了两种在数组实例内部进行搜索的策略，通过严格对等进行搜索，以及使用谓词函数进行搜索。<h4 id="Strict-Equivalence-186-严格对等"><a href="#Strict-Equivalence-186-严格对等" target="_blank" rel="noopener" class="headerlink" title="Strict Equivalence 186 严格对等"></a>Strict Equivalence 186 严格对等</h4>三种严格的对等查找方法是indexOf() 和lastIndexOf()以及include()。这些方法中的每一个都接受两个参数，要查找的项目和开始查找的可选索引选项。indexOf() 和include()方法从数组的开头（项目0）开始搜索，然后向后搜索，而lastIndexOf()从数组的最后一项开始向前查找。<br>indexOf()和lastIndexOf() 分别返回该项目在数组中的位置;如果该项目不再数组中，则返回-1. include()返回一个布尔值，该布尔值指示搜索数组中的至少一个元素是否与提供的元素匹配。将第一个参数与数组中的每个项目进行比较的时候，将使用同一性进行比较这意味着必须严格相等，就好像是用===进行比较一样。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];           alert(numbers.indexOf(<span class="number">4</span>));      <span class="comment">// 3 </span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>));  <span class="comment">// 5 </span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>));     <span class="comment">// true </span></span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>, <span class="number">4</span>));      <span class="comment">// 5 </span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>, <span class="number">4</span>));  <span class="comment">// 3 </span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>, <span class="number">7</span>));     <span class="comment">// false           </span></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;]; </span><br><span class="line"><span class="keyword">let</span> morePeople = [person];           </span><br><span class="line">alert(people.indexOf(person));      <span class="comment">// -1 </span></span><br><span class="line">alert(morePeople.indexOf(person));  <span class="comment">// 0 </span></span><br><span class="line">alert(people.includes(person));     <span class="comment">// false </span></span><br><span class="line">alert(morePeople.includes(person)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="Predicate-Search-187-谓词搜索"><a href="#Predicate-Search-187-谓词搜索" target="_blank" rel="noopener" class="headerlink" title="Predicate Search 187 谓词搜索"></a>Predicate Search 187 谓词搜索</h4>JS 还允许您定义一个谓词函数，这个会在每个索引调用。函数的返回值确定该索引处的元素是否被视为匹配项。谓词函数采用predicate(element,index,array)形式，其中element是要检查的数组中的当前元素，index是数组内的元素的索引，而array是数组实例。真实的返回值表示匹配。使用此方法的两个方法是find()和findIndex()。两者都开始在数组中的最低索引处搜索。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [  </span><br><span class="line">    &#123;    <span class="attr">name</span>: <span class="string">"Matt"</span>,    <span class="attr">age</span>: <span class="number">27</span>  &#125;,  </span><br><span class="line">    &#123;    <span class="attr">name</span>: <span class="string">"Nicholas"</span>,    <span class="attr">age</span>: <span class="number">29</span>  &#125; ];</span><br><span class="line"> </span><br><span class="line">alert(people.find(<span class="function">(<span class="params">element, index, array</span>)=&gt;</span>element.age &lt; <span class="number">28</span>)); <span class="comment">// &#123;name: "Matt", age: 27&#125;</span></span><br><span class="line"> </span><br><span class="line">alert(people.findIndex(<span class="function">(<span class="params">element, index, array</span>)=&gt;</span>element.age &lt; <span class="number">28</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
找到匹配项之后都不会在搜索。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evens = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// Last element of array will never be inspected after match is found 找到匹配项后，将永远不会检查数组的最后一个元素</span></span><br><span class="line">evens.find(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123;  </span><br><span class="line">alert(element);  </span><br><span class="line">alert(index);  </span><br><span class="line">alert(array); </span><br><span class="line"><span class="keyword">return</span> element === <span class="number">4</span>; &#125;);</span><br><span class="line"><span class="comment">// 2 // 0 // [2, 4, 6] // 4 // 1 // [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<h3 id="Iterative-Methods-188-迭代方法"><a href="#Iterative-Methods-188-迭代方法" target="_blank" rel="noopener" class="headerlink" title="Iterative Methods 188 迭代方法"></a>Iterative Methods 188 迭代方法</h3>为数组定义了5个迭代方法。每个方法都接受两个参数：要在每一项上运行的函数和可选的运行该函数作用域对象-影响this的值。传入这些方法中的函数都会接受三个参数：数组项的值，该项在数组中的位置，和数组对象本身，根据使用的犯法不同，这个函数执行后的返回值也可能不会影响方法的返回值。</li>
<li>every() 对数组中的每一项运行给 定函数，如果该函数对每一项都返回true，则返回true</li>
<li>filter() 对数组中的每一项运行给 定函数，返回该函数会返回true的项组成的数组。</li>
<li>forEach() 对数组中的每一项运行给 定函数。这个方法没有返回值</li>
<li>map() 对数组中的每一项运行给 定函数，返回每次函数调用结果组成的数组。</li>
<li>some() 对数组中的每一项运行给 定函数，如果该函数对任一项返回true， 则返回true。<br>以上方法都不会修改数组中的包含的值。<br>对这些方法中，最相似的是every() 和some(), 他们都用于查询数组中的项是否满足某个条件。对于every() 来说，传入的函数必须对每一项都返回true，这个方法才返回true. 否则他就返回false。而some()方法则只是要传入的函数对数组中的某一项返回true, 就会返回true。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];           <span class="keyword">let</span> everyResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>); </span><br><span class="line">alert(everyResult);  <span class="comment">// false           </span></span><br><span class="line"><span class="keyword">let</span> someResult = numbers.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);          </span><br><span class="line"> alert(someResult);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
以上代码调用了every() 和some() ，传入的函数只要给定向大于2，，就会返回true，对于every()，他返回的是false，因为只有部分数组符合条件。对于some() ,结果就是true，因为至少有意向是大于2的。<br>下一个方法是filter()，他利用制定的函数确定是否在返回的数组中包含某一项。例如，要返回一个所有数值都大于2的数组。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];           <span class="keyword">let</span> filterResult = numbers.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);           </span><br><span class="line">alert(filterResult);   <span class="comment">// [3,4,5,4,3]</span></span><br></pre></td></tr></table></figure>
这里，通过调用filter 方法创建并返回了包含3，4，,5,4,3的数组，因为传入的函数对他们每一项都返回true。 这个方法对查询符合某些条件的所有数组都非常有用。<br>map()也返回一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果，例如，可以给数组中的每一项乘以2，，然后返回这些乘积组成的数组。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];           <span class="keyword">let</span> mapResult = numbers.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);           </span><br><span class="line">alert(mapResult);   <span class="comment">// [2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure>
本实例中的代码返回一个数组，其中包含给每个数乘以2的结果。这个方法适合创建包含的项与另一个数组一一对应的值。<br>最后一个方法是forEach() ，他只是对数组中的每一项运行传入的函数，这个方法没有返回值，本质上与使用for循环迭代数组一样<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];           numbers.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;   <span class="comment">// do something here &#125;);</span></span><br></pre></td></tr></table></figure>
所有这些数组方法都通过执行许多不同的操作来简化数组的处理。<h3 id="Reduction-Methods-189-归并方法"><a href="#Reduction-Methods-189-归并方法" target="_blank" rel="noopener" class="headerlink" title="Reduction Methods 189 归并方法"></a>Reduction Methods 189 归并方法</h3>JS 还未数组提供了两种缩减的方法： reduce() 和reduceRight()。 这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。<br>这两个方法都接受两个参数：一个在每一项上调用的函数和（可选的）作为并归基础的初始值。传给reduce() 和reduceRight() 的函数接受4个参数：前一个值，当前值，项的索引，和数组对象。这个函数返回的任何值都会作为第一个参数自动传递给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。<br>使用reduce() 方法可以执行求数组所有值之和的操作<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> sum = values.reduce(<span class="function">(<span class="params">prev,cur,index,array</span>) =&gt;</span> prev + cur);</span><br><span class="line">alert(sum) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
第一次执行回调函数，prev 是1，cur 是2  。第二次，prev是3 (1+2的结果), cur是3(数组的第三项)。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。<br>reduceRight() 的作用类似，只不过方向相反而已。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> prev + cur; &#125;); </span><br><span class="line">alert(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
在这个例子中，第一次执行回调函数，prev是5，cur是4。当然最终结果相同，因为执行的都是简单相加的操作。<br>使用reduce()和reduceRight(),主要取决于要从那头开始遍历数组，除此之外，他们完全相同。<h2 id="Typed-Arrays-190"><a href="#Typed-Arrays-190" target="_blank" rel="noopener" class="headerlink" title="Typed Arrays 190"></a>Typed Arrays 190</h2>ES6中新增的功能，类型数组是一种用于将二进制数据传递到本地库的结构。JS 中没有实际的TypedArray类型，而是值包含数字类型的专用数组的集合，要了解如何类型化数组，先了解其预期用途很有帮助<h3 id="History-190"><a href="#History-190" target="_blank" rel="noopener" class="headerlink" title="History 190"></a>History 190</h3></li>
</ul>
<h4 id="WebGL-190"><a href="#WebGL-190" target="_blank" rel="noopener" class="headerlink" title="WebGL 190"></a>WebGL 190</h4><h4 id="Emergence-of-Typed-Arrays-191"><a href="#Emergence-of-Typed-Arrays-191" target="_blank" rel="noopener" class="headerlink" title="Emergence of Typed Arrays 191"></a>Emergence of Typed Arrays 191</h4><h3 id="Using-ArrayBuffers-191"><a href="#Using-ArrayBuffers-191" target="_blank" rel="noopener" class="headerlink" title="Using ArrayBuffers 191"></a>Using ArrayBuffers 191</h3><h3 id="DataViews-192"><a href="#DataViews-192" target="_blank" rel="noopener" class="headerlink" title="DataViews 192"></a>DataViews 192</h3><h4 id="ElementType-193"><a href="#ElementType-193" target="_blank" rel="noopener" class="headerlink" title="ElementType 193"></a>ElementType 193</h4><h4 id="Big-Endian-and-Little-Endian-194"><a href="#Big-Endian-and-Little-Endian-194" target="_blank" rel="noopener" class="headerlink" title="Big-Endian and Little-Endian 194"></a>Big-Endian and Little-Endian 194</h4><h4 id="Corner-Cases-195"><a href="#Corner-Cases-195" target="_blank" rel="noopener" class="headerlink" title="Corner Cases 195"></a>Corner Cases 195</h4><h3 id="Typed-Arrays-196"><a href="#Typed-Arrays-196" target="_blank" rel="noopener" class="headerlink" title="Typed Arrays 196"></a>Typed Arrays 196</h3><h4 id="Typed-Array-Behavior-197"><a href="#Typed-Array-Behavior-197" target="_blank" rel="noopener" class="headerlink" title="Typed Array Behavior 197"></a>Typed Array Behavior 197</h4><h4 id="Merging-Copying-and-Changing-Typed-Arrays-198"><a href="#Merging-Copying-and-Changing-Typed-Arrays-198" target="_blank" rel="noopener" class="headerlink" title="Merging, Copying, and Changing Typed Arrays 198"></a>Merging, Copying, and Changing Typed Arrays 198</h4><h4 id="Underflow-and-Overflow-200"><a href="#Underflow-and-Overflow-200" target="_blank" rel="noopener" class="headerlink" title="Underflow and Overflow 200"></a>Underflow and Overflow 200</h4><h2 id="The-Map-Type-201"><a href="#The-Map-Type-201" target="_blank" rel="noopener" class="headerlink" title="The Map Type 201"></a>The Map Type 201</h2><p>ES6规范之前，可以通过使用object 来有效的轻松地在JS 中实现键值对的储存,但是这种方法有缺陷，ES6中新添加了Map,它是一种新的集合类型，它将真正的键/值行为引入了该语言。它提供的功能与object类型提供的功能有很多重叠，但是在选择使用的时候，应当考虑到object和Map的细微差别。</p>
<h3 id="Basic-API-201-Order-and-Iteration-203"><a href="#Basic-API-201-Order-and-Iteration-203" target="_blank" rel="noopener" class="headerlink" title="Basic API 201 Order and Iteration 203"></a>Basic API 201 Order and Iteration 203</h3><p>空的Map用New关键字来实例化<br>const m = new Map();<br>如果希望在初始化Map的时候填充它，则构造函数可以选择接受一个可迭代的对象，期望它包含键值对数组，可迭代参数中的每队将以其迭代顺序插入新创建的Map中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize map with nested arrays </span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([  [<span class="string">"key1"</span>, <span class="string">"val1"</span>],  [<span class="string">"key2"</span>, <span class="string">"val2"</span>],  [<span class="string">"key3"</span>, <span class="string">"val3"</span>] ]); </span><br><span class="line">alert(m1.size);  <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Initialize map with custom-defined iterator </span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;    <span class="keyword">yield</span> [<span class="string">"key1"</span>, <span class="string">"val1"</span>];    <span class="keyword">yield</span> [<span class="string">"key2"</span>, <span class="string">"val2"</span>];    <span class="keyword">yield</span> [<span class="string">"key3"</span>, <span class="string">"val3"</span>];  &#125; &#125;); </span><br><span class="line">alert(m2.size);  <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Map expects values to be key/value whether they are provided or not </span></span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>([[]]); </span><br><span class="line">alert(m3.has(<span class="literal">undefined</span>));  <span class="comment">// true</span></span><br><span class="line">alert(m3.get(<span class="literal">undefined</span>));  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>可以在使用set() 初始化之后添加键值对，使用get()和has()查询，使用size属性计数，并使用delete()和clear()删除键值对。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">alert(m.has(<span class="string">"firstName"</span>));   <span class="comment">// false </span></span><br><span class="line">alert(m.get(<span class="string">"firstName "</span>));  <span class="comment">// undefined </span></span><br><span class="line">alert(m.size);  <span class="comment">// 0</span></span><br><span class="line">m.set(<span class="string">"firstName"</span>, <span class="string">"Matt"</span>) </span><br><span class="line">  .set(<span class="string">"lastName"</span>, <span class="string">"Frisbie"</span>);</span><br><span class="line">alert(m.has(<span class="string">"firstName"</span>));  <span class="comment">// true </span></span><br><span class="line">alert(m.get(<span class="string">"firstName"</span>));  <span class="comment">// Matt</span></span><br><span class="line"> alert(m.size);              <span class="comment">// 2</span></span><br><span class="line">m.delete(<span class="string">"firstName"</span>);  <span class="comment">// deletes only this key/value pair</span></span><br><span class="line">alert(m.has(<span class="string">"firstName"</span>));  <span class="comment">// false </span></span><br><span class="line">alert(m.has(<span class="string">"lastName"</span>));   <span class="comment">// true </span></span><br><span class="line">alert(m.size);              <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">m.clear();  <span class="comment">// destroys all key/value pairs in this Map instance </span></span><br><span class="line"> </span><br><span class="line">alert(m.has(<span class="string">"firstName"</span>));  <span class="comment">// false </span></span><br><span class="line">alert(m.has(<span class="string">"lastName"</span>));   <span class="comment">// false </span></span><br><span class="line">alert(m.size);              <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>set()方法返回Map实例，因此可以将多个set操作连接在一起，包括在初始声明中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">"key1"</span>, <span class="string">"val1"</span>);</span><br><span class="line">m.set(<span class="string">"key2"</span>, <span class="string">"val2"</span>) </span><br><span class="line">.set(<span class="string">"key3"</span>, <span class="string">"val3"</span>);</span><br><span class="line"> </span><br><span class="line">alert(m.size);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>与只能使用数字或字符串作为键的对象不同，地图可以使用任何JS 数据类型作为键，它使用SameValueZero 比较操作，并且与严格的对象等效检查秘钥匹配情况相当，与对象以一样，对值中包含的内容也没有限制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">m.set(functionKey, <span class="string">"functionValue"</span>); </span><br><span class="line">m.set(symbolKey, <span class="string">"symbolValue"</span>); </span><br><span class="line">m.set(objectKey, <span class="string">"objectValue"</span>);</span><br><span class="line"> </span><br><span class="line">alert(m.get(functionKey));  <span class="comment">// functionValue </span></span><br><span class="line">alert(m.get(symbolKey));    <span class="comment">// symbolValue </span></span><br><span class="line">alert(m.get(objectKey));    <span class="comment">// objectValue</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// SameValueZero checks mean separate instances will not collide </span></span><br><span class="line">alert(m.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;));  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>与严格等价一样，当键或者值的内容或属性发生改变的时候，用于键和值的对象和其他集合类型也将保持不变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;,       </span><br><span class="line">    objVal = &#123;&#125;,      </span><br><span class="line">    arrKey = [],      </span><br><span class="line">    arrVal = [];</span><br><span class="line"> </span><br><span class="line">m.set(objKey, objVal);</span><br><span class="line"> m.set(arrKey, arrVal);</span><br><span class="line"> </span><br><span class="line">objKey.foo = <span class="string">"foo"</span>; </span><br><span class="line">objVal.bar = <span class="string">"bar"</span>; </span><br><span class="line">arrKey.push(<span class="string">"foo"</span>); </span><br><span class="line">arrVal.push(<span class="string">"bar"</span>);</span><br><span class="line"> </span><br><span class="line">alert(m.get(objKey));  <span class="comment">// &#123;bar: "bar"&#125; </span></span><br><span class="line">alert(m.get(arrKey));  <span class="comment">// ["bar"]</span></span><br></pre></td></tr></table></figure>
<p>使用SameValueZero操作可能会去引入意外冲突</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>/<span class="string">""</span>,  <span class="comment">// NaN      </span></span><br><span class="line">b = <span class="number">0</span>/<span class="string">""</span>,  <span class="comment">// NaN      </span></span><br><span class="line">pz = +<span class="number">0</span>,      </span><br><span class="line">nz = <span class="number">-0</span>;</span><br><span class="line">alert(a === b);    <span class="comment">// false </span></span><br><span class="line">alert(pz === nz);  <span class="comment">// true</span></span><br><span class="line">m.set(a, <span class="string">"foo"</span>); </span><br><span class="line">m.set(pz, <span class="string">"bar"</span>);</span><br><span class="line">alert(m.get(b));   <span class="comment">// foo alert(m.get(nz));  // bar</span></span><br></pre></td></tr></table></figure>
<h3 id="顺序和迭代"><a href="#顺序和迭代" target="_blank" rel="noopener" class="headerlink" title="顺序和迭代"></a>顺序和迭代</h3><p>与object类型的约定大不相同的时候，Map实例保持键值插入的顺序，并允许按照插入顺序执行迭代操作。<br>Map实例可以提供一个Iterator, 该iterator以插入顺序包含[key, value]形式的数组对，可以使用entries() 和Symbol.iterator 属性 来检索词迭代器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([  [<span class="string">"key1"</span>, <span class="string">"val1"</span>],  [<span class="string">"key2"</span>, <span class="string">"val2"</span>],  [<span class="string">"key3"</span>, <span class="string">"val3"</span>] ]);</span><br><span class="line"> </span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]);  <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.entries()) &#123;  alert(pair); &#125; <span class="comment">// [key1,val1] // [key2,val2] // [key3,val3]</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m[<span class="built_in">Symbol</span>.iterator]()) &#123;  alert(pair); &#125; <span class="comment">// [key1,val1] // [key2,val2] // [key3,val3]</span></span><br></pre></td></tr></table></figure>
<p>因为entrys() 是默认的迭代器，所以可以使用spread操作符符将Map简洁的转换为数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([  [<span class="string">"key1"</span>, <span class="string">"val1"</span>],  [<span class="string">"key2"</span>, <span class="string">"val2"</span>],  [<span class="string">"key3"</span>, <span class="string">"val3"</span>] ]);</span><br><span class="line"> </span><br><span class="line">alert([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure>
<p>要是用回调约定而不是迭代自，forEach(callback,opt_thisArg)为每个键/值对调用回调。他可以选择接受第二个参数，该参数将在每次回调调用中覆盖此参数的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([  [<span class="string">"key1"</span>, <span class="string">"val1"</span>],  [<span class="string">"key2"</span>, <span class="string">"val2"</span>],  [<span class="string">"key3"</span>, <span class="string">"val3"</span>] ]);</span><br><span class="line"> </span><br><span class="line">m.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>)); <span class="comment">// key1 -&gt; val1 // key2 -&gt; val2 // key3 -&gt; val3</span></span><br></pre></td></tr></table></figure>
<p>key() 和values()返回一个迭代器，该迭代器按插入顺序包含Map中的所有键或者值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([  [<span class="string">"key1"</span>, <span class="string">"val1"</span>],  [<span class="string">"key2"</span>, <span class="string">"val2"</span>],  [<span class="string">"key3"</span>, <span class="string">"val3"</span>] ]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;  alert(key); &#125; <span class="comment">// key1 // key2 // key3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.values()) &#123;  alert(key); &#125; <span class="comment">// value1 // value2 // value3</span></span><br></pre></td></tr></table></figure>
<p>迭代器内部公开的键和值是可变的，但Map内的引用不能改变，但是这并不限制更干键或者值对象内的属性，这样做不会改变他们相对于Map实例的身份。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([  [<span class="string">"key1"</span>, <span class="string">"val1"</span>] ]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// String primitive as key is unaltered </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;  key = <span class="string">"newKey"</span>;  </span><br><span class="line">alert(key);            <span class="comment">// newKey  </span></span><br><span class="line">alert(m.get(<span class="string">"key1"</span>));  <span class="comment">// val1 &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([  [keyObj, <span class="string">"val1"</span>] ]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Key object property is altered, but the object still refers // to the same value inside the map </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;  </span><br><span class="line">    key.id = <span class="string">"newKey"</span>;  </span><br><span class="line">    alert(key);            <span class="comment">// &#123;id: "newKey"&#125;  </span></span><br><span class="line">    alert(m.get(keyObj));  <span class="comment">// val1 &#125; </span></span><br><span class="line">alert(keyObj);           <span class="comment">// &#123;id: "newKey"&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Choosing-Between-Objects-and-Maps-206"><a href="#Choosing-Between-Objects-and-Maps-206" target="_blank" rel="noopener" class="headerlink" title="Choosing Between Objects and Maps 206"></a>Choosing Between Objects and Maps 206</h3><p>对于大多数web开发而言，在Map或者常规Object之间进行选择仅仅是一个优先事项，而在其他地方则几乎没有影响。但是对于关心内存和性能的开发人员而言，可能感兴趣的对象和映射之间存在显著差异。</p>
<h4 id="Memory-Profile-206"><a href="#Memory-Profile-206" target="_blank" rel="noopener" class="headerlink" title="Memory Profile 206"></a>Memory Profile 206</h4><p>252</p>
<h4 id="Insertion-Performance-206"><a href="#Insertion-Performance-206" target="_blank" rel="noopener" class="headerlink" title="Insertion Performance 206"></a>Insertion Performance 206</h4><h4 id="Lookup-Performance-206"><a href="#Lookup-Performance-206" target="_blank" rel="noopener" class="headerlink" title="Lookup Performance 206"></a>Lookup Performance 206</h4><h4 id="Delete-Performance-206"><a href="#Delete-Performance-206" target="_blank" rel="noopener" class="headerlink" title="Delete Performance 206"></a>Delete Performance 206</h4><h2 id="The-WeakMap-Type-206-弱映射类型"><a href="#The-WeakMap-Type-206-弱映射类型" target="_blank" rel="noopener" class="headerlink" title="The WeakMap Type 206 弱映射类型"></a>The WeakMap Type 206 弱映射类型</h2><p>在ES6中新添加的WeakMap是一种新的集合类型，他讲增强的键值行为引入了该语言，WeakMap类型是Map类型的表情，其API实Map的严格子集，弱名称描述了JS 的垃圾收集器如何处理WeakMap中的键。<br>Basic API 207<br>Weak Keys 208<br>Non-Iterable Keys 209<br>Utility 209<br>Private Variables 209<br>DOM Node Metadata 211 </p>
<h2 id="The-Set-Type-211"><a href="#The-Set-Type-211" target="_blank" rel="noopener" class="headerlink" title="The Set Type 211"></a>The Set Type 211</h2><p>ES6中新增了set.他是一种新的集合类型，他是一种新的集合类型，他讲集合行为引入了语言，由于许多API和行为是共享的，因此Set在许多方面的行为都更像增强的Map。<br>Basic API 211<br>Order and Iteration 213<br>Defining Formal Set Operations 215<br>The WeakSet Type 217<br>Basic API 217<br>Weak Keys 219<br>Non-Iterable Values 219<br>Utility 219<br>Iteration and Spread operators 220<br>Summary </p>
<h1 id="ITERATORS-AND-GENERATORS-迭代器和生成器"><a href="#ITERATORS-AND-GENERATORS-迭代器和生成器" target="_blank" rel="noopener" class="headerlink" title="ITERATORS AND GENERATORS 迭代器和生成器"></a>ITERATORS AND GENERATORS 迭代器和生成器</h1><h2 id="Introduction-to-Iteration"><a href="#Introduction-to-Iteration" target="_blank" rel="noopener" class="headerlink" title="Introduction to Iteration"></a>Introduction to Iteration</h2><p>在JS 中，最简单的迭代示例之一是计数循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;  <span class="built_in">console</span>.log(i); &#125;</span><br></pre></td></tr></table></figure>
<p>循环是一种基本的迭代工具，因为循环使您可以指定应该进行多少迭代，以及在每次迭代中应该进行什么迭代。每个循环迭代将在另一个循环迭代开始之前完成执行，并且每次迭代发生的顺序是明确定义的。<br>迭代可能发在项目中的有序集合上，在这种情况下，考虑排序是只存在一个可接受的序列，其中应遍历所有项，并带有确定的开始和结束项。在JS中，此有序集合最常见的示例是数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; collection.length; ++index) &#123;  <span class="built_in">console</span>.log(collection[index]); &#125;</span><br></pre></td></tr></table></figure>
<p>因为数组的长度已知，并且可以通过其索引检索数组中的每个项目，所以通过增加可能的索引范围来按顺序遍历整个数组。<br>由于以下几个原因，在这种循环中发生的基本过程不理想。</p>
<ul>
<li>遍历数据结构需要有关如何使用数数据结构的特定知识，只能通过首先引用数组对象，然后使用[] 运算符在特定索引出检索项目，才能检索数组中的每个项目，这不会推广到其他数据结构。</li>
<li>遍历的顺序不是数据结构雇佣的，递增整数以访问顺序索引特定于数组类型，并且不能推广到具有隐式排序的其他数据结构。<br>ES5 引入了Array.prototype.forEach方法，该方法更接近于所需的方法，但仍然不是理想的解决方案。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];</span><br><span class="line"> </span><br><span class="line">collection.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item)); <span class="comment">// foo // bar // baz</span></span><br></pre></td></tr></table></figure>
这解决了通过数组对象分别跟踪索引和检索项目的问题，但是，无法终止此迭代，该方法进仅限于数组，并且回调结构繁琐。<h2 id="The-Iterator-Pattern"><a href="#The-Iterator-Pattern" target="_blank" rel="noopener" class="headerlink" title="The Iterator Pattern"></a>The Iterator Pattern</h2>迭代器模式（特别是在JS的环境中）描述了一种解决方案，其中某些事物可以描述为可迭代，并且可以实现正式的iterable接口并由迭代器使用。<br>可迭代的概念是故意抽象的，通常，可迭代对象将采用集合对象的形式。例如数组和集合，两者均具有有限数量的可数元素，并且具有明确的遍历顺序。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arrays have finite countable elements </span></span><br><span class="line"><span class="comment">// In-order traversal visits each index in increasing index order </span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Sets have finite countable elements </span></span><br><span class="line"><span class="comment">// In-order traversal visits each value in insertion order </span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set().add(3).add(1).add(4);</span><br></pre></td></tr></table></figure>
但是，迭代器不必连接到集合对象，它可以连接到仅表现为数组的对象，例如技术循环，在此循环中生成的值是瞬态的，但是这样的循环正在执行迭代，此技术循环和数组都可以表现为可迭代的。<h3 id="The-Iterable-Protocol"><a href="#The-Iterable-Protocol" target="_blank" rel="noopener" class="headerlink" title="The Iterable Protocol"></a>The Iterable Protocol</h3><h3 id="The-Iterator-Protocol"><a href="#The-Iterator-Protocol" target="_blank" rel="noopener" class="headerlink" title="The Iterator Protocol"></a>The Iterator Protocol</h3><h3 id="Custom-Iterator-Definition"><a href="#Custom-Iterator-Definition" target="_blank" rel="noopener" class="headerlink" title="Custom Iterator Definition"></a>Custom Iterator Definition</h3><h3 id="Early-Termination-of-Iterators"><a href="#Early-Termination-of-Iterators" target="_blank" rel="noopener" class="headerlink" title="Early Termination of Iterators"></a>Early Termination of Iterators</h3><h2 id="Generators"><a href="#Generators" target="_blank" rel="noopener" class="headerlink" title="Generators"></a>Generators</h2><h3 id="Generator-Basics"><a href="#Generator-Basics" target="_blank" rel="noopener" class="headerlink" title="Generator Basics"></a>Generator Basics</h3><h3 id="Interrupting-Execution-with-“yield”"><a href="#Interrupting-Execution-with-“yield”" target="_blank" rel="noopener" class="headerlink" title="Interrupting Execution with “yield”"></a>Interrupting Execution with “yield”</h3><h4 id="Using-a-Generator-Object-as-an-Iterable"><a href="#Using-a-Generator-Object-as-an-Iterable" target="_blank" rel="noopener" class="headerlink" title="Using a Generator Object as an Iterable"></a>Using a Generator Object as an Iterable</h4><h4 id="Using-“yield”-for-Input-and-Output"><a href="#Using-“yield”-for-Input-and-Output" target="_blank" rel="noopener" class="headerlink" title="Using “yield” for Input and Output"></a>Using “yield” for Input and Output</h4><h4 id="Yielding-an-Iterable"><a href="#Yielding-an-Iterable" target="_blank" rel="noopener" class="headerlink" title="Yielding an Iterable"></a>Yielding an Iterable</h4><h4 id="Recursive-Algorithms-Using-yield"><a href="#Recursive-Algorithms-Using-yield" target="_blank" rel="noopener" class="headerlink" title="Recursive Algorithms Using yield*"></a>Recursive Algorithms Using yield*</h4><h3 id="Using-a-Generator-as-the-Default-Iterator"><a href="#Using-a-Generator-as-the-Default-Iterator" target="_blank" rel="noopener" class="headerlink" title="Using a Generator as the Default Iterator"></a>Using a Generator as the Default Iterator</h3><h3 id="Early-Termination-of-Generators"><a href="#Early-Termination-of-Generators" target="_blank" rel="noopener" class="headerlink" title="Early Termination of Generators"></a>Early Termination of Generators</h3><h4 id="The-return-Method"><a href="#The-return-Method" target="_blank" rel="noopener" class="headerlink" title="The return() Method"></a>The return() Method</h4><h4 id="The-throw-Method"><a href="#The-throw-Method" target="_blank" rel="noopener" class="headerlink" title="The throw() Method"></a>The throw() Method</h4><h2 id="Summary-2"><a href="#Summary-2" target="_blank" rel="noopener" class="headerlink" title="Summary"></a>Summary</h2><h1 id="Objects-Classes-and-ObjectOriented-Programming"><a href="#Objects-Classes-and-ObjectOriented-Programming" target="_blank" rel="noopener" class="headerlink" title="Objects, Classes, and ObjectOriented Programming"></a>Objects, Classes, and ObjectOriented Programming</h1><h2 id="UNDERSTANDING-OBJECTS"><a href="#UNDERSTANDING-OBJECTS" target="_blank" rel="noopener" class="headerlink" title="UNDERSTANDING OBJECTS"></a>UNDERSTANDING OBJECTS</h2>创建自定义对象的规范是穿件一个Object 的新实例，并向其中添加属性和方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span></span><br><span class="line">person.age = <span class="number">29</span></span><br><span class="line">person.job = <span class="string">"S E"</span></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;</span><br></pre></td></tr></table></figure>
上个例子创建了一个名为person的对象，并为他添加了三个属性(name,age和job)和一个方法sayName()。 其中sayName()方法显示this.name的值，这个值被解析为person.name的值，早期的JS 开发人员经常使用此模式来创建新对象，几年后，对象字面量成为创建这种对象的首选模式，可是使用对象字面量来重写前面的实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span></span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">    job: <span class="string">"SE"</span></span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个实例中person对象等同于先前实例中的person对象，具有所有相同的属性和方法，这些属性在创建的时候都带有一些特征值，JS通过这些特征值来定义他们的行为<h3 id="Types-of-Properties-属性类型"><a href="#Types-of-Properties-属性类型" target="_blank" rel="noopener" class="headerlink" title="Types of Properties 属性类型"></a>Types of Properties 属性类型</h3>只有内部才用的特性，描述了属性的各种特征。这些属性不能再JS中直接访问，要指示属性是内部属性，请用两队方括号将属性名括起来例如[[Enumerable]]<br>属性有两种类型：数据属性和访问器属性<h4 id="Data-Properties"><a href="#Data-Properties" target="_blank" rel="noopener" class="headerlink" title="Data Properties"></a>Data Properties</h4>数据属性包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个描述其行为的特征。</li>
<li>[[Configurable]] 表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特征，或者能否把属性修改为访问器属性。默认情况下，对于直接在对象上定义的所有属性都是true。</li>
<li>[[Enumerable]] 表示能够通过for-in循环返回属性，像前面例子中那样直接在对象上定义的属性，他们这个特性默认值为true</li>
<li>[[Writable]] 表示能够修改属性的值，默认值为true</li>
<li>[[Value]] 包含这个属性的数据值，读取属性值的时候，从这个位置读，写入属性值的时候，把新的值保存在这个位置，这个特性的默认值为undefined。<br>对于像前面例子中那样直接在对象上定义的属性，他们的[[Configurable]],[[Enumerable]]和[[Writable]]特性都被设置是为true，而[[Value]] 特性被设置为指定的值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;;</span><br></pre></td></tr></table></figure>
这里创建了一个名为name 的属性，为它制定的值是”Nicholas”，也就是说，[[Value]] 特性将被设置为”Nicholas”，而对这个值的任何修改都将反应在这个位置。<br>要修改属性默认的特性必须使用Object.defineProperty()方法，这个方法接受三个参数：属性所在的对象，属性的名字和一个描述符对象。其中描述符对象的属性必须是configurable, enumerable, writable, and value。设置其中的一或多个值，可以修改对应的特性值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;  <span class="attr">writable</span>: <span class="literal">false</span>,  <span class="attr">value</span>: <span class="string">"Nicholas"</span> &#125;); </span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// "Nicholas" </span></span><br><span class="line">person.name = <span class="string">"Greg"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
这个例子创建了一个名为name的属性，它的值Nicholas是只读的。这个属性的值是不可修改的，如果尝试为它制定心智，则在非严格模式下，赋值操作将被忽略，在严格模式下，赋值操作将会导致抛出错误。<br>类似的规则也适用于不可配置的属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;  <span class="attr">configurable</span>: <span class="literal">false</span>,  <span class="attr">value</span>: <span class="string">"Nicholas"</span> &#125;); </span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// "Nicholas" </span></span><br><span class="line"><span class="keyword">delete</span> person.name; </span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
把configurable 设置false, 表示不能从对象中删除对象。在非严格模式下什么也不会发生，而在严格模式下会导致错误，而且一旦把属性定义为不可配置的，就不能再把它变回课配置了、此时，在调用Object.definedProperty() 方法修改Writable 之外的特性，都会导致错误：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;  <span class="attr">configurable</span>: <span class="literal">false</span>,  <span class="attr">value</span>: <span class="string">"Nicholas"</span> &#125;);</span><br><span class="line"><span class="comment">// Throws an error </span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;  <span class="attr">configurable</span>: <span class="literal">true</span>,  <span class="attr">value</span>: <span class="string">"Nicholas"</span> &#125;);</span><br></pre></td></tr></table></figure>
也就是说，可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable 特性设置为false 之后就会有限制了。<br>在调用Object.defineProperty() 方法的时候，如果不指定，configurable,enumerable 和writable 特性的默认值都是false。多数情况下，可能都没有必要利用Object.defineProperty()方法提供的这些高级功能，不对理解这些概念对理解JS 对象却非常有用。<h5 id="访问器属性"><a href="#访问器属性" target="_blank" rel="noopener" class="headerlink" title="访问器属性"></a>访问器属性</h5>访问器属性不包含数据值：他们包含一堆getter和setter函数，尽管这两个函数都不是必须的。在读取访问器属性的时候，会调用getter函数，这个函数负责返回有效的值;在写入访问器属性的时候，会调用setter函数，这个函数负责决定如何处理数据</li>
<li>[[Configurable]] 表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性，对于直接在对象上定义的属性，这个特性的默认值为true</li>
<li>[[Enumerable]] 表示能否通过for-in循环返回属性，对于直接在对象上定义的属性，这个特性的默认值为true。</li>
<li>[[Get]] 在读取属性时候调用函数，默认值为undefined</li>
<li>[[Set]] 在写入属性的时候调用函数，默认值为undefined<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define object with pseudo-private member 'year_' </span></span><br><span class="line"><span class="comment">// and public member 'edition' </span></span><br><span class="line"><span class="keyword">let</span> book = &#123;  <span class="attr">year_</span>: <span class="number">2017</span>,  <span class="attr">edition</span>: <span class="number">1</span> &#125;;  <span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;  </span><br><span class="line">    <span class="keyword">get</span>() &#123;    <span class="keyword">return</span> <span class="keyword">this</span>.year_;  &#125;,  </span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;     </span><br><span class="line">             <span class="keyword">this</span>.year_ = newValue;      </span><br><span class="line">             <span class="keyword">this</span>.edition += newValue - <span class="number">2017</span>;    &#125;  &#125; &#125;); </span><br><span class="line">book.year = <span class="number">2018</span>; </span><br><span class="line"><span class="built_in">console</span>.log(book.edition);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
以上代码，创建了一个book对象，并给它定义两个默认的属性：year_ 和edition。 year_上的下划线是一种常见的表示法。用于表示只能通过对象访问的属性。而访问器属性year则包含一个getter函数和一个setter函数。getter函数仅仅返回year_的值，而setter进行一些计算来确定正确的版本，因此，把year属性修改为2018会导致year_和edition都更改为2。 这是使用访问器属性的常见方式，及设置一个属性的值会导致其他属性发生变化。<br>不一定非要同时制定 getter 和 setter 。只指定getter 意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只制定了getter函数的属性会抛出错误。类似的，只制定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。<br>在不支持Object.defineProperty()的浏览器中，无法修改[[Configurable]] 或者[[Enumerable]]<h3 id="定义多个属性"><a href="#定义多个属性" target="_blank" rel="noopener" class="headerlink" title="定义多个属性"></a>定义多个属性</h3>由于为对象定义多个属性的可能性很大，因此由定义了一个Object.defineProperties() 方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接受两个对象参数：第一个对象是要添加和修改器属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;  </span><br><span class="line">    year_: &#123;    </span><br><span class="line">        value: <span class="number">2017</span>  &#125;,    </span><br><span class="line">    edition: &#123;    </span><br><span class="line">        value: <span class="number">1</span>  &#125;,    </span><br><span class="line">    year: &#123;          </span><br><span class="line">        <span class="keyword">get</span>() &#123;      </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.year_;    &#125;,       </span><br><span class="line">        <span class="keyword">set</span>(newValue) &#123;      </span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;        </span><br><span class="line">                <span class="keyword">this</span>.year_ = newValue;        <span class="keyword">this</span>.edition += newValue - <span class="number">2017</span>;      &#125;              &#125;        &#125;    &#125;);</span><br><span class="line">    <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year_"</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(descriptor.value);         <span class="comment">// 2017</span></span><br><span class="line">     <span class="built_in">console</span>.log(descriptor.configurable);  <span class="comment">// false</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get);    <span class="comment">// "undefined" </span></span><br><span class="line">      <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>); </span><br><span class="line">      <span class="built_in">console</span>.log(descriptor.value);         <span class="comment">// undefined </span></span><br><span class="line">      <span class="built_in">console</span>.log(descriptor.enumerable);    <span class="comment">// false </span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get);  <span class="comment">//"function</span></span><br></pre></td></tr></table></figure>
对于数据属性year_ ，其值等于原始值，可配置为false。而get为未定义。对于存储器属性year,值是undefined,enumerable是false，而get是指向制定的getter函数的指针。<br>ESMA 2017中新的功能是Object.getOwnPropertyDescriptors()静态方法，此方法有效的对所有自己的属性执行Object.getOwnPropertyDescriptors() 并将其返回到新对象中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;; <span class="built_in">Object</span>.defineProperties(book, &#123;  <span class="attr">year_</span>: &#123;    <span class="attr">value</span>: <span class="number">2017</span>  &#125;,    <span class="attr">edition</span>: &#123;    <span class="attr">value</span>: <span class="number">1</span>  &#125;,    <span class="attr">year</span>: &#123;          <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;      <span class="keyword">return</span> <span class="keyword">this</span>.year_;    &#125;,        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;        <span class="keyword">this</span>.year_ = newValue;        <span class="keyword">this</span>.edition += newValue - <span class="number">2017</span>;      &#125;              &#125;        &#125;    &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(book)); <span class="comment">// &#123; //   edition: &#123; //     configurable: false, //     enumerable: false, //     value: 1, //     writable: false //   &#125;, //   year: &#123; //     configurable: false, //     enumerable: false, //     get: f(), //     set: f(newValue), //   &#125;, //   year_: &#123; //     configurable: false, //     enumerable: false, //     value: 2019, //     writable: false //   &#125; // &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Merging-Objects-合并对象"><a href="#Merging-Objects-合并对象" target="_blank" rel="noopener" class="headerlink" title="Merging Objects 合并对象"></a>Merging Objects 合并对象</h3>JS 开发人员通常会发现能够执行两个对象的合并很有用。更具体的说此合并将采取将一个源对象的所有本地属性折叠到目标对象中的形式。通常，此行为也称为是使用混合，其中通过混合源对象的属性来增强目标对象。<br>es6 通过Object.assign() 方法引入了这种确切的行为。此方法接受一个目标对象和一个或多个源对象，并且对于每个源对象，将枚举(Object.propertyIsEnumerable 返回true) 和拥有(Object.hasOwnProperty 返回true)属性复制到目标对象。字符串和符号的键属性将被复制。对于每个合适的属性，该方法将使用[[Get]] 从源对象中检索值，并使用目标对象上的[[Set]]来分配值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** * Simple copy */</span> </span><br><span class="line">dest = &#123;&#125;; </span><br><span class="line">src = &#123; <span class="attr">id</span>: <span class="string">'src'</span> &#125;;</span><br><span class="line"> </span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Object.assign mutates the destination object </span></span><br><span class="line"><span class="comment">// and also returns that object after exiting.</span></span><br><span class="line"><span class="built_in">console</span>.log(dest === result);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(dest !== src);     <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(result);           <span class="comment">// &#123; id: src &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(dest);             <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** * Multiple source objects */</span> </span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">a</span>: <span class="string">'foo'</span> &#125;, &#123; <span class="attr">b</span>: <span class="string">'bar'</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// &#123; a: foo, b: bar &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** * Getters and setters */</span> </span><br><span class="line">dest = &#123;  <span class="keyword">set</span> a(val) &#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Invoked dest setter with param $&#123;val&#125;'</span>);  &#125; &#125;; </span><br><span class="line">src = &#123;  <span class="keyword">get</span> a() &#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Invoked src getter'</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;  &#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src); <span class="comment">// Invoked src getter // Invoked dest setter with param foo</span></span><br><span class="line"> <span class="comment">// Since the setter does not perform an assignment, </span></span><br><span class="line"> <span class="comment">// no value is actually transferred </span></span><br><span class="line"> <span class="built_in">console</span>.log(dest);  <span class="comment">// &#123; set a(val) &#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure>
Object.assign() 有效地从每个源对象执行浅拷贝。如果多个源对象定义了形同的属性，则要赋值的最后一个将会是最终值。此外将从源对象上的访问器属性(例如getter)中检索到的任何值都分配为目标对象上的静态值-无法再对象之间传递getter和setter<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** * Overwritten properties */</span> dest = &#123; <span class="attr">id</span>: <span class="string">'dest'</span> &#125;;</span><br><span class="line"> </span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">'src1'</span>, <span class="attr">a</span>: <span class="string">'foo'</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">'src2'</span>, <span class="attr">b</span>: <span class="string">'bar'</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Object.assign will overwrite duplicate properties. console.log(result);  // &#123; id: src2, a: foo, b: bar &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// This can be observed by using a setter on the destination object: dest = &#123;  set id(x) &#123;    console.log(x);  &#125; &#125;;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">'first'</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">'second'</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">'third'</span> &#125;); <span class="comment">// first // second // third</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/** * Object references */</span></span><br><span class="line"> </span><br><span class="line">dest = &#123;&#125;; src = &#123; <span class="attr">a</span>: &#123;&#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Shallow property copies means only object references copied. console.log(dest);              // &#123; a :&#123;&#125; &#125; console.log(dest.a === src.a);  // true</span></span><br></pre></td></tr></table></figure>
如果在分配过程中抛出错误，它将终止并退出并抛出错误，Object.assign()没有回滚早期分配的概念，因此它是一种尽力而为的方法，可能仅部分完成。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  * Error handling */</span> dest = &#123;&#125;; src = &#123;  <span class="attr">a</span>: <span class="string">'foo'</span>,  <span class="keyword">get</span> b() &#123;    <span class="comment">// Error will be thrown when Object.assign()    // invokes this getter.    throw new Error();  &#125;,  c: 'bar' &#125;;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span> &#123;  <span class="built_in">Object</span>.assign(dest, src); &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Object.assign() has no way of rolling back already performed changes, // so set operations already performed on the destination object before // the error is thrown remain: console.log(dest);  // &#123; a: foo &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="对象定义和平等"><a href="#对象定义和平等" target="_blank" rel="noopener" class="headerlink" title="对象定义和平等"></a>对象定义和平等</h3>在ES6之前的版本，有几种棘手的情况，其中===运算符不足、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These are cases where === behaves as expected:</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="literal">true</span> === <span class="number">1</span>);   <span class="comment">// false </span></span><br><span class="line"> <span class="built_in">console</span>.log(&#123;&#125; === &#123;&#125;);    <span class="comment">// false </span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"2"</span> === <span class="number">2</span>);    <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// These have different representations in the JS engine and yet are treated as equal </span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>);    <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">0</span>);     <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> === <span class="number">0</span>);     <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// To determine NaN equivalence, the profoundly annoying isNaN() is required </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
为了解决这个问题，ES6规范引入了Object.is()，它的行为基本上与===相同，但也考虑了前面累出的特殊情况，该方法正好接受两个参数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">true</span>, <span class="number">1</span>));   <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;));    <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">"2"</span>, <span class="number">2</span>));    <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Correct 0, -0, +0 equivalence/nonequivalence:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>));    <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>));     <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">0</span>));     <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Correct NaN equivalence: </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
要检查两个以上的对象，递归使用传递相等性是很简单的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursivelyCheckEqual</span>(<span class="params">x, ...rest</span>) </span>&#123;  <span class="keyword">return</span> <span class="built_in">Object</span>.is(x, rest[<span class="number">0</span>]) &amp;&amp;          (rest.length &lt; <span class="number">2</span> || recursivelyCheckEqual(...rest)); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="增强对象语法"><a href="#增强对象语法" target="_blank" rel="noopener" class="headerlink" title="增强对象语法"></a>增强对象语法</h3>ES6中引入了一些非常有用的语法工具，用于定义对象并与对象进行交互，他们都无法有益的改变现有引擎的行为，但是他们极大的提高了处理对象的便捷性<br>所有对象语法也适用于稍后定义的ES6类<h4 id="Property-Value-Shorthand-属性值简写"><a href="#Property-Value-Shorthand-属性值简写" target="_blank" rel="noopener" class="headerlink" title="Property Value Shorthand 属性值简写"></a>Property Value Shorthand 属性值简写</h4>开发人员发现，将变量添加到对象的时候，用于输入该变量的属性名通常会与变量名称本身匹配。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Matt'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: name &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// &#123; name: 'Matt' &#125;</span></span><br></pre></td></tr></table></figure>
因此，引入了属性值简写作为约定，这是您可以简单的使用不带冒号的变量本身，并且解释器将自动的使用变量名作为属性键。如果找不到变量名，将引发ReferenceError<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Matt'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person = &#123;  name &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// &#123; name: 'Matt' &#125;</span></span><br></pre></td></tr></table></figure>
缩小符将在范围之间保留属性名称，以防止破坏引用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">name</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123;     name  &#125;; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person = makePerson(<span class="string">'Matt'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>
即使参数标识符仅限于函数范围，编译器仍应小心的初始名称字符串标识符保留在函数定义中，函数参数名称将被缩短，但属性名称将保留。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">a</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">        name: a  &#125;; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person = makePerson(<span class="string">"Matt"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>
<h4 id="计算属性键"><a href="#计算属性键" target="_blank" rel="noopener" class="headerlink" title="计算属性键"></a>计算属性键</h4>在引入计算属性键之前，没有办法在不声明对象的情况下在对象常量中动态分配属性键，然后单独使用方括号符号进行属性分配。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">'name'</span>; </span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">'age'</span>; </span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">'job'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line">person[nameKey] = <span class="string">'Matt'</span>; </span><br><span class="line">person[ageKey] = <span class="number">27</span>; </span><br><span class="line">person[jobKey] = <span class="string">'Software engineer'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// &#123; name: 'Matt', age: 27, job: 'Software engineer' &#125;</span></span><br></pre></td></tr></table></figure>
使用计算出的属性，属性分配可以发生在对象字面量的初始定义内，对象属性键周围的方括号指示运行时将其内容评估为JS 表达式而不是字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">'name'</span>; </span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">'age'</span>; </span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">'job'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    [nameKey]: <span class="string">'Matt'</span>,  </span><br><span class="line">    [ageKey]: <span class="number">27</span>,  </span><br><span class="line">    [jobKey]: <span class="string">'Software engineer'</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// &#123; name: 'Matt', age: 27, job: 'Software engineer' &#125;</span></span><br></pre></td></tr></table></figure>
因为内容是作为JS 表达式求职的，所以可以在实例化的时候使要计算的属性复杂表达式的内容求值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">'name'</span>; </span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">'age'</span>; </span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">'job'</span>; </span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueKey</span>(<span class="params">key</span>) </span>&#123;  <span class="keyword">return</span> <span class="string">'$&#123;key&#125;_$&#123;uniqueToken++&#125;'</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person = &#123;  [getUniqueKey(nameKey)]: <span class="string">'Matt'</span>,  [getUniqueKey(ageKey)]: <span class="number">27</span>,  [getUniqueKey(jobKey)]: <span class="string">'Software engineer'</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// &#123; name_0: 'Matt', age_1: 27, job_2: 'Software engineer' &#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="Concise-Method-Syntax-简洁方法语法"><a href="#Concise-Method-Syntax-简洁方法语法" target="_blank" rel="noopener" class="headerlink" title="Concise Method Syntax  简洁方法语法"></a>Concise Method Syntax  简洁方法语法</h5>定义对象的函数属性的时候，格式几乎总是采用引用匿名函数表达式的属性键的形式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'My name is $&#123;name&#125;'</span>);  &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">person.sayName(<span class="string">'Matt'</span>);  <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure>
这也适用于getter和setter对象约定<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    name_: <span class="string">''</span>,  </span><br><span class="line">    <span class="keyword">get</span> name() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name_;  &#125;,  </span><br><span class="line">    <span class="keyword">set</span> name(name) &#123;    </span><br><span class="line">        <span class="keyword">this</span>.name_ = name;  &#125;,  </span><br><span class="line">        sayName() &#123;    </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'My name is $&#123;this.name_&#125;'</span>);  &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">person.name = <span class="string">'Matt'</span>; person.sayName();  <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure>
短记方法语法和计算的属性键相互兼容<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodKey = <span class="string">'sayName'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person = &#123;  [methodKey](name) &#123;    <span class="built_in">console</span>.log(<span class="string">'My name is $&#123;name&#125;'</span>);  &#125; &#125; </span><br><span class="line"> </span><br><span class="line">person.sayName(<span class="string">'Matt'</span>);  <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-Destructuring-对象分解"><a href="#Object-Destructuring-对象分解" target="_blank" rel="noopener" class="headerlink" title="Object Destructuring  对象分解"></a>Object Destructuring  对象分解</h3>ES6 引入了对象解构，它允许您使用单个语句中的嵌套数据执行一个或多个操作。<br>以下是两个等效的代码片段示例，第一个没有对象分解。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Without object destructuring </span></span><br><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">'Matt'</span>,  <span class="attr">age</span>: <span class="number">27</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> personName = person.name,    </span><br><span class="line">personAge = person.age;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(personName);  <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(personAge);   <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
其次，使用对象分解：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With object destructuring </span></span><br><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">'Matt'</span>,  <span class="attr">age</span>: <span class="number">27</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge &#125; = person;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(personName);  <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(personAge);   <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
解构是您可以声明多个变量，并同时在单个对象字面量中同时执行多个赋值。如果要将属性名称重新作用本地变量名称，则可以使用一下速记语法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">'Matt'</span>,  <span class="attr">age</span>: <span class="number">27</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(age);   <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
销毁分配不必陪陪对象内部的内容，执行分配时，您可以忽略属性，相反，如果引用的属性不存在，则将分配undefined<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">'Matt'</span>,  <span class="attr">age</span>: <span class="number">27</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; name, job &#125; = person;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(job);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
也可以定义默认值，如果源对象中不存在属性，则将应用默认值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">'Matt'</span>,  <span class="attr">age</span>: <span class="number">27</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; name, job=<span class="string">'Software engineer'</span> &#125; = person;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(job);   <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure>
解构使用内部函数ToObject() 在运行时无法直接访问，将源强制为对象，这意味在解构操作中使用原始值的时候，他们将被视为对象；这也意味着，根据ToObject()规范中的定义，null和undefined不能呗解构，并且将引发错误。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length &#125; = <span class="string">'foobar'</span>; </span><br><span class="line"><span class="built_in">console</span>.log(length);        <span class="comment">// 6</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">constructor</span>: c &#125; = <span class="number">4</span>; </span><br><span class="line"><span class="built_in">console</span>.log(c === <span class="built_in">Number</span>);  <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">null</span>;           <span class="comment">// TypeError</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">undefined</span>;      <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
解构不要求变量声明在解构表达式内发生，但是，这样做需要将赋值表达式包含在括号内<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">'Matt'</span>,  <span class="attr">age</span>: <span class="number">27</span> &#125;;</span><br><span class="line"> </span><br><span class="line">(&#123;<span class="attr">name</span>: personName, <span class="attr">age</span>: personAge&#125; = person);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(personName, personAge);  <span class="comment">// Matt, 27</span></span><br></pre></td></tr></table></figure>
<h5 id="Nested-Destructuring-嵌套解构"><a href="#Nested-Destructuring-嵌套解构" target="_blank" rel="noopener" class="headerlink" title="Nested Destructuring  嵌套解构"></a>Nested Destructuring  嵌套解构</h5>引用嵌套属性或分配目标没有任何限制，这使您可以执行诸如执行对象属性副本的操作。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    name: <span class="string">'Matt'</span>,  </span><br><span class="line">    age: <span class="number">27</span>,  </span><br><span class="line">    job: &#123;    </span><br><span class="line">        title: <span class="string">'Software engineer'</span>  &#125; &#125;; </span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">(&#123;   <span class="attr">name</span>: personCopy.name,   <span class="attr">age</span>: personCopy.age,  <span class="attr">job</span>: personCopy.job &#125; = person);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Because an object reference was assigned into personCopy, changing a property </span></span><br><span class="line"><span class="comment">// inside the person.job object will be propagated to personCopy: </span></span><br><span class="line">person.job.title = <span class="string">'Hacker'</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person);      <span class="comment">// &#123; name: 'Matt', age: 27, job: &#123; title: 'Hacker' &#125; &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(personCopy);  </span><br><span class="line"><span class="comment">// &#123; name: 'Matt', age: 27, job: &#123; title: 'Hacker' &#125; &#125;</span></span><br></pre></td></tr></table></figure>
可以嵌套解构分配以匹配嵌套的属性引用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    name: <span class="string">'Matt'</span>,  </span><br><span class="line">    age: <span class="number">27</span>,  </span><br><span class="line">    job: &#123;    <span class="attr">title</span>: <span class="string">'Software engineer'</span>  &#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Declares 'title' variable and assigns person.job.title as its value </span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">job</span>: &#123; title &#125;&#125; = person;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(title);  <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure>
当外部属性未定义时候，不能使用嵌套的属性引用。源对象和目标对象军事如此。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    job: &#123;    </span><br><span class="line">        title: <span class="string">'Software engineer'</span>  &#125; &#125;; </span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 'foo' is undefined on the source object </span></span><br><span class="line">(&#123;   <span class="attr">foo</span>: &#123;    <span class="attr">bar</span>: personCopy.bar  &#125; &#125; = person); </span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property 'bar' of 'undefined' or 'null'.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 'job' is undefined on the destination object </span></span><br><span class="line">(&#123;  <span class="attr">job</span>: &#123;    <span class="attr">title</span>: personCopy.job.title  &#125; &#125; = person); <span class="comment">// TypeError: Cannot set property 'title' of undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="Partial-Destructuring-Completion-部分解构完成"><a href="#Partial-Destructuring-Completion-部分解构完成" target="_blank" rel="noopener" class="headerlink" title="Partial Destructuring Completion 部分解构完成"></a>Partial Destructuring Completion 部分解构完成</h4>请务必主义，设计多个属性结构化分配时具有独立结果的顺序操作。如果在具有多个分配的单个已经分解解构表达式中，初始分配成功，但后来的分配抛出错误，则仅部分完成的已退出结构的分配将退出。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">'Matt'</span>,   <span class="attr">age</span>: <span class="number">27</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> personName, personBar, personAge;</span><br><span class="line"><span class="keyword">try</span> &#123;  <span class="comment">// person.foo is undefined, so this will throw an error  </span></span><br><span class="line">(&#123;<span class="attr">name</span>: personName, <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: personBar &#125;, <span class="attr">age</span>: personAge&#125; = person); &#125; </span><br><span class="line"><span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(personName, personBar, personAge); </span><br><span class="line"><span class="comment">// Matt, undefined, undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="Parameter-Context-Matching-参数上下文匹配"><a href="#Parameter-Context-Matching-参数上下文匹配" target="_blank" rel="noopener" class="headerlink" title="Parameter Context Matching 参数上下文匹配"></a>Parameter Context Matching 参数上下文匹配</h4>也可以在功能参数列表中执行非结构化分配，它不会影响参数对象，但是它允许您在函数签名中声明在函数体内立即可用的变量。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">'Matt'</span>,   <span class="attr">age</span>: <span class="number">27</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson</span>(<span class="params">foo, &#123;name, age&#125;, bar</span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(name, age); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson2</span>(<span class="params">foo, &#123;name: personName, age: personAge&#125;, bar</span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);  <span class="built_in">console</span>.log(personName, personAge); &#125;</span><br><span class="line"> </span><br><span class="line">printPerson(<span class="string">'1st'</span>, person, <span class="string">'2nd'</span>); <span class="comment">// ['1st', &#123; name: 'Matt', age: 27 &#125;, '2nd'] // 'Matt', 27</span></span><br><span class="line"> </span><br><span class="line">printPerson2(<span class="string">'1st'</span>, person, <span class="string">'2nd'</span>); <span class="comment">// ['1st', &#123; name: 'Matt', age: 27 &#125;, '2nd'] // 'Matt', 2</span></span><br></pre></td></tr></table></figure>
<h2 id="OBJECT-CREATION-创建对象"><a href="#OBJECT-CREATION-创建对象" target="_blank" rel="noopener" class="headerlink" title="OBJECT CREATION 创建对象"></a>OBJECT CREATION 创建对象</h2>尽管Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点，使用同一个接口创建很多对象，会产生大量的重复代码。<h3 id="Overview-总览"><a href="#Overview-总览" target="_blank" rel="noopener" class="headerlink" title="Overview 总览"></a>Overview 总览</h3>ES6规范，引入了对类和继承的正式支持。<h3 id="The-Factory-Pattern-工厂模式"><a href="#The-Factory-Pattern-工厂模式" target="_blank" rel="noopener" class="headerlink" title="The Factory Pattern  工厂模式"></a>The Factory Pattern  工厂模式</h3>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建特定对象的过程。此示例显示了一种使用特定接口创建对象的方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();  </span><br><span class="line">    o.name = name;  </span><br><span class="line">    o.age = age;  </span><br><span class="line">    o.job = job;  </span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  &#125;;    </span><br><span class="line">    <span class="keyword">return</span> o; &#125;           </span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
在这里，函数createPerson() 接受用于构建对象的参数，该对象具有表示Person对象的所有必要信息。可以使用不同的参数多次调用该函数，并且甘薯每次它都会返回一个包含三个属性一个方法的对象，尽管这解决了创建多个相似对象的问题，但工厂模式并未解决对象表示(对象是什么类型的对象)问题。<h3 id="构造函数模式-The-Function-Constructor-Pattern"><a href="#构造函数模式-The-Function-Constructor-Pattern" target="_blank" rel="noopener" class="headerlink" title="构造函数模式 The Function Constructor Pattern"></a>构造函数模式 The Function Constructor Pattern</h3>ES中的构造函数可用来创建特定类型的对象。向Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中，此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如：可以使用构造函数模式将前面的例子重写如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;  </span><br><span class="line">    <span class="keyword">this</span>.age = age;  </span><br><span class="line">    <span class="keyword">this</span>.job = job;  </span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  &#125;;  &#125;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">person1.sayName();  <span class="comment">// Nicholas </span></span><br><span class="line">person2.sayName();  <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure>
在这个例子中，Person() 函数代替了工厂的createPerson()函数，请注意，Person()内的代码与CreatePerson()内的代码相同，但还存在不同之处</li>
<li>没有显示的创建对象</li>
<li>直接将属性和方法赋值给了this对象</li>
<li>没有return 语句<br>此外，还应该注意到函数名Person使用的是大写字母P，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数以小写字母开头，这个约定借鉴来自其他OO语言，主要是为了区别JS 的其他函数，因为构造函数本身也是函数，只不过可以用来创建对象而已。<br>要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上经历一下4个步骤。</li>
<li>创建一个新对象在内存中</li>
<li>新对象的内部[[Prototype]] 指针分配给构造函数的prototype属性</li>
<li>将构造函数的作用域赋给新对象 （因此this就指向了这个心对象）</li>
<li>执行构造函数的代码（将属性添加到新对象）</li>
<li>如果构造函数返回一个非null值，则返回该对象，否则将返回刚刚创建的新对象。<br>在前面例子的最后，person1和person2 分别保存着Person的一个不同的实例。这两个对象都有一个constructor 构造函数属性，该属性指向Person<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
对象的constructor 属性最初使用来标识对象类型的。但是提到检测对象类型，还是instanceOf操作符要更可靠一些。我们在这个例子中创建的所有对象既是Object的实例，同时也是Person的实例，这一点通过instanceOf 操作符可以得到验证。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。在这个例子中，person1和person2 之所以同时是Object的实例，是因为所有对象均继承自Object<br>构造函数不必表示为函数声明，分配给变量的函数表达式的行为相同。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, job</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;  </span><br><span class="line">    <span class="keyword">this</span>.age = age;  </span><br><span class="line">    <span class="keyword">this</span>.job = job;  </span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  &#125;;  &#125;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"> </span><br><span class="line">person1.sayName();  <span class="comment">// Nicholas </span></span><br><span class="line">person2.sayName();  <span class="comment">// Greg</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
当实例化的时候，如果不希望传递任何参数，则构造函数后的括号是可选的。无论如何，new运算符都将调用构造函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Jake"</span>;  </span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  &#125;; &#125;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person;</span><br><span class="line"> </span><br><span class="line">person1.sayName();  <span class="comment">// Jake </span></span><br><span class="line">person2.sayName();  <span class="comment">// Jake</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="Constructors-as-Functions-将构造函数当作函数"><a href="#Constructors-as-Functions-将构造函数当作函数" target="_blank" rel="noopener" class="headerlink" title="Constructors as Functions 将构造函数当作函数"></a>Constructors as Functions 将构造函数当作函数</h4>构造函数与其他函数的唯一区别，就在于调用他们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那它就可以作为构造函数。而任何函数，如果不通过new 操作符来调用，那它跟普通函数也不会有什么两样。例如前面例子中定义的Person() 函数可以通过下列任何一种方式来调用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use as a constructor </span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line">person.sayName();   <span class="comment">// "Nicholas"           </span></span><br><span class="line"><span class="comment">// call as a function </span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);  <span class="comment">// adds to window </span></span><br><span class="line"><span class="built_in">window</span>.sayName();   <span class="comment">// "Greg"           </span></span><br><span class="line"><span class="comment">// call in the scope of another object </span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>); </span><br><span class="line">o.sayName();  <span class="comment">// "Kristen"</span></span><br></pre></td></tr></table></figure>
这个例子中的前两行代码展示了构造函数的经典用法，即使用new操作符来创建一个新对象。接下来的两行代码展示了不适用new操作符调用Person() 会出现什么结果： 属性和方法都被添加给window对象了。在没有显示设置此值的情况下（通过对象方法或call()/apply()) 调用此函数的时候，此对象始终指向Global对象。因此在嗲用函数之后，可以通过window 对象来嗲用sayName()方法，并且还返回了greg。最后也可以使用call()（或者apply()）在某个特殊对象的作用域中调用Person()函数。这里实在对象o的作用域中调用的，因此调用后o就拥有了所有属性和sayName()方法。<h4 id="Problems-with-Constructors-构造函数问题"><a href="#Problems-with-Constructors-构造函数问题" target="_blank" rel="noopener" class="headerlink" title="Problems with Constructors 构造函数问题"></a>Problems with Constructors 构造函数问题</h4>尽管构造函数模式好用，但也并非没有去的点的。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。请记住，函数是JS 中的对象，因此没定义一个函数，也就是实例化了一个对象。从逻辑角度将，此时的构造函数也可以这样定义。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;  </span><br><span class="line">    <span class="keyword">this</span>.age = age;  </span><br><span class="line">    <span class="keyword">this</span>.job = job;  </span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(this.name)"</span>);  <span class="comment">// logical equivalent &#125;</span></span><br></pre></td></tr></table></figure>
从这个角度上来看构造函数，更容易明白Person实例都包含一个不同的Function 实例（以显示name属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制仍然是相同的，因此，不同实例上的同名函数是不相等的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
然而创建两个完成同样任务的Function实例的确没有必要；况且有this对象在，根本不用在执行代码前就把函数绑定到特定的对象上面，因为大可像下面这样，通过函数定义转移到构造函数外部来解决这个问题。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;  </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">    <span class="keyword">this</span>.job = job;  </span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName; &#125;           </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"> </span><br><span class="line">person1.sayName();  <span class="comment">// Nicholas </span></span><br><span class="line">person2.sayName();  <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure>
在这个例子汇总，我们把sayName() 函数的定义转移到了构造函数外部，而在构造函数内部，我们将sayName 属性设置成等于全局的sayName函数。这样一来，由于sayName 包含的是一个指向函数的指针，因此person1和person2对象就共享了在全局作用域中定义的同一个sayName() 函数，这样做确实解决了两个函数做同一时间的事情，可是新问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而耿然人无法接受的是，如果对象需要定义很多方法，那么久要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在这些问题可以通过使用原型模式来解决。<h3 id="The-Prototype-Pattern-原型模式"><a href="#The-Prototype-Pattern-原型模式" target="_blank" rel="noopener" class="headerlink" title="The Prototype Pattern 原型模式"></a>The Prototype Pattern 原型模式</h3>我们创建的每个函数都有一个prototype原型属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line">person1.sayName();   <span class="comment">// "Nicholas"           </span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line">person2.sayName();   <span class="comment">// "Nicholas"           </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
使用函数表达式，也适用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;           Person.prototype.name = <span class="string">"Nicholas"</span>; Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line">person1.sayName();   <span class="comment">// "Nicholas"           </span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line">person2.sayName();   <span class="comment">// "Nicholas"           </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="How-Prototypes-Work"><a href="#How-Prototypes-Work" target="_blank" rel="noopener" class="headerlink" title="How Prototypes Work"></a>How Prototypes Work</h4>在此，我们将sayName() 方法和所有属性直接添加到了Person和prototype 属性中，构造函数变成了空函数。即使如此，也让然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数不同的是，新对象的这些方法是有由所有实例共享的。换句话说，person1 和person2 访问的都是同一组属性和同一个sayName() 函数，要理解其工作原理，必须先先了解JS中的原型对象的性质。<h5 id="How-Prototypes-Work-理解原型对象"><a href="#How-Prototypes-Work-理解原型对象" target="_blank" rel="noopener" class="headerlink" title="How Prototypes Work 理解原型对象"></a>How Prototypes Work 理解原型对象</h5>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。在前面的实例中，Person.prototype.constructor 指向Person。 而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br>创建自定义的构造函数之后，其原型对象默认只会取得constructor 属性；至于其他发放，则都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。 这个指针叫做[[Prototype]]。虽然脚本中没有标准的方式访问[[Prototype]]，但是在浏览器中都支持名为 <strong>proto</strong> 属性。 而在其他市县中，这个属性对脚本则是完全不可见的。不过要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在实例与构造函数之间。<br>这种关系可能很难可视化，因此请参考以下代码段，作为整体原型行为的查找表。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * Constructor function can exist as function expression * or function declaration, so both of these are suitable: 构造函数可以以函数表达式或者函数声明的形式存在，因此两者都适用。</span></span><br><span class="line"><span class="comment"> * *   </span></span><br><span class="line"><span class="comment"> * function Person &#123;&#125; *   </span></span><br><span class="line"><span class="comment"> * let Person = function() &#123;&#125; */</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**  * Upon declaration, the constructor function already * has a prototype object associated with it:</span></span><br><span class="line"><span class="comment"> * 声明后，构造函数已经具有与之关联的原型对象</span></span><br><span class="line"><span class="comment"> *  */</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype); </span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype); </span><br><span class="line"><span class="comment">// &#123; //   constructor: f Person(), </span></span><br><span class="line"><span class="comment">//   __proto__: Object // &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** * As mentioned previously, the constructor function has * a 'prototype' reference to the prototype object, and * the prototype object has a 'constructor' reference to * the constructor function. These references are cyclical: */</span></span><br><span class="line"><span class="comment">/* 如前所述，构造函数具有对线性对象的prototype引用，并且原型对象具有对constructor 引用到构造函数，这些引用时循环的。 */</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person);  <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** * Any normal prototype chain will terminate at the Object prototype. * The prototype of the Object prototype is null. 任何正常的原型链都将终止于Object原型，对象的原型为null</span></span><br><span class="line"><span class="comment"> * */</span> </span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype);    <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.constructor === <span class="built_in">Object</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.__proto__ === <span class="literal">null</span>);      <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);  </span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line">    <span class="comment">//   constructor: f Object(), </span></span><br><span class="line">    <span class="comment">//   toString: ... </span></span><br><span class="line">    <span class="comment">//   hasOwnProperty: ... //   isPrototypeOf: ... //   ... // &#125;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(),    </span><br><span class="line">    person2 = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** * The constructor, the prototype object, and an instance * are three completely distinct objects: 构造函数，prototype 对象和实例 是三个完全不同的对象 */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person);            <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person.prototype);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype !== person);   <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**  * An instance is linked to the prototype through __proto__, which  * is the literal manifestation of the [[Prototype]] hidden property.  一个实例通过__proto__链接到原型，该原型是[[Prototype]]隐藏属性的字面体现 *  * A constructor is linked to the prototype through the constructor property. 通过构造函数属性将构造函数链接到原型  *   * An instance has no direct link to the constructor, only through the prototype.  实例没有直接链接到构造函数，仅通过原型即可。 */</span> </span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype);    <span class="comment">// true </span></span><br><span class="line">conosle.log(person1.__proto__.constructor === Person);  <span class="comment">// true  </span></span><br><span class="line"><span class="comment">/** * Two instances created from the same constructor function will share * a prototype object: </span></span><br><span class="line"><span class="comment"> * 同一个构造函数创建的两个实例将共享 一个prototype 对象*</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === person2.__proto__);  <span class="comment">// true </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** * instanceof will check the instance's prototype chain against the * prototype property of a constructor function:  instanceof 将对照构造函数的prototype 属性检查实例的原型链*/</span> </span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);           <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);           <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
考虑使用Person构造函数和Person.prototype 的原始示例。<br>P321 页 图<br>显示了Person构造函数，Person 的原型属性以及Person现有的两个实例之间的关系。在此，Person.prototype 指向了原型对象，而Person.prototype.constructor 又指回了Person。 原型对象中除了包产constructor 属性之外，还包括后来添加的其他属性。Person的每个实例 - person1 和person2 都包含了一个内部属性，该属性仅仅指向了Person.prototype； 换句话说，他们与构造函数没有直接关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName() 也可以调用，这是通过查找对象属性的过程来实现的。<br>虽然在所有实现中都无法访问[[Prototype]]， 但可以通过isPrototypeof() 方法来确定对象之间是否存在这种关系，。从本质上讲，如果[[Prototype]] 指向调用isPrototypeOf() 方法的对象(Person.prototype)， 那么这个方法就返回true<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1));  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
这里，我们用原型对象的isPrototypeOf()方法测试了person1 和person2。 因为他们内部都有一个指向Person.prototype 的指针，因此都返回true<br>对象类型具有一个被称为Object.getPrototypeOf() 的方法，该方法返回[[Prototype]] 的值。例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1).name);                 <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
此代码的第一行只是确认Object.getPrototypeOf() 返回的对象实际就是这个对象的原型，第二行代码取得了原型对象中name 属性的值，也就是”Nicholas”。 使用Object.getPrototypeOf() 可以方便的取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。<br>Object类型 还具有一个setPrototypeOf() 方法，该方法将新值写入实例的[[Prototype]]. 这使您可以覆盖已经实例化的对象的原型结构层次<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;  <span class="attr">numLegs</span>: <span class="number">2</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123;  <span class="attr">name</span>: <span class="string">'Matt'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, biped);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);                <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs);             <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
为了避免这些速度下降，最好仅仅创建一个新对象，并使用Object.create() 指定其原型：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;  <span class="attr">numLegs</span>: <span class="number">2</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(biped); </span><br><span class="line">person.name = <span class="string">'Matt'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);                              <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs);                           <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="Understanding-the-Prototype-Hierarchy-了解原型层次结构"><a href="#Understanding-the-Prototype-Hierarchy-了解原型层次结构" target="_blank" rel="noopener" class="headerlink" title="Understanding the Prototype Hierarchy  了解原型层次结构"></a>Understanding the Prototype Hierarchy  了解原型层次结构</h4>每当代码读取某个对象的某个属性的时候，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续上搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值，也就是在我们调用person1.sayName()的时候，会先后执行两次搜索。首先，解析器会问：”实例person1有sayName的属性吗？”答：没有。 然后，它继续搜索，在问： person1 的原型有sayName属性吗？ 答 有。 于是他就读取那个保存在原型对象中的函数，当我们调用person2.sayName() 的时候，将会重现相同的搜索过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。<br>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();          </span><br><span class="line">person1.name = <span class="string">"Greg"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name);   <span class="comment">// "Greg" - from instance </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);   <span class="comment">// "Nicholas" - from prototype</span></span><br></pre></td></tr></table></figure>
在这个例子中，person1 和name 被一个属性被新值覆盖。person.name和person.name 仍然可以正常运行，分别返回Greg和Nicholas。 在console.log() 中访问person1.name 的时候需要读取他的值，因此就会在这个实例上搜索一个名为name的属性。这个属性确实存在，于是就返回它的值而不必在搜索原型了。当以同样的方式访问person2.name 的时候，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了name 属性。<br>党委对象实例添加一个属性的时候，这个属性就会屏蔽原型对象中保存的同名属性。换句话说，添加这个属性只会组织我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null,也只会在实例中设置这个属性，而不会恢复期指向原型的链接。不过使用delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();           </span><br><span class="line">person1.name = <span class="string">"Greg"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name);   <span class="comment">// "Greg" - from instance </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);   <span class="comment">// "Nicholas" - from prototype           </span></span><br><span class="line"><span class="keyword">delete</span> person1.name; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name);   <span class="comment">// "Nicholas" - from the prototype</span></span><br></pre></td></tr></table></figure>
在这个修改后的例子中，我们使用delete操作符删除了person1.name, 之前它保存的Greg值屏蔽了同名的原型属性。把它删除后，就恢复了对原型中name属性的链接。因此，接下来在调用person.name 的时候，返回的就是原型中name 属性的值了<br>使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法(不要忘了它是从Object继承来的) 只在给定属性存在于对象实例中的时候，才返回true。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// false           </span></span><br><span class="line">person1.name = <span class="string">"Greg"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name);   <span class="comment">// "Greg" - from instance </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// true  </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);   <span class="comment">// "Nicholas" - from prototype </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// false </span></span><br><span class="line"><span class="keyword">delete</span> person1.name; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name);   <span class="comment">// "Nicholas" - from the prototype </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
通过使用hasOwnProperty() 方法的时候，什么时候访问的是实例属性，什么时候访问的是原型属性就一清二楚了。调用person1.hasOwnProperty(“name”)的时候，只有当person1 重写name 属性才会返回true， 因为只有这时候name 才是一个实例属性，而非原型属性。<h4 id="Prototypes-and-the-“in”-Operator-原型与In操作符"><a href="#Prototypes-and-the-“in”-Operator-原型与In操作符" target="_blank" rel="noopener" class="headerlink" title="Prototypes and the “in” Operator  原型与In操作符"></a>Prototypes and the “in” Operator  原型与In操作符</h4>有两种使用方式in操作符，单独使用和在for-in循环使用。在单独使用的时候，in操作符会通过对象能够访问给定属性的时候返回true，无论该属性存在于实例中还是原型中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();           </span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1);  <span class="comment">// true           </span></span><br><span class="line">person1.name = <span class="string">"Greg"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name);   <span class="comment">// "Greg" - from instance </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1);  <span class="comment">// true           </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);   <span class="comment">// "Nicholas" - from </span></span><br><span class="line">prototype <span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person2);  <span class="comment">// true           </span></span><br><span class="line"><span class="keyword">delete</span> person1.name; <span class="built_in">console</span>.log(person1.name);   <span class="comment">// "Nicholas" - from the prototype </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
在以上代码的执行整个过程中，name 属性要么是直接在对象上访问到的，要么是通过原型访问到的。因此，调用name in person1 始终都返回true。 无论该属性存在于实例中还是存在于原型中。同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在什么对象中，还是存在于原型中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span> (<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于in操作符只要通过对象能够访问到属性就返回true， hasOwnProperty() 只在属性存在于事例中时候才返回true, 因此只要in 操作符 返回true 而 hasOwnProperty() 返回true ，既可以确定属性是原型中的属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();    </span><br><span class="line"><span class="built_in">console</span>.log(hasPrototypeProperty(person, <span class="string">"name"</span>));  <span class="comment">// true           </span></span><br><span class="line">person.name = <span class="string">"Greg"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(hasPrototypeProperty(person, <span class="string">"name"</span>));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
在这里name 属性 先是存在于原型中，因此hasPrototypeProperty() 返回true。 当在实例中重写name 属性后，该属性就存在于实例中了。因此hasPrototypeProperty() 返回false。 即使原型中仍然有name 属性，但由于现在实例中也有了这个属性，因此原型中的name 属性就用不到了。<br>在使用for-in 循环的时候，返回的是所有能够通过对象访问的，可枚举，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enmerable]]标记为false属性）的实例属性也会在for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可以枚举的。<br>要检索对象上所有可枚举实例属性的列表，可以使用Object.keys() 方法，该方法接受一个对象作为其参数，并返回包含所有可枚举属性名字的字符串数组。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Person.prototype); </span><br><span class="line"><span class="built_in">console</span>.log(keys);    <span class="comment">// "name,age,job,sayName" </span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(); </span><br><span class="line">p1.name = <span class="string">"Rob"</span>; </span><br><span class="line">p1.age = <span class="number">31</span>; </span><br><span class="line"><span class="keyword">let</span> p1keys = <span class="built_in">Object</span>.keys(p1); </span><br><span class="line"><span class="built_in">console</span>.log(p1keys);  <span class="comment">// "name,age"</span></span><br></pre></td></tr></table></figure>
在这里，keys 变量由包含 name ,age, job 和sayName 的数组填充。这里通常使用for-in出现的顺序。在Person 的实例上调用的时候，Object.keys() 返回name 和age 的数组，这是仅有的两个实例属性。<br>如果需要所有实例属性(无论是否可枚举)的列表，则可以使用Object.getOwnPropertyName() 以相同的方式。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); </span><br><span class="line"><span class="built_in">console</span>.log(keys);   <span class="comment">// "constructor,name,age,job,sayName"</span></span><br></pre></td></tr></table></figure>
请注意，结果列表中包含了不可枚举的constructor属性。Object.keys() 和Object.getOwnPropertyName() 可能是for-in 的替代品<br>随着ES6符号的引入，需要Object.getOwnPropertyNames()。 因为符号键属性没有名称概念，所以getOwnPropertyNames() 变得显而易见，因此引入了Object.getOwnPropertySymbols() 它提供了与Object.getOwnPropertyNames() 相同的行为<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">'k1'</span>),    </span><br><span class="line">k2 = <span class="built_in">Symbol</span>(<span class="string">'k2'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> o = &#123;  [k1]: <span class="string">'k1'</span>,  [k2]: <span class="string">'k2'</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o)); <span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure>
<h4 id="Property-Enumeration-Order-属性列举顺序"><a href="#Property-Enumeration-Order-属性列举顺序" target="_blank" rel="noopener" class="headerlink" title="Property Enumeration Order  属性列举顺序"></a>Property Enumeration Order  属性列举顺序</h4>for-in 循环，Object.keys() , Object.getOwnPropertyNames/Symbols() 和 Object.assign() 在属性枚举顺序上有重要区别。for-in循环和Object.keys() 没有确定的枚举顺序，这些顺序有JS引擎确定的，并且可能因为浏览器而异。<br>Object.getOwnPropertyNames()Object.getOwnPropertySymbols(), 和 Object.assign(), 确实具有确定枚举顺序。 数字键 将首先以升序顺序枚举，然后字符串和符号键以插入顺序枚举。在对象字面量汇总内联定义的键将以逗号分隔的顺序插入。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">'k1'</span>),    </span><br><span class="line">    k2 = <span class="built_in">Symbol</span>(<span class="string">'k2'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> o = &#123;  </span><br><span class="line">    <span class="number">1</span>: <span class="number">1</span>,  </span><br><span class="line">    first: <span class="string">'first'</span>,  </span><br><span class="line">    [k1]: <span class="string">'sym2'</span>,  </span><br><span class="line">    second: <span class="string">'second'</span>,  </span><br><span class="line">    <span class="number">0</span>: <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">o[k2] = <span class="string">'sym2'</span>; </span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>; </span><br><span class="line">o.third = <span class="string">'third'</span>; </span><br><span class="line"><span class="number">0</span>[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// ["0", "1", "3", "first", "second", "third"]</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o)); </span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-Iteration"><a href="#Object-Iteration" target="_blank" rel="noopener" class="headerlink" title="Object Iteration"></a>Object Iteration</h3>对于大多数JS 历史而言，迭代对象的属性都是一件麻烦事。ES2017 引入了两种静态方法，用于将对象的内容转换为有序的(更重要的是可迭代)格式。 这些静态方法， Object.values() 和Object.entries() 。接收和对象并且在数组中返回其中的内容。Object.values() 返回对象值的数组，而Object.entries() 返回数组对的数组，每个数组对代表对象中的[key,value] 对。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;  <span class="attr">foo</span>: <span class="string">'bar'</span>,  <span class="attr">baz</span>: <span class="number">1</span>,  <span class="attr">qux</span>: &#123;&#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)); <span class="comment">// ["bar", 1, &#123;&#125;]</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o))); <span class="comment">// [["foo", "bar"], ["baz", 1], ["qux", &#123;&#125;]]</span></span><br></pre></td></tr></table></figure>
请注意，非字符串属性在输出的数组中转换为字符串，此外，该方法执行对象的浅拷贝。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;  <span class="attr">qux</span>: &#123;&#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)[<span class="number">0</span>] === o.qux); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(o)[<span class="number">0</span>][<span class="number">1</span>] === o.qux); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
符号键属性将被忽略<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> o = &#123;  [sym]: <span class="string">'foo'</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)); <span class="comment">// []</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o))); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h4 id="Alternate-Prototype-Syntax-另外的原型语法"><a href="#Alternate-Prototype-Syntax-另外的原型语法" target="_blank" rel="noopener" class="headerlink" title="Alternate Prototype Syntax  另外的原型语法"></a>Alternate Prototype Syntax  另外的原型语法</h4>您可能已经在前面的实例主义到，必须为每个属性和方法键入Person.prototype 。 为了限制这种冗余并更好地从视觉上封装原型的功能，使用包含所有属性和方法对象常量 简单的覆盖 原型已经变得越来越普遍。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line">Person.prototype = &#123;  </span><br><span class="line">    name: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    age: <span class="number">29</span>,  </span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,  </span><br><span class="line">sayName() &#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  &#125; &#125;;</span><br></pre></td></tr></table></figure>
在这个重写的示例中. Person.prototype 属性设置为等于 使用对象字面量 创建的新对象。最终结果是相同的，但有一个例外，构造函数属性不在指向Person。 创建函数的时候，将创建其原型对象和自动分配构造函数。本质上，此语法会完全覆盖默认的原型对象，这意味着构造函数属性等于全新（对象构造函数）的属性，而不是函数本身。机关instanceOf运算符仍然可以可靠的运行，但是您不能依靠构造函数来指示对象的类型。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person);      <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person);  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
在这里，instanceOf 对于Object 和 Person 仍然返回true。但是构造函数属性现在等于Object 而不是Person。 如果构造函数的值很重要，则可以将其专门设置回适当的值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; &#125;           </span><br><span class="line">Person.prototype = &#123;  </span><br><span class="line">    <span class="keyword">constructor</span>: Person,  </span><br><span class="line">    name: "Nicholas",  </span><br><span class="line">    age: 29,  </span><br><span class="line">    job: "Software Engineer",  </span><br><span class="line">    sayName() &#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  &#125; &#125;;</span><br></pre></td></tr></table></figure>
该代码专门包含了一个构造函数属性，并将其设置为Person, 以确保该属性包含适当的值。<br>请记住 ，以这种方式还原构造函数会创建一个[[Enumerable]] 设置为true 的属性，默认情况下，本地构造函数属性不可枚举。因此如果您使用兼容的JS 引擎，则可能希望使用Object.defineProperty()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line">Person.prototype = &#123;  </span><br><span class="line">    name: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    age: <span class="number">29</span>,  </span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,  </span><br><span class="line">    sayName() &#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  &#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// restore the constructor Object.defineProperty</span></span><br><span class="line">(Person.prototype, <span class="string">"constructor"</span>, &#123;  </span><br><span class="line">    enumerable: <span class="literal">false</span>,  <span class="attr">value</span>: Person &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Dynamic-Nature-of-Prototypes-原型动态性"><a href="#Dynamic-Nature-of-Prototypes-原型动态性" target="_blank" rel="noopener" class="headerlink" title="Dynamic Nature of Prototypes 原型动态性"></a>Dynamic Nature of Prototypes 原型动态性</h4>因为在原型上查找值的过程是一种搜索，所以在任何时候对原型所做的更改都会立即反应在实例上，即使进行更改之前存在的实例也是如此。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();           Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>); &#125;;           </span><br><span class="line">friend.sayHi();  <span class="comment">// "hi" - works!</span></span><br></pre></td></tr></table></figure>
以上代码先创建了一个Person的一个实例，并将其保存在person中，然后下一条语句在Person.prototype 中添加了一个方法sayHi()。 即使person 实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用person.sayHi() 的时候，首先会在实例中搜索名为sayHi的属性，在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi 属性并保存在那里的函数。<br>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反应出来，但如果重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数的时候会为实例添加一个执行最初原型的[[Prototype]] 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住，实例中的指针仅仅指向原型，而不指向构造函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;  </span><br><span class="line">    <span class="keyword">constructor</span>: Person,  </span><br><span class="line">    name: "Nicholas",  </span><br><span class="line">    age: 29,  </span><br><span class="line">    job: "Software Engineer",  </span><br><span class="line">    sayName() &#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  &#125; &#125;; </span><br><span class="line">friend.sayName();   <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
在这个例子中我们先创建了一个Person 的一个实例，然后又重写了其原型对象。然后在嗲用friend.sayName() 的时候发生了错误，因为friend 指向的原型中不包含以该名字命名的属性<br>在构造函数上覆盖原型意味着实例引用新原型，而任何先前存在的对象实例仍然引用旧原型。<h4 id="Native-Object-Prototypes-原生对象的原型"><a href="#Native-Object-Prototypes-原生对象的原型" target="_blank" rel="noopener" class="headerlink" title="Native Object Prototypes 原生对象的原型"></a>Native Object Prototypes 原生对象的原型</h4>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型(Object,Array,String) 都在其构造函数的原型上定义了方法。例如在Array.prototype 中可以找到sort() 方法，而在String.prototype 中可以找到substring() 方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort);        <span class="comment">// "function" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring);  <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure>
通过原生的对象，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String添加了一个名为startsWith()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123; </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) === <span class="number">0</span>; &#125;;           </span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">"Hello world!"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
在这里新定义的startWith() 方法会在传入的文本位于一个字符串开始的时候返回true。 既然方法被添加给了String.prototype， 那么当前环境中的所有字符串都可以调用它。由于msg 是字符串，而且后台会调用String 基本包装函数创建这个字符串，因此通过msg就可以调用startsWith()方法。、<h4 id="Problems-with-Prototypes-原型对象的问题"><a href="#Problems-with-Prototypes-原型对象的问题" target="_blank" rel="noopener" class="headerlink" title="Problems with Prototypes 原型对象的问题"></a>Problems with Prototypes 原型对象的问题</h4>原型模式也不是没有缺点，首先它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。<br>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line">Person.prototype = &#123;  </span><br><span class="line">    <span class="keyword">constructor</span>: Person,  </span><br><span class="line">    name: "Nicholas", </span><br><span class="line">    age: 29,  </span><br><span class="line">    job: "Software Engineer",  </span><br><span class="line">    friends: ["Shelby", "Court"],  </span><br><span class="line">    sayName() &#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  &#125; &#125;;           </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();           person1.friends.push(<span class="string">"Van"</span>);           </span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);  <span class="comment">// "Shelby,Court,Van" </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);  <span class="comment">// "Shelby,Court,Van" </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
在此，Person.prototype 对象有一个名为friends 的属性，该属性包含一个字符串数组，然后创建了Person 的两个实例，接着，修改了person1,friends 引用的数组，向数组中添加了一个字符串。由于friends 数组存在于Person.prototype 而非person1 中，所以刚刚提到的修改也会通过person2.friends 反应出来。加入我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我没有话可说，可是实例一般都是要有属于自己的全部属性，而这个问题正是我们很少看到有人单独使用原型模式的原因所在。<h2 id="Inheritance-继承"><a href="#Inheritance-继承" target="_blank" rel="noopener" class="headerlink" title="Inheritance 继承"></a>Inheritance 继承</h2>许多OO语言都支持两种继承方式： 接口继承和实现继承。 接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，所以JS 无法实现接口继承，JS 只支持实现继承，而且其实现继承主要依靠原型链来实现的<h3 id="Prototype-Chaining"><a href="#Prototype-Chaining" target="_blank" rel="noopener" class="headerlink" title="Prototype Chaining"></a>Prototype Chaining</h3>将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数，实例和原型之间的关系。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含这一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，这就是所谓原型链的概念。<br>实现原型链有一种基本模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>; &#125;           </span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property; &#125;;           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>; &#125;           </span><br><span class="line">    <span class="comment">// inherit from SuperType </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();           </span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty; &#125;;           </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType(); </span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
以上代码定义了两个类型 SuperType 和SubType。 每个类类型分别有一个属性和一个方法。他们的主要区别是SubType 继承了SuperType。 而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于SuperType 的实例中的所有属性和方法，现在也存在于SubType.prototype 中了。在确立了继承关系之后，我们给SubType.prototype 添加了一个方法，这样就在继承了SuperType 的属性和方法的基础上有添加了一个方法。<br>上面的代码中，我们没有使用SubType默认提供的原型，而是给它换了一个新原型；这个心原型的就是SuperType 的实例。于是，新原型不仅具有作为一个SuperType 的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了SuperType 的原型。最终结果就是这样的： instance 指向SubType 的原型， SubType 的原型又指向SuperType 的原型。getSuperValue() 方法仍然还在SuperType.prototype 中，但property 则位于SubType.prototype 中。这是因为property是一个实例属性，而getSuperValue() 则是一个原型方法，既然subType.prototype现在是SuperType 的实例，那么property 当然就位于该实例中了。此外，要注意instance.constructor 现在指向的是SuperType。这是因为原来SubType.prototype 中的constructor 被重写了的缘故。<br>通过实现原型链，本质上扩展了本章前面介绍的原型链搜索机制，当以读取模式访问一个实例属性的时候，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。子啊通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue() 会经理三个搜索步骤， 搜索实例，搜索SubType.prototype 。 搜索SuperType.prototype 最后一步才会找到该方法。在找不到属性或方法的情况下，索索构成总是要一环一环的前行到原型链末端才会停下来。<h3 id="Default-Prototypes-默认原型"><a href="#Default-Prototypes-默认原型" target="_blank" rel="noopener" class="headerlink" title="Default Prototypes  默认原型"></a>Default Prototypes  默认原型</h3>实际上，前面李忠展现的原型链还少一环。我们知道，所有引用类型默认都继承了Object， 而这个继承也是通过原型链实现的。所有函数的默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向Object.prototype 。 这也是所有自定义类都会继承toString() ， valueOf() 等默认方法的根本原因。所以我们说还是那个面例子展示的原型链中应该还包括另外一个继承层次。<br>SubType 继承了SuperType， 而SuperType 继承了Object. 当调用instance.toString() 的时候，实际上调用的还是保存在Object.prototype 中的那个方法。<h3 id="Prototype-and-Instance-Relationships-原型与实例的关系"><a href="#Prototype-and-Instance-Relationships-原型与实例的关系" target="_blank" rel="noopener" class="headerlink" title="Prototype and Instance Relationships  原型与实例的关系"></a>Prototype and Instance Relationships  原型与实例的关系</h3>可以通过两种方式来原型和实例之间的关系。第一种方式是使用instanceOf操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType);  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
由于原型链的关系，我们可以说instance 是Object ， SuperType, SubType 中任何一个类型的实例。因此，测试这三个构造函数的结构都返回了true。<br>第二种方式是isPrototypeOf() 方法。同样只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型，因此isPrototypeOf() 方法也会返回true。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));     <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance));  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance));    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="使用方法"><a href="#使用方法" target="_blank" rel="noopener" class="headerlink" title="使用方法"></a>使用方法</h3>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>; &#125;           </span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.property; &#125;;           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="comment">// inherit from SuperType </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();           </span><br><span class="line"><span class="comment">// new method </span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty; &#125;;           </span><br><span class="line"><span class="comment">// override existing method SubType.prototype.</span></span><br><span class="line">getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; &#125;;          </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType(); </span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
在以上代码中，加粗的部分是两个方法的定义。第一个方法getSubValue() 被添加到了SubType中。 第二个方法getSuperValue() 是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当通过SubType 的实例调用getSuperValue()的时候，调用的就是这个重新定义的方法。但是通过SuperType的实例调用getSuperTypeValue() 的时候，还会继续调用原来的那个方法。这里要注意的是，必须再用SuperType的实例替换原型之后，在定义这两个方法。<br>即在通过原型链实现继承的时候，不能使用对象字面量创建原型方法，因为这样做就会重写原型链。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>; &#125;           </span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property; &#125;;           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>; &#125;           </span><br><span class="line"><span class="comment">// inherit from SuperType </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();           </span><br><span class="line"><span class="comment">// try to add new methods - this nullifies the previous line </span></span><br><span class="line">SubType.prototype = &#123;  </span><br><span class="line">    getSubValue() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;  &#125;,   </span><br><span class="line">    someOtherMethod() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  &#125; ;    &#125;       </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());   <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
以上代码展示了刚刚把SuperType的实例赋值给原型，紧接着有奖原型替换成一个对象字面量而导致的问题，由于现在的原型包含的是一个Object 的实例，而非SuperType 的实例，因此我们摄像中的原型链已经被切断。 SubType 和SuperType 之间已经没有关系了。<h3 id="Problems-with-Prototype-Chaining"><a href="#Problems-with-Prototype-Chaining" target="_blank" rel="noopener" class="headerlink" title="Problems with Prototype Chaining"></a>Problems with Prototype Chaining</h3>原型链虽然很强大，可以用它来实现继承，但是也存在一些问题。其中，最主要的问题来自包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享，而这也正是为什么要在构造书中，而不是在原型对象中定义属性的原因。在通过原型来实现继承的时候，原型世纪上回变成另一个类型的实例。于是，原先的实例属性也就顺理成章的变成了现在的原型属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; &#125;           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;           </span><br><span class="line"><span class="comment">// inherit from SuperType </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();           </span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">// "red,blue,green,black"           </span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);  <span class="comment">// "red,blue,green,black"</span></span><br></pre></td></tr></table></figure>
在这个例子中SuperType 构造函数定义了一个colors属性，该属性包含一个数组。SuperType 的每个实例都会有各自包含自己的数组colors属性。当SubType 通过原型链继承SuperType 之后，SubType.prototype 就变成了SuperType 的一个实例，因此它也拥有了一个它自己的colors 属性- 就跟专门创建了一个SubType.prototype.colors 属性一样。结果是SubType 的所有实例都会共享这一个colors属性。而我们对instace1.colors 的修改能够通过instance2.colors 反应出来。就已经充分证实了这一点。<h3 id="Constructor-Stealing-借用构造函数"><a href="#Constructor-Stealing-借用构造函数" target="_blank" rel="noopener" class="headerlink" title="Constructor Stealing 借用构造函数"></a>Constructor Stealing 借用构造函数</h3>在解决原型中包含引用类型值所带来的问题的过程中，开发人员开始使用一种叫做借用构造函数的技术，有时候也叫做伪造对象或经典继承。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用apply() 和call()方法也可以在新创建的对象上执行构造函数、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; &#125;           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;    <span class="comment">// inherit from SuperType  </span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>); &#125;           </span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(); </span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">// "red,blue,green,black"           </span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);  <span class="comment">// "red,blue,green"</span></span><br></pre></td></tr></table></figure>
在代码中加醋的哪一行代码借调了超类型的构造函数。通过使用call()方法，apply() 方法也可以，我们实际上是在新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType 对象上执行SuperType()函数定中定义的所有对象初始化代码，结果SubType 的每个实例就都会具有自己的colors属性的副本了。<h4 id="Passing-Arguments-传递参数"><a href="#Passing-Arguments-传递参数" target="_blank" rel="noopener" class="headerlink" title="Passing Arguments  传递参数"></a>Passing Arguments  传递参数</h4>相对于原型链而言，借用构造函数有一个很大的优势，即可在子类型构造函数中项超类型构造函数传递参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name; &#125;           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;    <span class="comment">// inherit from SuperType passing in an argument  </span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);    <span class="comment">// instance property  </span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>; &#125;           </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType(); </span><br><span class="line"><span class="built_in">console</span>.log(instance.name);  <span class="comment">// "Nicholas"; </span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);   <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
以上代码中的SuperType 只接受一个参数name，该参数会直接赋给一个属性。在SubType 构造函数内部调用SuperType 构造函数的时候，实际上是为了SubType 的实例这是了name属性。为了确保SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，在添加应该在子类型中定义的属性。<h4 id="Problems-with-Constructor-Stealing-借用构造函数的问题"><a href="#Problems-with-Constructor-Stealing-借用构造函数的问题" target="_blank" rel="noopener" class="headerlink" title="Problems with Constructor Stealing  借用构造函数的问题"></a>Problems with Constructor Stealing  借用构造函数的问题</h4>如果仅仅是借用构造函数，那额也将无法避免构造函数模式存在的问题，方法都在构造函数中定义，因此函数服用就无从说起了。而且在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。<h3 id="Combination-Inheritance-组合继承"><a href="#Combination-Inheritance-组合继承" target="_blank" rel="noopener" class="headerlink" title="Combination Inheritance 组合继承"></a>Combination Inheritance 组合继承</h3>组合继承 ，有时候页脚做伪经典继承，值得是将原型链和借用构造函数的技术组合到一起，从而发挥而这之长的一种继承模式，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;  </span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; &#125;           </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;    </span><br><span class="line">    <span class="comment">// inherit properties  </span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);    </span><br><span class="line">    <span class="keyword">this</span>.age = age; &#125;           </span><br><span class="line">    <span class="comment">// inherit methods </span></span><br><span class="line">    SubType.prototype = <span class="keyword">new</span> SuperType();           SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age); &#125;;           </span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>); </span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">// "red,blue,green,black" </span></span><br><span class="line">instance1.sayName();            <span class="comment">// "Nicholas"; </span></span><br><span class="line">instance1.sayAge();             <span class="comment">// 29           let </span></span><br><span class="line">instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>); </span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);  <span class="comment">// "red,blue,green" </span></span><br><span class="line">instance2.sayName();            <span class="comment">// "Greg"; </span></span><br><span class="line">instance2.sayAge();             <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
在这个例子中，SuperType 构造函数定义了两个属性： name 和 colors。 SuperType 的原型定义了一个方法sayName()。 SubType构造函数在调用SuperType 构造函数的时候传入了name 参数，紧接着又定义了它自己的属性age。 然后将SuperType 的实例赋值给subType 的原型，然后又在该原型上定义了方法sayAge()。 这样一来就可以让两个不同的subType 实例既分别拥有自己的属性-包括colors 属性，又可以使用相同的方法了。<br>组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，成为了JS 中最常用的继承模式。而且instanceOf和isPrototypeof() 也能够用于识别基于组合继承创建的对象。<h3 id="原型继承"><a href="#原型继承" target="_blank" rel="noopener" class="headerlink" title="原型继承"></a>原型继承</h3>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;  </span><br><span class="line">    F.prototype = o;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F(); &#125;</span><br></pre></td></tr></table></figure>
在Object() 函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object() 对传入其中的对象执行了一次浅复制<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    name: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>] &#125;;         </span><br><span class="line"><span class="keyword">let</span> anotherPerson = object(person); </span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>; </span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);           </span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = object(person); yetAnotherPerson.name = <span class="string">"Linda"</span>; </span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);           <span class="built_in">console</span>.log(person.friends);   <span class="comment">// "Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
要求你必须有一个对象可以作为另一个对象的基础，如果有这么一个对象的话，可以把它传递给object() 函数，然后在根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person 对象，于是我们把它传入object() 函数中，然后该函数就回去返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.frineds 不仅属于person 所有，而且也会被anotherPerson 以及yetAnotherPerson 共享。实际上，这就相当于又创建了person对象的两个副本。<br>ES5 通过新增Object.create() 方法规范了原型式继承，这个方法接受两个参数： 一个用作新对象原型的对象和 （可选的） 一个为新对象定义额外属性的对象。在传入一个参数的情况下 Object.create() 与object() 方法的行为相同。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    name: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>] &#125;;         </span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person); anotherPerson.name = <span class="string">"Greg"</span>; </span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);           </span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person); yetAnotherPerson.name = <span class="string">"Linda"</span>; </span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);           <span class="built_in">console</span>.log(person.friends);   <span class="comment">// "Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
Object.create() 的第二个参数与 Object.defineProperties() 方法的第二个参数格式相同： 每个属性都是通过自己的描述符定义的，以这种方式制定的任何属性都会覆盖原型对象上的同名属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    name: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>] &#125;;         </span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;  </span><br><span class="line">    name: &#123;   </span><br><span class="line">         value: <span class="string">"Greg"</span>  &#125; &#125;); </span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name);  <span class="comment">// "Greg"</span></span><br></pre></td></tr></table></figure>
在没有必要创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。<h3 id="Parasitic-Inheritance-寄生式继承"><a href="#Parasitic-Inheritance-寄生式继承" target="_blank" rel="noopener" class="headerlink" title="Parasitic Inheritance 寄生式继承"></a>Parasitic Inheritance 寄生式继承</h3>寄生式继承与原型是继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工程模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后在像真的是它做了所有工作一样返回对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> clone = object(original);  <span class="comment">// create a new object by calling a function  </span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;     <span class="comment">// augment the object in some way    </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi"</span>);  &#125;;  </span><br><span class="line">    <span class="keyword">return</span> clone;           <span class="comment">// return the object</span></span><br></pre></td></tr></table></figure>
在这个例子中，createAnother() 函数接受了一个参数，也就是将要作为新对象基础的对象，然后把这个对象original 传递给object() 对象，将返回的结果赋值给clone。再为clone 对象添加一个新方法sayHi() ，最后返回clone 对象。<br>可以像下面这样来使用createAnother()对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">    name: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>] &#125;;         </span><br><span class="line"><span class="keyword">let</span> anotherPerson = createAnother(person); anotherPerson.sayHi();  <span class="comment">// "hi"</span></span><br></pre></td></tr></table></figure>
在这个例子中的代码基于person 返回了一个新对象 anotherPerson。 新对象不仅具有person 的所有属性和方法，而且还有自己的sayHi() 方法<br>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时候使用的object() 函数不是必须的；任何能够返回新对象的函数都适用于此模式。<h3 id="Parasitic-Combination-Inheritance-寄生组合式继承"><a href="#Parasitic-Combination-Inheritance-寄生组合式继承" target="_blank" rel="noopener" class="headerlink" title="Parasitic Combination Inheritance 寄生组合式继承"></a>Parasitic Combination Inheritance 寄生组合式继承</h3>组合继承的最大稳态就是无论什么情况下，都会嗲用两次超类型构造函数： 一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实力属性，但是我们不得不在调用子类型构造函数的时候重写这些属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;  </span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; &#125;           </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;    </span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);      <span class="comment">// second call to SuperType()    </span></span><br><span class="line">    <span class="keyword">this</span>.age = age; &#125;           </span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();   <span class="comment">// first call to SuperType() </span></span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age); &#125;;</span><br></pre></td></tr></table></figure>
加粗字体的行中是调用SuperType构造函数的代码。在第一次调用SuperType 构造函数的时候， SubType.prototype 会得到两个属性 ： name 和colors。 他们都是SuperType 的实例属性，只不过现在位于SubType 的原型中，当调用SubType 构造函数的时候，又会调用一次SuperType 构造函数。、这一次又在新对象上穿件了实例属性name 和colors .于是这两个属性就屏蔽了原型中的两个同名属性、<br>有两组name和colors ： 一组在实例上，一组在SubType原型中。这就是调用两次SuperType 构造函数的结果。解决方法是寄生组合式继承<br>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路就是：不必为了制定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式来继承来继承超类型的原型，然后在将结果指定给子类型的原型。寄生组合式继承的基本模式如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> prototype = object(superType.prototype);  <span class="comment">// create object  </span></span><br><span class="line">    prototype.constructor = subType;              <span class="comment">// augment object  </span></span><br><span class="line">    subType.prototype = prototype;                <span class="comment">// assign object &#125;</span></span><br></pre></td></tr></table></figure>
在这个实例中的inheritPrototype() 函数实现了寄生组合式继承的最简单形式。这个函数接受两个参数 ： 子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二部是为创建的副本添加constructor 属性，从而弥补因重写原型而失去的默认的constructor 属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样我们就可以调用  inheritPrototype() 函数的语句，去替换前面例子中为子类型原型赋值的语句。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;  </span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; &#125;           </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); &#125;;           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;    </span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);    </span><br><span class="line">    <span class="keyword">this</span>.age = age; &#125;           </span><br><span class="line">inheritPrototype(SubType, SuperType);           SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age); &#125;;</span><br></pre></td></tr></table></figure>
在这个例子的高效率体现在它只嗲用了一次SuperType 构造函数，并且因此避免了在SubType.prototype 上穿件不必要，多余的属性，与此同时，原型链还能保持不变。因此还能够正常使用 instanceOf 和isPrototypeOf()。 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。<h2 id="Classes-类"><a href="#Classes-类" target="_blank" rel="noopener" class="headerlink" title="Classes 类"></a>Classes 类</h2>前面的部分对如何仅仅使用ES5中可用的功能来模拟类行为进入了深入的概述，不难得出结论，所示的策略存在各种问题。最重要的事，语法无意过于冗长和混乱。<br>为了解决这些问题，ES6中新引入的功能是可以使用class关键字 正式定义类。在js 中，类从根本上是一种新的语法构造，因此一开始可能会对他们感到陌生，尽管ES6 的类似乎具有面相对象编程的功能，但是他们仍在幕后使用原型和构造函数的概念。<h3 id="类的定义基础"><a href="#类的定义基础" target="_blank" rel="noopener" class="headerlink" title="类的定义基础"></a>类的定义基础</h3>与函数类型想蕾西，定义类有两种主要方法： 类声明和类表达式。两者都是用class 关键字和花括号：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class declaration </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// class expression </span></span><br><span class="line"><span class="keyword">const</span> Animal = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
与函数表达式一样，类表达式必须在执行中进行求值后才能够引用。但是，与函数定义的秉性行为的一个重要偏离是，函数声明会提升，但是类没有。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(FunctionExpression);  <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> FunctionExpression = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(FunctionExpression);  <span class="comment">// function() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration); <span class="comment">// undefined </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionDeclaration</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration); <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(ClassExpression);     <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> ClassExpression = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(ClassExpression);     <span class="comment">// class &#123;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration);    <span class="comment">// ReferenceError: ClassDeclaration is not defined class </span></span><br><span class="line">ClassDeclaration &#123;&#125; </span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration);    <span class="comment">// class ClassDeclaration &#123;&#125;</span></span><br></pre></td></tr></table></figure>
不同于函数声明，函数声明是函数范围，类声明是块范围。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FunctionDeclaration</span>(<span class="params"></span>) </span>&#123;&#125;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClassDeclaration</span> </span>&#123;&#125; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration);  <span class="comment">// FunctionDeclaration() &#123;&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration);  <span class="comment">//                    ReferenceError: ClassDeclaration is not defined</span></span><br></pre></td></tr></table></figure>
<h4 id="Class-Composition-类的组成"><a href="#Class-Composition-类的组成" target="_blank" rel="noopener" class="headerlink" title="Class Composition 类的组成"></a>Class Composition 类的组成</h4>一个类由这个类的构造航发，实例方法，getters，setters 和静态类方法组成。这也都是不明确要求的，一个空类的定义是有效的语法。默认情况下，类定义中的所有内容均已严格模式执行。<br>与构造函数一样，大多数样式指南知道您 大写类名，以将其从其创建的实例区分开 （例如， 类Foo{} 可能创建 实例 foo）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Valid empty class definition 定义有效的空类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Valid class definition with constructor  有效的类和构造函数定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;  <span class="keyword">constructor</span>() &#123;&#125; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Valid class definition with getter </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> </span>&#123;  <span class="keyword">get</span> myBaz() &#123;&#125; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Valid class definition with static method </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;  <span class="keyword">static</span> myQux() &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>
类表达式可以选择命名。 将表达式分配给变量后，可以使用name 检索类表达式命名的字符串，但是类表达式范围之外无法访问标识符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonName</span> </span>&#123;  </span><br><span class="line">    identify() &#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(Person.name, PersonName.name);  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">p.identify();              <span class="comment">// PersonName, PersonName</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Person.name);  <span class="comment">// PersonName </span></span><br><span class="line"><span class="built_in">console</span>.log(PersonName);   <span class="comment">// ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="The-Class-Constructor-类构造器"><a href="#The-Class-Constructor-类构造器" target="_blank" rel="noopener" class="headerlink" title="The Class Constructor 类构造器"></a>The Class Constructor 类构造器</h3>这个构造器关键词用于类定义块内，以表示该类的构造函数的定义。使用方法名构造函数向解释器发出信号，应该调用此特定函数以使用new运算符创建一个新实例。构造函数的定义是可选的： 选择不定义类构造函数与将构造函数定义为空函数相同。<h4 id="Instantiation-实例化"><a href="#Instantiation-实例化" target="_blank" rel="noopener" class="headerlink" title="Instantiation 实例化"></a>Instantiation 实例化</h4>使用new 运算符 实例化Person的操作与将new与函数构造函数一起使用的操作相同。唯一克制的区别是JS 解释器理解将new与类一起使用意味着应该将构造函数用于实例化。<br>使用new嗲用构造函数将执行以下操作。</li>
<li>在内存中创建一个新对象</li>
<li>新对象的内部[[Prototype]] 指针被分配为构造函数的prototype 属性</li>
<li>构造函数的this值分配给新对象（因此在构造函数内部引用的时候，它指向新对象。）</li>
<li>执行构造函数中的代码（将属性添加到对象）</li>
<li>如果构造函数返回一个对象，则返回该对象，否则，将返回刚刚创建的新对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">constructor</span>() &#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'person ctor'</span>);  &#125; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vegetable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">constructor</span>() &#123;    </span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">'orange'</span>;  &#125; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();  <span class="comment">// person ctor</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vegetable(); </span><br><span class="line"><span class="built_in">console</span>.log(v.color);  <span class="comment">// orange</span></span><br></pre></td></tr></table></figure>
实例化类的时候提供的参数用于构造函数的参数，如果不需要使用参数，则类名后的空括号是可选的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;   </span><br><span class="line">         <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);    </span><br><span class="line">         <span class="keyword">this</span>.name = name || <span class="literal">null</span>;  &#125; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person;          <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name);         <span class="comment">// null</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person();        <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name);         <span class="comment">// null</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> Person(<span class="string">'Jake'</span>);  <span class="comment">// 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(p3.name);         <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure>
350页<h4 id="Understanding-Classes-as-Special-Functions"><a href="#Understanding-Classes-as-Special-Functions" target="_blank" rel="noopener" class="headerlink" title="Understanding Classes as Special Functions"></a>Understanding Classes as Special Functions</h4><h3 id="Instance-Prototype-and-Class-Members"><a href="#Instance-Prototype-and-Class-Members" target="_blank" rel="noopener" class="headerlink" title="Instance, Prototype, and Class Members"></a>Instance, Prototype, and Class Members</h3><h4 id="Instance-Members"><a href="#Instance-Members" target="_blank" rel="noopener" class="headerlink" title="Instance Members"></a>Instance Members</h4><h4 id="Prototype-Methods-and-Accessors"><a href="#Prototype-Methods-and-Accessors" target="_blank" rel="noopener" class="headerlink" title="Prototype Methods and Accessors"></a>Prototype Methods and Accessors</h4><h4 id="Static-Class-Methods-and-Accessors"><a href="#Static-Class-Methods-and-Accessors" target="_blank" rel="noopener" class="headerlink" title="Static Class Methods and Accessors"></a>Static Class Methods and Accessors</h4><h4 id="Non-Function-Prototype-and-Class-Members"><a href="#Non-Function-Prototype-and-Class-Members" target="_blank" rel="noopener" class="headerlink" title="Non-Function Prototype and Class Members"></a>Non-Function Prototype and Class Members</h4><h4 id="Iterator-and-Generator-Methods"><a href="#Iterator-and-Generator-Methods" target="_blank" rel="noopener" class="headerlink" title="Iterator and Generator Methods"></a>Iterator and Generator Methods</h4><h3 id="Inheritance"><a href="#Inheritance" target="_blank" rel="noopener" class="headerlink" title="Inheritance"></a>Inheritance</h3><h4 id="Inheritance-Basics"><a href="#Inheritance-Basics" target="_blank" rel="noopener" class="headerlink" title="Inheritance Basics"></a>Inheritance Basics</h4><h4 id="Constructors-HomeObjects-and-super"><a href="#Constructors-HomeObjects-and-super" target="_blank" rel="noopener" class="headerlink" title="Constructors, HomeObjects, and super()"></a>Constructors, HomeObjects, and super()</h4><h4 id="Abstract-Base-Classes"><a href="#Abstract-Base-Classes" target="_blank" rel="noopener" class="headerlink" title="Abstract Base Classes"></a>Abstract Base Classes</h4><h4 id="Inheriting-from-Built-in-Types"><a href="#Inheriting-from-Built-in-Types" target="_blank" rel="noopener" class="headerlink" title="Inheriting from Built-in Types"></a>Inheriting from Built-in Types</h4><h4 id="Class-Mixins"><a href="#Class-Mixins" target="_blank" rel="noopener" class="headerlink" title="Class Mixins"></a>Class Mixins</h4><h1 id="PROXIES-AND-REFLECT"><a href="#PROXIES-AND-REFLECT" target="_blank" rel="noopener" class="headerlink" title="PROXIES AND REFLECT"></a>PROXIES AND REFLECT</h1><h1 id="FUNCTIONS"><a href="#FUNCTIONS" target="_blank" rel="noopener" class="headerlink" title="FUNCTIONS"></a>FUNCTIONS</h1>每个函数都是Function 类型的实例，该函数具有与其他引用类型一样的属性和方法。因为函数是对象，所以函数名称只是指向函数对象的指针，而不必绑定到函数本身。通常使用函数声明语法定义函数如下所示<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure>
在此代码中，变量sum 被定义并初花为一个函数，请注意在function 关键词之后不包含名称，因为它不是必须的，该函数可以由变量sum 引用，另外请注意，函数定义结束之后没有分号<br>函数声明语法几乎完全等同于使用函数表达式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;  <span class="keyword">return</span> num1 + num2; &#125;;</span><br></pre></td></tr></table></figure>
请注意，函数结束后，会有分号，就像在任何变量初始化之后一样。<br>定义<br>与函数表达式另外一种非常相似定义函数表达式的语法就是使用箭头函数语法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;  <span class="keyword">return</span> num1 + num2; &#125;;</span><br></pre></td></tr></table></figure>
定义函数的最后一种方法是使用Function 构造函数，该函数接受任意数量的参数，最后一个参数始终被视为函数主体，而前面的参数会枚举新函数的参数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>);   <span class="comment">// not recommended</span></span><br></pre></td></tr></table></figure>
不建议使用此语法，因为它会引起代码的双重解释，因此会影响性能，但是将函数视为对象，将函数名称视为指针非常重要，这种语法非常适合表示该概念。<h2 id="Arrow-Functions-箭头函数"><a href="#Arrow-Functions-箭头函数" target="_blank" rel="noopener" class="headerlink" title="Arrow Functions 箭头函数"></a>Arrow Functions 箭头函数</h2>ES6中的新增功能是使用 fat-arrow 语法定义函数表达式的功能。在大多数情况下，箭头函数实例化函数对象，这些对象的行为与他们标准函数表达式的行为相同。在可以使用函数表达式的任何地方，也可以使用箭头函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrowSum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;  <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> functionExpressionSum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;  <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(arrowSum(<span class="number">5</span>, <span class="number">8</span>));  <span class="comment">// 13 </span></span><br><span class="line"><span class="built_in">console</span>.log(functionExpressionSum(<span class="number">5</span>, <span class="number">8</span>));  <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
箭头函数在提供更简洁语法的嵌入式情况下特别有用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(ints.map(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;));  <span class="comment">// [2, 3, 4] </span></span><br><span class="line"><span class="built_in">console</span>.log(ints.map(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123; <span class="keyword">return</span> i + <span class="number">1</span> &#125;));        <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
如果指向使用单个参数，则箭头函数不需要括号，如果要使用零个参数或者多个参数，则需要括号、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Both are valid 两者都有效</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;; </span><br><span class="line"><span class="keyword">let</span> triple = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">3</span> * x; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Zero parameters require an empty pair of parentheses  零参数需要一对空括号</span></span><br><span class="line"><span class="keyword">let</span> getRandom = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.random(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple parameters require parentheses 多个参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Invalid syntax: 无效语法</span></span><br><span class="line"><span class="keyword">let</span> multiply = a, b =&gt; &#123; <span class="keyword">return</span> a * b; &#125;;</span><br></pre></td></tr></table></figure>
箭头函数也不需要花括号，但是选择不使用花括号会改变函数的行为。使用花括号被称为块语法，其行为与普通函数表达式相同，因为箭头函数中可以存在多行代码，就像普通函数表达式一样，如果省略花括号，则使用的是简洁主题 语法，并且仅限于一行代码，例如赋值或者表达式，该行的值将隐式返回。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Both are valid and will return the value </span></span><br><span class="line"><span class="keyword">let</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;; </span><br><span class="line"><span class="keyword">let</span> triple = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="number">3</span> * x;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assignment is allowed 允许分配</span></span><br><span class="line"><span class="keyword">let</span> value = &#123;&#125;; </span><br><span class="line"><span class="keyword">let</span> setName = <span class="function">(<span class="params">x</span>) =&gt;</span> x.name = <span class="string">"Matt"</span>; </span><br><span class="line">setName(value); </span><br><span class="line"><span class="built_in">console</span>.log(value.name);  <span class="comment">// "Matt"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Invalid syntax: </span></span><br><span class="line"><span class="keyword">let</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="keyword">return</span> a * b;</span><br></pre></td></tr></table></figure>
箭头函数尽管语法简洁，但在某些情况下并不适用，他们不许允许使用参数,super 和 new.target 也不能用作构造函数，此外，使用箭头函数创建的函数对象未定义原型。<h2 id="Function-names"><a href="#Function-names" target="_blank" rel="noopener" class="headerlink" title="Function names"></a>Function names</h2>因为函数名称只是函数的指针，所以他们的作用类似于包含指向对象的指针的任何其他变量。这意味着一个函数可以有多个名称<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;  <span class="keyword">return</span> num1 + num2; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));         <span class="comment">// 20                   </span></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum;        </span><br><span class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20                   </span></span><br><span class="line">sum = <span class="literal">null</span>;        </span><br><span class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
此代码定义了一个名为sum()的函数，该函数将两个数字加载一起。声明变量anotherSum 并将其设置为等于sum。 请注意，使用不带括号的函数名称将访问函数指针，而不是执行函数。此时，anotherSum 和sum 都指向同一个函数，这意味着可以调用anotherSum() 并且返回结果，当sum 设置为null的时候，它切断了与函数之间的关系，尽管仍然可以毫无问题的调用anotherSum()<br>ES6中所有的函数对象都暴露一个只读name 属性用来描述该函数。在许多情况下，这仅仅是函数标识符或引用该函数的字符串变量名称。如果函数没有命名，则这样报告。如果使用函数构造函数创建，则会被成为匿名。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="keyword">let</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo.name);               <span class="comment">// foo </span></span><br><span class="line"><span class="built_in">console</span>.log(bar.name);               <span class="comment">// bar </span></span><br><span class="line"><span class="built_in">console</span>.log(baz.name);               <span class="comment">// baz </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;&#125;).name);        <span class="comment">// (empty string) </span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name);  <span class="comment">// anonymous</span></span><br></pre></td></tr></table></figure>
如果函数是getter,setter 或使用bind() 实例化的，则将在前缀之前加上前缀以进行标识。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo.bind(<span class="literal">null</span>).name);    <span class="comment">// bound foo</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> dog = &#123;  </span><br><span class="line">    years: <span class="number">1</span>,  </span><br><span class="line">    <span class="keyword">get</span> age() &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.years;  &#125;,  </span><br><span class="line">    <span class="keyword">set</span> age(newAge) &#123;    </span><br><span class="line">        <span class="keyword">this</span>.years = newAge;  &#125; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(dog, <span class="string">'age'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.get.name);  <span class="comment">// get age </span></span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.set.name);  <span class="comment">// set age</span></span><br></pre></td></tr></table></figure>
<h2 id="Understanding-Arguments-理解参数"><a href="#Understanding-Arguments-理解参数" target="_blank" rel="noopener" class="headerlink" title="Understanding Arguments  理解参数"></a>Understanding Arguments  理解参数</h2>JS 函数不在乎传入了多少个参数，也不在乎这些参数的数据类型，仅仅因为您定义了一个接受两个参数的函数，并不意味着您只能传递连个参数，您可以输入1或者3 ， 或者不输入也没有关系。<br>之所以输出，是因为JS 中的参数在内部表示为数组。数组始终传递给函数，但函数并不关心数组中的内容，如果有。 如果数组传递0项，也没关系，如果传递更多，也没关系。世纪上，当时用function关键字（意味着非箭头函数） 定义函数的时候，实际上存在一个arguments 对象 ，可以在函数内部访问该arguments 对象以检索传入的每个参数的值。<br>arguments 对象的行为就像是一个数组（尽管他不是Array的一个实例），因为您可以使用方括号表示法访问每个参数（第一个参数是arguments[0],第二个是arguments[1]，依次类推）并通过使用length 属性来确定传入了多少个参数<br>在下面的示例中， sayHi()函数的第一个参数 名为name<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + name + <span class="string">", "</span> + message); &#125;</span><br></pre></td></tr></table></figure>
可以通过arguments[0] 访问相同的值，因此可以在不显示命名参数的情况下重写 函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="string">", "</span> + <span class="built_in">arguments</span>[<span class="number">1</span>]); &#125;</span><br></pre></td></tr></table></figure>
在此重写的版本中，没有命名参数。name 和 <h3 id="Arguments-in-Arrow-Functions"><a href="#Arguments-in-Arrow-Functions" target="_blank" rel="noopener" class="headerlink" title="Arguments in Arrow Functions"></a>Arguments in Arrow Functions</h3><h2 id="no-overloading"><a href="#no-overloading" target="_blank" rel="noopener" class="headerlink" title="no overloading"></a>no overloading</h2><h2 id="Default-Parameter-Values"><a href="#Default-Parameter-Values" target="_blank" rel="noopener" class="headerlink" title="Default Parameter Values"></a>Default Parameter Values</h2><h3 id="Default-Parameter-Scope-and-Temporal-Dead-Zone"><a href="#Default-Parameter-Scope-and-Temporal-Dead-Zone" target="_blank" rel="noopener" class="headerlink" title="Default Parameter Scope and Temporal Dead Zone"></a>Default Parameter Scope and Temporal Dead Zone</h3><h2 id="Spread-Arguments-and-Rest-Parameters"><a href="#Spread-Arguments-and-Rest-Parameters" target="_blank" rel="noopener" class="headerlink" title="Spread Arguments and Rest Parameters"></a>Spread Arguments and Rest Parameters</h2><h3 id="Spread-Arguments"><a href="#Spread-Arguments" target="_blank" rel="noopener" class="headerlink" title="Spread Arguments"></a>Spread Arguments</h3><h3 id="Rest-Parameter"><a href="#Rest-Parameter" target="_blank" rel="noopener" class="headerlink" title="Rest Parameter"></a>Rest Parameter</h3><h2 id="Function-Declarations-versus-Function-Expressions"><a href="#Function-Declarations-versus-Function-Expressions" target="_blank" rel="noopener" class="headerlink" title="Function Declarations versus Function Expressions"></a>Function Declarations versus Function Expressions</h2><h2 id="Functions-as-Values"><a href="#Functions-as-Values" target="_blank" rel="noopener" class="headerlink" title="Functions as Values"></a>Functions as Values</h2><h2 id="Function-Internals"><a href="#Function-Internals" target="_blank" rel="noopener" class="headerlink" title="Function Internals"></a>Function Internals</h2><h3 id="arguments"><a href="#arguments" target="_blank" rel="noopener" class="headerlink" title="arguments"></a>arguments</h3><h3 id="this"><a href="#this" target="_blank" rel="noopener" class="headerlink" title="this"></a>this</h3><h3 id="caller"><a href="#caller" target="_blank" rel="noopener" class="headerlink" title="caller"></a>caller</h3><h3 id="new-target"><a href="#new-target" target="_blank" rel="noopener" class="headerlink" title="new.target"></a>new.target</h3><h2 id="Function-Properties-and-Methods"><a href="#Function-Properties-and-Methods" target="_blank" rel="noopener" class="headerlink" title="Function Properties and Methods"></a>Function Properties and Methods</h2><h2 id="Function-Expressions"><a href="#Function-Expressions" target="_blank" rel="noopener" class="headerlink" title="Function Expressions"></a>Function Expressions</h2><h2 id="Recursion"><a href="#Recursion" target="_blank" rel="noopener" class="headerlink" title="Recursion"></a>Recursion</h2><h2 id="Tail-Call-optimization"><a href="#Tail-Call-optimization" target="_blank" rel="noopener" class="headerlink" title="Tail Call optimization"></a>Tail Call optimization</h2><h3 id="Tail-Call-Optimization-Requirements"><a href="#Tail-Call-Optimization-Requirements" target="_blank" rel="noopener" class="headerlink" title="Tail Call Optimization Requirements"></a>Tail Call Optimization Requirements</h3><h3 id="Coding-for-Tail-Call-Optimization"><a href="#Coding-for-Tail-Call-Optimization" target="_blank" rel="noopener" class="headerlink" title="Coding for Tail Call Optimization"></a>Coding for Tail Call Optimization</h3><h2 id="Closures"><a href="#Closures" target="_blank" rel="noopener" class="headerlink" title="Closures"></a>Closures</h2><h3 id="The-this-Object"><a href="#The-this-Object" target="_blank" rel="noopener" class="headerlink" title="The this Object"></a>The this Object</h3><h3 id="Memory-Leaks"><a href="#Memory-Leaks" target="_blank" rel="noopener" class="headerlink" title="Memory Leaks"></a>Memory Leaks</h3><h2 id="Immediately-Invoked-Function-Expressions"><a href="#Immediately-Invoked-Function-Expressions" target="_blank" rel="noopener" class="headerlink" title="Immediately Invoked Function Expressions"></a>Immediately Invoked Function Expressions</h2><h2 id="Private-Variables"><a href="#Private-Variables" target="_blank" rel="noopener" class="headerlink" title="Private Variables"></a>Private Variables</h2><h3 id="Static-Private-Variables"><a href="#Static-Private-Variables" target="_blank" rel="noopener" class="headerlink" title="Static Private Variables"></a>Static Private Variables</h3><h3 id="The-Module-Pattern"><a href="#The-Module-Pattern" target="_blank" rel="noopener" class="headerlink" title="The Module Pattern"></a>The Module Pattern</h3><h3 id="The-Module-Augmentation-Pattern"><a href="#The-Module-Augmentation-Pattern" target="_blank" rel="noopener" class="headerlink" title="The Module-Augmentation Pattern"></a>The Module-Augmentation Pattern</h3></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Luxin Z</p>
              <p class="site-description motion-element" itemprop="description">用于分享读书笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/" target="_blank" rel="noopener">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luxin Z</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
