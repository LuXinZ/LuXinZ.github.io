<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="用于分享读书笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="用于分享读书笔记">
<meta property="og:locale" content="zh">
<meta property="article:author" content="Luxin Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="LuXinZ.github.io/"/>





  <title>个人博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" target="_blank"  class="brand" rel="start noopener">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每日笔记</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" target="_blank" rel="section noopener">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" target="_blank" rel="section noopener">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/21/展开(spread )运算符和 剩余(Rest) 运算符有什么区别？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/21/展开(spread )运算符和 剩余(Rest) 运算符有什么区别？/" target="_blank" rel="noopener" itemprop="url">展开(spread )运算符和 剩余(Rest) 运算符有什么区别？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-21T17:11:51+08:00">
                2020-02-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="展开-spread-运算符和-剩余-Rest-运算符有什么区别？"><a href="#展开-spread-运算符和-剩余-Rest-运算符有什么区别？" target="_blank" rel="noopener" class="headerlink" title="展开(spread )运算符和 剩余(Rest) 运算符有什么区别？"></a>展开(spread )运算符和 剩余(Rest) 运算符有什么区别？</h1><p>展开运算符（spread） 是三个点… ， 可以将一个数组专为逗号分隔的参数序列，把一个大元素给打散成一个个单独的小元素<br>剩余运算符也是 三个… 它的样子看起来和展开运算符一样，但是它用于解构数组和对象。在某种程度上，剩余元素和展开元素相反，展开元素会展开数组变成多个元素，剩余元素会收集多个元素和压缩成一个单一的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> sum = add(...nums);</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>
<p>在本例中，我们在调用add 函数的时候使用了展开运算符，对nums 数组进行展开，所以参数a 的值是5， b的参数值是6，所以sum 是11</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...rest</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rest.deduce(<span class="function">(<span class="params">total,current</span>) =&gt;</span> total + current)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>在本例中，我们有一个add函数，它接受任意数量的参数，并将它们全部相加，然后返回总数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...others] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,]</span><br><span class="line"><span class="built_in">console</span>.log(first) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(others) <span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>这里，我们使用剩余操作符提取所有剩余的数组值，并将他们放入第一项之外的其他数组中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/21/数据结构(三)之栈结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/21/数据结构(三)之栈结构/" target="_blank" rel="noopener" itemprop="url">数据结构(三)之栈结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-21T14:25:01+08:00">
                2020-02-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="认识栈结构"><a href="#认识栈结构" target="_blank" rel="noopener" class="headerlink" title="认识栈结构"></a>认识栈结构</h1><h2 id="栈结构"><a href="#栈结构" target="_blank" rel="noopener" class="headerlink" title="栈结构"></a>栈结构</h2><ul>
<li>数组<ul>
<li>我们知道数组是一种线性结构，并且可以在数组的任意位置插入和删除数据</li>
<li>但是有时候，我们为了实现某些现实，必须对这种任意性加以限制</li>
<li>而栈和队列就是比较常见的受限的线性结构，我们先来学习栈结构</li>
</ul>
</li>
<li>栈stack , 它是一种运算受限的线性表，后进先出LIFO<ul>
<li>LIFO 表示后进入的元素，第一个弹出栈空间，类似于自助餐托盘，最后放上的托盘，往往先把拿出去使用。</li>
<li>其限制是仅允许在表的一端进行插入和删除运算，这一端被称为栈顶，相对的，把另一端称为栈底</li>
<li>向一个栈插入新元素又称作进栈，入栈 或压栈，它是把新元素放到栈顶元素的上面，使之称为新的栈顶元素</li>
<li>从一个栈删除元素又称作出栈，或退栈，它是把栈顶元素删除掉，使其相邻的元素称为新的栈顶元素<h1 id="面试题"><a href="#面试题" target="_blank" rel="noopener" class="headerlink" title="面试题"></a>面试题</h1><h1 id="栈结构实现"><a href="#栈结构实现" target="_blank" rel="noopener" class="headerlink" title="栈结构实现"></a>栈结构实现</h1><h2 id="栈的创建"><a href="#栈的创建" target="_blank" rel="noopener" class="headerlink" title="栈的创建"></a>栈的创建</h2>我们先来创建一个栈的类，用于封装栈相关的操作<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 栈的属性</span></span><br><span class="line">    <span class="keyword">var</span> items = []</span><br><span class="line">    <span class="comment">// 栈先关的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们创建了一个Stack 构造函数，用户创建栈的类。<br>在构造函数中，定义了一个变量，这个变量用于保存当前栈对象中所有的元素<br>这个变量是一个数组类型，我们之后无论是压栈操作还是出栈操作，都是从数组中添加和删除元素。<br>栈有一些相关的操作方法，通常无论是什么语言，操作都是比较类似的。<h1 id="栈的操作"><a href="#栈的操作" target="_blank" rel="noopener" class="headerlink" title="栈的操作"></a>栈的操作</h1>push(element) 添加一个新元素到栈顶位置<br>pop() 移除栈顶的元素，同时返回被移除的元素<br>peek() 返回栈顶的元素，不对栈做任何修改<br>isEmpty() 如果栈里没有任何元素就返回true, 否则返回false 。<br>clear() 移除栈里的所有元素<br>size() 返回栈里的元素个数，这个方法和数组的length 属性很类似。<br>push 方法<br>注意： 我们的实现是将最新的元素放在了数组的末尾，那么数组末尾的元素就是我们的栈顶元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压栈操作</span></span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>)</span>&#123;</span><br><span class="line">    items.push(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
pop方法<br>注意： 出栈操作应该是将栈顶的元素删除，并且返回<br>因此，我们这里直接从数组中删除最后一个元素，并且将该元素返回就可以了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出栈操作</span></span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
peek 方法<br>peek 方法是一个比较常见的方法，主要目的是看一眼栈顶的元素<br>注意： 和pop不同，peek仅仅的是瞥一眼栈顶的元素，并不需要将这个元素从栈顶弹出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peek 操作</span></span><br><span class="line"><span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[items.length <span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
isEmpty 方法<br>isEmpty 方法用户判断栈中是否有元素<br>实现起来非常简单，直接判断数组中的元素个数是为0，为0返回true，否则返回false<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断栈中的元素是否为空</span></span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.length == <span class="number">0</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
size 方法<br>size 方法是获取栈中元素的个数<br>因为我们使用的是数组来作为栈的底层实现的，所以直接获取数组的长度即可，也可以使用链表作为栈的顶层实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取栈中元素的个数</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
完整代码<br>下面给出自定义栈的完整代码<br>注意为了将属性方法放在一起，没有使用原型来封装方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 栈中的属性</span></span><br><span class="line">    <span class="keyword">var</span> items = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈相关的方法</span></span><br><span class="line">    <span class="comment">// 压栈操作</span></span><br><span class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.pop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// peek操作</span></span><br><span class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[items.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈中的元素是否为空</span></span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈中元素的个数</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈的使用"><a href="#栈的使用" target="_blank" rel="noopener" class="headerlink" title="栈的使用"></a>栈的使用</h1><h2 id="十进制转换二进制"><a href="#十进制转换二进制" target="_blank" rel="noopener" class="headerlink" title="十进制转换二进制"></a>十进制转换二进制</h2>为什么需要十进制转二进制<br>现实生活中，我们主要使用二进制<br>但在计算机科学中，二进制非常重要，因为计算机里的所有内容都是用二进制数字表示的<br>没有十进制和二进制相互沾化的能力，与计算机交流就是很款南<br>如何实现十进制转二进制<br>要把十进制转换成二进制，我们可以将该十进制数组和2整除，直到结果为0 为止<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装十进制转二进制的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec2bin</span>(<span class="params">decNumber</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">    <span class="keyword">var</span> remainder;</span><br><span class="line">    <span class="comment">// 循环除法</span></span><br><span class="line">    <span class="keyword">while</span> (decNumber &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        remainder = decNumber % <span class="number">2</span></span><br><span class="line">        decNumber = <span class="built_in">Math</span>.floor(decNumber /<span class="number">2</span> )</span><br><span class="line">        stack.push (remainder)</span><br><span class="line">    &#125;<span class="comment">// 10: 0 5 0 1 2 01 0 1 010 1 0 0101 1010</span></span><br><span class="line">    <span class="comment">// 将数据取出</span></span><br><span class="line">    <span class="keyword">var</span> binayriStrng  = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        binayriStrng  += stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binayriStrng</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/21/深入理解作用域、作用域链和闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/21/深入理解作用域、作用域链和闭包/" target="_blank" rel="noopener" itemprop="url">深入理解作用域、作用域链和闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-21T12:11:03+08:00">
                2020-02-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/20/await 及其如何工作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/20/await 及其如何工作/" target="_blank" rel="noopener" itemprop="url">await 及其如何工作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-20T23:28:03+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是async-await-及其如何工作"><a href="#什么是async-await-及其如何工作" target="_blank" rel="noopener" class="headerlink" title="什么是async/await 及其如何工作"></a>什么是async/await 及其如何工作</h1><p>async/await 是JS 中编写异步或非阻塞代码的新方法，它建立在promise 之上，让异步代码的可读性和间接性都更高<br>async/await 是js 中编写异步或者非阻塞代码的新方法，它建立在promise 之上，相对于promise和回调，它的可读性和间接性更高，但是，它是基于promise构建的，这意味着幕后使用仍然是promise<br>使用promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callApi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">'url/to/api/endpoint'</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">resp</span> =&gt;</span> resp.josn())</span><br><span class="line">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// do something with data</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// do something with err</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用async/await<br>在async/await ，我们使用 try/catch 语法来捕获异常</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">callApi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> resp = <span class="keyword">await</span> fetch(<span class="string">'url/to/api/endpoint'</span>)</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> resp.json();</span><br><span class="line">        <span class="comment">// do something with data </span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="comment">// do something with err </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： 使用async 关键声明函数会隐式返回一个promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> giveMeOne = <span class="keyword">async</span> () =&gt; <span class="number">1</span>;</span><br><span class="line">giveMeOne()</span><br><span class="line">    .then(<span class="function">(<span class="params">num</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num) <span class="comment">// logs 1</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>注意 await 关键字只能在 async function 中使用。在任何非async function的函数中使用await 关键字都会抛出错误。await 关键字在执行下一行代码之前等待右侧表达（可能是一个promise）返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> giveMeOne = <span class="keyword">async</span> () =&gt; <span class="number">1</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOne</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> num = <span class="keyword">await</span> giveMeOne();</span><br><span class="line">        <span class="built_in">console</span>.log(num)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 语法错误，无效的async 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTwo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> num1 = <span class="keyword">await</span> giveMeOne()</span><br><span class="line">        <span class="keyword">const</span> num2 = <span class="keyword">await</span> giveMeOne()</span><br><span class="line">        <span class="keyword">return</span> num1 + num2 </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> getTwo() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/20/数据结构2数组结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/20/数据结构2数组结构/" target="_blank" rel="noopener" itemprop="url">数据结构2数组结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-20T17:08:15+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组的基本使用"><a href="#数组的基本使用" target="_blank" rel="noopener" class="headerlink" title="数组的基本使用"></a>数组的基本使用</h1><h2 id="创建和初始化数组"><a href="#创建和初始化数组" target="_blank" rel="noopener" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h2><p>用JS 声明，创建和初始化数组很简单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建和初始化数组</span></span><br><span class="line"><span class="keyword">let</span> daysOfWeek = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="keyword">let</span> daysOfWeek = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">let</span> daysOfWeek = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'Sunday'</span>, <span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>,</span><br><span class="line">    <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>, <span class="string">'Saturday'</span>)</span><br></pre></td></tr></table></figure>
<p>代码解析：<br>使用new 关键字，就能简单的声明并初始化一个数组<br>用这种方式，还可以创建一个指定长度的数组<br>另外，也可以直接将数组元素作为参数传递给它的构造器。<br>用new 创建数组并不是最好的方式，如果想在JS 创建一个数组，只用中括号 [] 的形式就可以了<br>使用中括号[]  创建数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> daysOfWeek = [<span class="string">'Sunday'</span>, <span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>,</span><br><span class="line">    <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>, <span class="string">'Saturday'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="数组长度和遍历数组"><a href="#数组长度和遍历数组" target="_blank" rel="noopener" class="headerlink" title="数组长度和遍历数组"></a>数组长度和遍历数组</h2><p>如果我们希望获取数组的长度，有一个length 属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数组的长度</span></span><br><span class="line">alert(daysOfWeek.length)</span><br></pre></td></tr></table></figure>
<p>也可以通过下标值来遍历数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通for方式遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">0</span>;i &lt; daysOfWeek.length;i++)&#123;</span><br><span class="line">    alert (daysOfWeek[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过foreach 遍历数组</span></span><br><span class="line">daysWeek.foreach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line">    alert(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>求斐波那契数列的前20 个数组，并且放在数组中<br>菲波那切数列第一个数组是1 ，第二个数字也是1 ，第三项是前两项的和。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shuzu = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i&lt;<span class="number">20</span>;i++ )&#123;</span><br><span class="line">    shuzu[i] = shuzu[i<span class="number">-1</span>] + shuzu[i<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(shuzu)</span><br></pre></td></tr></table></figure>
<h1 id="数组的常见操作"><a href="#数组的常见操作" target="_blank" rel="noopener" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h1><h2 id="添加元素"><a href="#添加元素" target="_blank" rel="noopener" class="headerlink" title="添加元素"></a>添加元素</h2><p>假如我们有一个数组 numbers, 初始化为0-9</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个数组</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>添加一个元素到数组的最后位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1 </span></span><br><span class="line">numbers[numbers.length] = <span class="number">10</span></span><br><span class="line"><span class="comment">// 方式2 </span></span><br><span class="line">numbers.push(<span class="number">11</span>)</span><br><span class="line">numbers.push(<span class="number">12</span>,<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<p>在数组首位插入一个元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = numbers.length;i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">    numbers[i] = numbers[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>
<p>考虑上面的代码实现的性能怎么样呢<br>    性能并不算非常高，<br>    这也是数组和链表（在中间位置插入元素的效率比链表低）<br>当然我们在数组首位插入数据可以直接使用unshift 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过unshift 在首位插入数据</span></span><br><span class="line">number.unshift(<span class="number">-2</span>)</span><br><span class="line">number.unshift(<span class="number">-4</span>,<span class="number">-3</span>)</span><br><span class="line">alert(numbers) <span class="comment">// -4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13</span></span><br></pre></td></tr></table></figure>
<h2 id="删除元素"><a href="#删除元素" target="_blank" rel="noopener" class="headerlink" title="删除元素"></a>删除元素</h2><p>如果希望删除数组最后的元素，可以使用pop()方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除最后的元素</span></span><br><span class="line">number.pop()</span><br><span class="line">alert(numbers)<span class="comment">// -4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12</span></span><br></pre></td></tr></table></figure>
<p>如果我们希望移除首位的元素，自己实现代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;numbers.length; i++)&#123;</span><br><span class="line">    numbers[i] = numbers[i+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">number.pop()</span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>
<h2 id="任意位置"><a href="#任意位置" target="_blank" rel="noopener" class="headerlink" title="任意位置"></a>任意位置</h2><p>前面主要是在数组的开头和结尾处添加和删除数据<br>通过splice 删除数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的几个元素</span></span><br><span class="line">numbers.splice(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">alert(numbers) <span class="comment">// -4,-3,-2,-1,0,4,5,6,7,8,9,10,11,12,13</span></span><br></pre></td></tr></table></figure>
<p>上面的代码会删除索引为 5，6, 7 位置的元素<br>第一个参数表示索引起始的位置为5 （其实是第六个元素，因为索引从0开始），删除3个元素<br>如果我们希望使用splice 来插入数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入指定位置元素</span></span><br><span class="line">numbers.splice(<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">alert(numbers) <span class="comment">// -4,-3,-2,-1,0,3,2,1,4,5,6,7,8,9,10,11,12,13</span></span><br></pre></td></tr></table></figure>
<p>上面的代码会从索引为5 的位置开始插入数据，其他数据依次向后位移。<br>第一个参数依然是索引值为5（第六个位置）<br>第二个参数为0的时候表示不是删除数据，而是插入数据<br>后面今个的是在这个位置要插入的数据，可以是其他类型的。<br>如果我们希望使用splice 来修改数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改指定位置的元素</span></span><br><span class="line">numbers.splice(<span class="number">5</span>,<span class="number">3</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>)</span><br><span class="line">alert(numbers) <span class="comment">// -4,-3,-2,-1,0,a,b,c,4,5,6,7,8,9,10,11,12,13</span></span><br></pre></td></tr></table></figure>
<p>上面的代码会从索引5的卫视开始修改数据，修改多少个呢，第二个参数来确定的。<br>第一个参数依然是索引的位置为5<br>第二个参数是要将数组中多少个元素给替换掉，这里是3个，也可是2个<br>后面跟着的就是要替换的元素</p>
<h1 id="数组的其他操作"><a href="#数组的其他操作" target="_blank" rel="noopener" class="headerlink" title="数组的其他操作"></a>数组的其他操作</h1><h2 id="常见方法"><a href="#常见方法" target="_blank" rel="noopener" class="headerlink" title="常见方法"></a>常见方法</h2><p>concat 连接2个或者更多数组，并返回结果<br>every 对数组中的每一项运行给定函数，如果该函数的每一项都返回true，则返回true，否则返回false<br>filter 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组<br>forEach 对数组中每一项运行给定函数，这个方法没有返回值<br>join 将所有数组元素连接成一个字符串<br>indexOf 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1<br>lastIndexOf 返回在数组中搜索到的与给定参数相等的元素的索引里最大值<br>map 对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组<br>reverse 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个<br>slice 传入索引值，将数组里对应索引范围内的元素作为新数组返回<br>some 对数组中的每一项运行给定函数，如果任一项返回true， 则结果为true。 并且迭代结束<br>sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数<br>toString  将数组作为字符串返回<br>valueOf 和toString 类似，将数组作为字符串返回。</p>
<h2 id="数组合并"><a href="#数组合并" target="_blank" rel="noopener" class="headerlink" title="数组合并"></a>数组合并</h2><p>数组的合并非常简单，使用concat 即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的合并</span></span><br><span class="line"><span class="keyword">var</span> nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> nums2 = [<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>]</span><br><span class="line"><span class="keyword">var</span> newNums = nums1.concat(num2)</span><br><span class="line">alert(newNums) <span class="comment">// 1,2,3,100,200,300</span></span><br><span class="line"></span><br><span class="line">numNums = nums1 + nums2 </span><br><span class="line">alert(newNums) <span class="comment">// 1,2,3,100,200,300</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代方法"><a href="#迭代方法" target="_blank" rel="noopener" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>every() 方法<br>    every() 方法是将数组中每一个元素传入到一个函数中，该函数返回true/ false<br>    如果函数中每一个元素返回true, 那么结果为true ，有一个为false， 那么结果为false<br>every() 练习<br>判断一组元素中是否都包含某个字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">'abc'</span>,<span class="string">'cb'</span>,<span class="string">'mba'</span>,<span class="string">'dna'</span>]</span><br><span class="line"><span class="comment">// 判断数组的元素是否都包含a字符</span></span><br><span class="line"><span class="keyword">var</span> flag = names.every(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.indexOf(<span class="string">'a'</span>) != <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(flag)</span><br></pre></td></tr></table></figure>
<p>some() 方法<br>    some()方法是将数组中每一个元素传入到一个函数中，该函数返回true/false<br>    但是和every 不同的是，一旦有一次函数返回了true, 那么迭代就会结束，并且结果返回true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">'abc'</span>,<span class="string">'cb'</span>,<span class="string">'mba'</span>,<span class="string">'dna'</span>]</span><br><span class="line"><span class="comment">// 判断数组中是否包含有a字符的字符</span></span><br><span class="line"><span class="keyword">var</span> flag = names.some(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">    alert(t)</span><br><span class="line">    <span class="keyword">return</span> t.indexOf(<span class="string">'a'</span>) !== <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(flag)</span><br></pre></td></tr></table></figure>
<p>forEach() 方法<br>    froEach() 方法仅仅是一种快速迭代数组的方式而已<br>    该方法不需要返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'abc'</span>,<span class="string">'cb'</span>,<span class="string">'mba'</span>,<span class="string">'dna'</span>]</span><br><span class="line"><span class="comment">// forEach 的使用</span></span><br><span class="line">names.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">    alert(t)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>filter() 方法<br>    filter()方法是一种过滤的函数<br>    首先会遍历数组中每一个元素传入到函数中<br>    函数的结果返回true，俺么这个元素会被添加到最新的数组中，返回false， 则忽略该元素<br>    最终会形成一个 新的数组，该数组就是filter() 方法的返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">"abc"</span>, <span class="string">"cb"</span>, <span class="string">"mba"</span>, <span class="string">"dna"</span>]</span><br><span class="line"><span class="comment">// 获取names 中所有包含a 字符的元素、</span></span><br><span class="line"><span class="keyword">var</span> newNames= names.filter(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.indexOf(<span class="string">'a'</span>) !== <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newNames)</span><br></pre></td></tr></table></figure>
<p>map() 方法<br>    map方法提供的是一种映射函数<br>    首先会遍历数组中每一个元素传入到函数中<br>    元素会经过函数中的指令进行各种变换，生成新的元素，并且将新的元素返回<br>    最终会将返回的所有元素形成一个新的数组，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">"abc"</span>, <span class="string">"cb"</span>, <span class="string">"mba"</span>, <span class="string">"dna"</span>]</span><br><span class="line"><span class="comment">// 在names 中所有的元素后面拼接-abc</span></span><br><span class="line"><span class="keyword">var</span> newNames = names.map(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="string">'-abc'</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(newNames)</span><br></pre></td></tr></table></figure>
<p>reduce 方法<br>首先，这个方法需要的参数<br>arr.reduce(callback[,initialValue])<br>参数：<br>    callback(一个在数组中每一项上调用的函数，接受四个函数)<br>    previousValue(上一次调用回调函数的时候的返回值，或者初始值)<br>    currentValue( 当前正在处理的数组元素)<br>    currentValue(当前正在处理的数组元素)<br>    array(调用reduce()方法的数组)<br>求一个数组中数组的累加和<br>使用for 实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义数组</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">    total += number[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用forEach() 简化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">number.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">    total += t</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用reduce方法实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = numbers.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre + cur</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>pre 中每次传入的参数是不固定的，而是上次执行函数时的结果保存在了pre中<br>第一次执行，pre为0 ，cur 为1<br>第二次执行时, pre为1 (0+1, 上次函数执行的结果), cur为2<br>第三次执行时, pre为3 (1+2, 上次函数执行的结果), cur为3<br>第四次执行时, pre为6 (3+3, 上次函数执行的结果), cur为4<br>当cur为4时, 数组中的元素遍历完了, 就直接将第四次的结果, 作为reduce函数的返回值进行返回</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/20/js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/20/js/" target="_blank" rel="noopener" itemprop="url">js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-20T12:57:53+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            for (let index = 0; index < 100000; index++) {
    if (index % 1 == 0 && index % 2 == 1 && index % 3 == 0 && index % 4 == 1 && index % 5 == 1 && index % 6 == 3 && index % 7 == 0 && index % 8 == 1 && index % 9 == 0) {
        console.log(index);


    }

}
let index = 3969
if (index % 1 == 0 && index % 2 == 1 && index % 3 == 0 && index % 4 == 1 && index % 5 == 1 && index % 6 == 3 && index % 7 == 0 && index % 8 == 1 && index % 9 == 0) {
    console.log(index)
} else {
    console.log('错误');

}

let index = 3969
if (index % 1 !== 0) {
    console.log(1);

} else if (index % 2 !== 1) {
    console.log(2);

} else if (index % 3 !== 0) {
    console.log(3);
} else if (index % 4 !== 1) {
    console.log(4);
} else if (index % 5 !== 1) {
    console.log(5);
} else if (index % 6 !== 3) {
    console.log(6);
} else if (index % 7 !== 0) {
    console.log(7);
} else if (index % 8 !== 1) {
    console.log(8);
} else if(index % 9 !== 0) {
    console.log(9);
}
for (var i = 0; i <numbers.length; i++) {
    numbers[i] = number[i+1]
}
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/19/数组遍历方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/19/数组遍历方法/" target="_blank" rel="noopener" itemprop="url">数组遍历方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-19T15:55:33+08:00">
                2020-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="forEach、map、filter、find、sort、some等易错点整理"><a href="#forEach、map、filter、find、sort、some等易错点整理" target="_blank" rel="noopener" class="headerlink" title="forEach、map、filter、find、sort、some等易错点整理"></a>forEach、map、filter、find、sort、some等易错点整理</h1><h2 id="常用的解析方法"><a href="#常用的解析方法" target="_blank" rel="noopener" class="headerlink" title="常用的解析方法"></a>常用的解析方法</h2><h3 id="forEach"><a href="#forEach" target="_blank" rel="noopener" class="headerlink" title="forEach"></a>forEach</h3><h4 id="基础点"><a href="#基础点" target="_blank" rel="noopener" class="headerlink" title="基础点"></a>基础点</h4><p>forEach的使用频率很高，多用于对数组自身的改变和个元素相关统计性的计算，重要特性如下：</p>
<ul>
<li>可以改变数组自身，没有返回值</li>
<li>中途不能用常规操作跳出循环，可以用抛出异常（try/catch）的方式，但不推荐这样做。<h4 id="易错点"><a href="#易错点" target="_blank" rel="noopener" class="headerlink" title="易错点"></a>易错点</h4></li>
<li>forEach() 不一定改变自身数组，我们可以看看数组中的元素是值类型和引用类型场景下，是否都能获得改变<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">'鸣人'</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">'佐助'</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr1.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123; </span><br><span class="line">  item.age = item.age + <span class="number">1</span>&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; [&#123;name:'鸣人',age:17&#125;,&#123;name:'佐助',age:18&#125;]</span></span><br><span class="line"></span><br><span class="line">arr2.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  item = item * <span class="number">2</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; [1,2,3]</span></span><br></pre></td></tr></table></figure>
最后的结果是，arr1发生了改变，鸣人和佐助都长了一岁，arr2没有任何改变，所以可以的出结论，当数组中元素时值类型，forEach绝对不会改变数组；当时引用类型，则可以改变数组</li>
<li>不迟滞链式操作，所以一下代码是错误的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].forEach(</span><br><span class="line">   item =&gt; <span class="built_in">console</span>.log(item)</span><br><span class="line">).filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> item &gt; <span class="number">2</span> </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property 'filter' of undefined</span></span><br></pre></td></tr></table></figure>
注意这里仅仅说forEach()这个方法不支持链式调用，在调用forEach之前，前面的数组怎么链式都没问题，最后返回一个正常数组即可<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个没问题</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span> </span><br><span class="line">&#125;).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(item) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>不会在迭代之前创建数组的副本，忽略。<h3 id="map"><a href="#map" target="_blank" rel="noopener" class="headerlink" title="map"></a>map</h3>map() 功能很强大，forEach() 的一些局限性他都能解决，map即映射，也就是原数组被映射到对应新数组<h4 id="基础点-1"><a href="#基础点-1" target="_blank" rel="noopener" class="headerlink" title="基础点"></a>基础点</h4></li>
<li>新建一个数组，需要有承载对象，也意味着原始数组在调用它后不会发生变化；</li>
<li>该数组中的每个元素 都调用一个提供的函数后返回结果<h4 id="易错点-1"><a href="#易错点-1" target="_blank" rel="noopener" class="headerlink" title="易错点"></a>易错点</h4></li>
<li>创建新数组不代表不能用它改变原有数组，你用原有数组去承载就可以了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">return</span> item * <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure></li>
<li>map() 中每个元素都要执行相应的回调函数，所以必须要有return。如果你想给数组做一定的过滤处理，那map()基本上行不通<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">if</span>(item &gt; <span class="number">3</span>) <span class="keyword">return</span> item &#125;)</span><br><span class="line"><span class="comment">// =&gt; [undefined, undefined, undefined, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" target="_blank" rel="noopener" class="headerlink" title="filter"></a>filter</h3>map() 没办法做到的过滤就交给filter()去完成，也是创建一个新数组，新数组中的元素时筛选出来的符合条件的所有对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].filter(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(item &gt; <span class="number">3</span>) <span class="keyword">return</span> item </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//  =&gt; [4,5]</span></span><br></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" target="_blank" rel="noopener" class="headerlink" title="sort"></a>sort</h3>sort() 用于对数组的元素进行排序，排序顺序可以是字母或数字，并按照升序或降序<h4 id="基础点-2"><a href="#基础点-2" target="_blank" rel="noopener" class="headerlink" title="基础点"></a>基础点</h4><h5 id="默认排序按字母升序"><a href="#默认排序按字母升序" target="_blank" rel="noopener" class="headerlink" title="默认排序按字母升序"></a>默认排序按字母升序</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>].sort()</span><br><span class="line"><span class="comment">// =&gt; [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'Javascript'</span>,<span class="string">'Vue'</span>,<span class="string">'React'</span>,<span class="string">'Node'</span>,<span class="string">'Webpack'</span>].sort();</span><br><span class="line"><span class="comment">// =&gt; ["Javascript", "Node", "React", "Vue", "Webpack"]</span></span><br></pre></td></tr></table></figure>
<h4 id="易错点-2"><a href="#易错点-2" target="_blank" rel="noopener" class="headerlink" title="易错点"></a>易错点</h4></li>
<li>sort() 与map(),filter()不同，它直接改变原始数据</li>
<li>如果想要按照其他标准进行排序，就需要提供比较函数compareFunction(a,b), 数组会按照调用该函数的返回值排序，即a和b是两个将要比较的元素<ul>
<li>如果compareFunction(a,b) 小于0，则a排列到b之前</li>
<li>如果compareFunction(a,b) 等于0，则a和b的相对位置不变</li>
<li>如果compareFunction(a,b) 大于0，则b排列到a之前<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Users = [</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">'鸣人'</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">'卡卡西'</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">'自来也'</span>,<span class="attr">age</span>:<span class="number">50</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">'佐助'</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;</span><br><span class="line">];</span><br><span class="line">Users.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a.age - b.age</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; 鸣人、佐助、卡卡西、自来也</span></span><br></pre></td></tr></table></figure>
<h3 id="some"><a href="#some" target="_blank" rel="noopener" class="headerlink" title="some()"></a>some()</h3>some() 也是很好的一个方法，用于检查数组中是否有某些符合条件<h4 id="基础点-3"><a href="#基础点-3" target="_blank" rel="noopener" class="headerlink" title="基础点"></a>基础点</h4></li>
</ul>
</li>
<li>只要有一个满足即返回true，之后的不在执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">'鸣人'</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">'佐助'</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;</span><br><span class="line">].some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> item.age &gt; <span class="number">16</span> </span><br><span class="line">&#125;);</span><br><span class="line">=&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="易错点-3"><a href="#易错点-3" target="_blank" rel="noopener" class="headerlink" title="易错点"></a>易错点</h4>some () 和 every() 返回都是Boolean值，仅此而已<h3 id="every"><a href="#every" target="_blank" rel="noopener" class="headerlink" title="every()"></a>every()</h3>如果说some() 是 || 判断，那every() 就是 &amp;&amp; 判断，它用于检测数组中的每一项是否都满足条件，只有都满足了才会返回true，<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">'鸣人'</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>:<span class="string">'佐助'</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;</span><br><span class="line">].every(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> item.age &gt; <span class="number">16</span> </span><br><span class="line">&#125;);</span><br><span class="line">=&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="其他景点方法"><a href="#其他景点方法" target="_blank" rel="noopener" class="headerlink" title="其他景点方法"></a>其他景点方法</h1><h2 id="数字去重"><a href="#数字去重" target="_blank" rel="noopener" class="headerlink" title="数字去重"></a>数字去重</h2><h3 id="new-Set-的局限性"><a href="#new-Set-的局限性" target="_blank" rel="noopener" class="headerlink" title="new Set() 的局限性"></a>new Set() 的局限性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tempArr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment">// =&gt; &#123;1,2,3,4,5&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//并且已有元素是添加不进去的：</span></span><br><span class="line">tempArr.add(<span class="number">3</span>) </span><br><span class="line"><span class="comment">// =&gt; &#123;1,2,3,4,5&#125;</span></span><br><span class="line"></span><br><span class="line">tempArr.add(<span class="number">6</span>)</span><br><span class="line"><span class="comment">// =&gt; &#123;1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>
一定注意newSet() 会将结果转换成对象，但实际工作中我们很少会和元素是值类型的数组打交道，那看看元素是引用类型还行不行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">mySet.add(<span class="number">1</span>); <span class="comment">// Set(1) &#123;1&#125;</span></span><br><span class="line">mySet.add(<span class="number">5</span>); <span class="comment">// Set(2) &#123;1, 5&#125;</span></span><br><span class="line">mySet.add(<span class="number">5</span>); <span class="comment">// Set(2) &#123;1, 5&#125; 这里体现了值的唯一性</span></span><br><span class="line">mySet.add(<span class="string">'some text'</span>); </span><br><span class="line">[...mySet]</span><br><span class="line"><span class="comment">// =&gt; [1,5,'some text']</span></span><br><span class="line"></span><br><span class="line">mySet.add(&#123;<span class="attr">name</span>:<span class="string">'jay Chou'</span>,<span class="attr">age</span>:<span class="number">40</span>&#125;);</span><br><span class="line">mySet.add(&#123;<span class="attr">name</span>:<span class="string">'jay Chou'</span>,<span class="attr">age</span>:<span class="number">40</span>&#125;);</span><br><span class="line"></span><br><span class="line">[...mySet]</span><br><span class="line"><span class="comment">// =&gt; [1,5,'some text',&#123;name:'jay Chou',age:40&#125;,&#123;name:'jay Chou',age:40&#125;]</span></span><br></pre></td></tr></table></figure>
set()没发去重元素是引用对象的数组。<h3 id="uniqWith"><a href="#uniqWith" target="_blank" rel="noopener" class="headerlink" title="_.uniqWith()"></a>_.uniqWith()</h3>Lodash 是一个一致性，模块化，高性能的JS 实用工具库，它提供了一个方法 _.uniqWith()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> objects = [&#123; <span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">2</span>, <span class="string">'y'</span>: <span class="number">1</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span> &#125;];</span><br><span class="line">_.uniqWith(objects, _.isEqual);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/=&gt; [&#123; 'x': 1, 'y': 2 &#125;, &#123; 'x': 2, 'y': 1 &#125;]</span></span><br></pre></td></tr></table></figure>
其中 _.isEqual(value,other) 用于执行深比较来确定两者的值是否相等， _.uniqWith() 做去重处理<h2 id="获取数组中的指定元素"><a href="#获取数组中的指定元素" target="_blank" rel="noopener" class="headerlink" title="获取数组中的指定元素"></a>获取数组中的指定元素</h2>出于性能的考虑，不用filter() 从头遍历到尾<h3 id="findIndex"><a href="#findIndex" target="_blank" rel="noopener" class="headerlink" title="findIndex()"></a>findIndex()</h3>既然filter() 不支持中断遍历，那我们就要找一个能中断遍历的方法，我们可以使用for…of ，该方法支持中断遍历，但是该方法代码量较大，不建议使用。 我们可以使用findIndex() 帮我们先获取到所需元素的索引值，拿到索引值后。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testArr = [&#123;<span class="attr">name</span>:<span class="string">'鸣人'</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'佐助'</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'卡卡西'</span>,<span class="attr">age</span>:<span class="number">26</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> index = testArr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">return</span> item.age &gt; <span class="number">16</span> &#125;);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
或者也可以使用Loadsh提供的_.findIndex() ，通过对象属性值直接获取对应索引。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testArr = [&#123;<span class="attr">name</span>:<span class="string">'鸣人'</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'佐助'</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'卡卡西'</span>,<span class="attr">age</span>:<span class="number">26</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> index = _.findIndex(testArr, &#123;<span class="attr">name</span>:<span class="string">'佐助'</span>&#125;);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" target="_blank" rel="noopener" class="headerlink" title="find()"></a>find()</h3>find() 顾名思义，就是用来在数组中找到我们所需要的元素，并且和some() 一样，只要有一个满足即返回该元素，不会多于遍历，对性能很友善<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testArr = [&#123;<span class="attr">name</span>:<span class="string">'鸣人'</span>,<span class="attr">age</span>:<span class="number">16</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'佐助'</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'卡卡西'</span>,<span class="attr">age</span>:<span class="number">27</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'佐助'</span>,<span class="attr">age</span>:<span class="number">17</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> result = testArr.find(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="keyword">return</span> item.name == <span class="string">'佐助'</span>&#125;);</span><br><span class="line"><span class="comment">// =&gt; &#123; name:'佐助',age:17 &#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/19/数组16种常用方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/19/数组16种常用方法/" target="_blank" rel="noopener" itemprop="url">数组16种常用方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-19T14:00:28+08:00">
                2020-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="增删改（此类均改变原数组）"><a href="#增删改（此类均改变原数组）" target="_blank" rel="noopener" class="headerlink" title="增删改（此类均改变原数组）"></a>增删改（此类均改变原数组）</h1><h1 id="push"><a href="#push" target="_blank" rel="noopener" class="headerlink" title="push"></a>push</h1><p>定义： 向数组的末尾追加元素<br>@params: 追加的项（多个任意类型）<br>@return: 新增数组的长度<br>是否改变原数组： 改变<br>使用方法： ary.push(增加的项)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> res=ary.push(<span class="number">6</span>) ; ===&gt;<span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(ary); ===&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<h1 id="unshift"><a href="#unshift" target="_blank" rel="noopener" class="headerlink" title="unshift"></a>unshift</h1><p>定义： 向数组的开头追加元素<br>@params: 追加的项（多个任意类型）<br>@return : 新增数组的长度<br>是否改变原数组： 改变<br>使用方法： ary.unshift(增加的项)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res=ary.unshift(<span class="number">6</span>);==&gt;<span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(ary);===&gt;[<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h1 id="shift"><a href="#shift" target="_blank" rel="noopener" class="headerlink" title="shift"></a>shift</h1><p>定义： 删除数组开头向<br>@params : 无<br>@return ： 删除的那一项<br>是否改变原数组： 改变<br>使用方法： ary.shift()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> res = ary.shift()</span><br><span class="line"><span class="built_in">console</span>.log(ary)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h1 id="pop"><a href="#pop" target="_blank" rel="noopener" class="headerlink" title="pop"></a>pop</h1><p>定义： 删除数组的结尾项<br>@params: 无<br>@return : 删除的那一项<br>是否改变数组： 改变<br>使用方法： ary.pop()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> res = ary.pop()</span><br><span class="line"><span class="built_in">console</span>.log(ary)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h1 id="splice"><a href="#splice" target="_blank" rel="noopener" class="headerlink" title="splice"></a>splice</h1><p>实现数组的增加，删除，修改<br>@params: n,m,x<br>@return: 修改后的新数组<br>是否改变原数组： 改变<br>使用方法 ： ary.splice(n,m,x)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(ary.splice(<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>));</span><br><span class="line"><span class="built_in">console</span>.log(ary) ==&gt;[<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>【删除】返回值是一个数组，里面是删除项<br>ary.splice(0) 可以清空数组，把原始数组中的内容基于新数组储存起来<br>ary.splice(ary.length-1) 删除最后一项<br>ary.splice(0,1) 删除第一项。<br>【新增】 ary.splice(n,0,x);在索引n的前面添加了x项<br>ary.splice(ary.length,0,x) 在数组最后增加x项<br>ary.splice(0,0,x) 在数组的开头增加x项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(ary.splice(<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line"><span class="built_in">console</span>.log(ary) ==&gt;[<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>【修改】 用x替代删除的m的即可</p>
<h1 id="查询和拼接（此类均不改变原数组）"><a href="#查询和拼接（此类均不改变原数组）" target="_blank" rel="noopener" class="headerlink" title="查询和拼接（此类均不改变原数组）"></a>查询和拼接（此类均不改变原数组）</h1><h1 id="slice"><a href="#slice" target="_blank" rel="noopener" class="headerlink" title="slice"></a>slice</h1><p>实现数组的查询<br>@params: n,m // 从索引n开始，找到索引为m的地方（不包含m这一项）<br>@return ： 把找到的内容以新数组的形式返回<br>是否改变原数组：不改变<br>ary.slice(n,m)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> res=ary.slice(<span class="number">1</span>,<span class="number">3</span>);==&gt;[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>ary.slice(0) : m不写是查找至数位，相当于数组克隆，参数0可以不写。<br>如果n/m 为负数的情况<br>start  要抽取的片段的起始下表，如果是负数，则该参数规定的是从字符串的尾部开始算起，也就是说-1指字符串的最后一个字符串， -2指倒数第二个字符<br>end 紧接着要抽取的片段的结尾的下标，如果没有指定此参数，则要提取的子串包含start 到原字符串结尾的字符串，如果参数是负数，那么它规定的是从字符串的尾部开始算起的位置。<br>n&gt;m 会返回空数组<br>n,m 如果是小数，会只取小数点前的整数，无论小数点后数字是几都直接省略</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">ary.slice(<span class="number">1.3</span>,<span class="number">4.2</span>);<span class="comment">//==&gt; [8, 7, 3]</span></span><br><span class="line">ary.slice(<span class="number">1.6</span>,<span class="number">4.9</span>);<span class="comment">//==&gt;[8, 7, 3]</span></span><br><span class="line">ary.slice(<span class="number">1</span>,<span class="number">4</span>);<span class="comment">//==&gt;[8, 7, 3]</span></span><br></pre></td></tr></table></figure>
<p>如果是非有效数字，则会基于Number转换为数字，在进行截取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">ary.slice(<span class="string">"sss"</span>,<span class="string">"sss"</span>);<span class="comment">//==&gt; []</span></span><br><span class="line">ary.slice(<span class="string">"1"</span>,<span class="string">"3"</span>);<span class="comment">//==&gt; [8, 7]</span></span><br><span class="line">ary.slice(<span class="literal">false</span>,<span class="literal">true</span>);<span class="comment">//==&gt; [1]</span></span><br><span class="line">ary.slice([],[<span class="number">4</span>]);<span class="comment">//==&gt;[1, 8, 7, 3]</span></span><br><span class="line">ary.slice(&#123;&#125;,&#123;<span class="attr">a</span>:b&#125;);<span class="comment">//==&gt;Uncaught ReferenceError: b is not defined</span></span><br><span class="line">ary.slice(<span class="literal">NaN</span>,<span class="number">2</span>);<span class="comment">//==&gt; [1, 8]</span></span><br></pre></td></tr></table></figure>
<p>当n大于索引的时候，返回值为空数组，当n小于索引，m大于索引的时候，会返回从索引n开始直到数组末尾项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ary.slice(<span class="number">8</span>,<span class="number">3</span>);<span class="comment">//==&gt; []</span></span><br><span class="line">ary.slice(<span class="number">1</span>,<span class="number">8</span>);<span class="comment">//==&gt;[8, 7, 3, 6, 4]</span></span><br></pre></td></tr></table></figure>
<h1 id="concat"><a href="#concat" target="_blank" rel="noopener" class="headerlink" title="concat"></a>concat</h1><p>实现数组。合并<br>@params 拼接的项（多个任意值）<br>@return ： 拼接后的新数组<br>是否改变原数组： 不改变<br>ary.concat(拼接的内容)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary1=[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> ary2=[<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>];</span><br><span class="line"><span class="keyword">let</span> res=ary1.concat(<span class="string">"培训"</span>，ary2);</span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//==&gt;[10,20,30,"培训",40,50,60]</span></span><br></pre></td></tr></table></figure>
<p>ary.concat() 相当于数组克隆，真实项目一般不用<br>ary.concat(‘1’) 传一个值也相当于给数组末尾追加项，真实项目一般不用</p>
<h1 id="把数组转换为字符串（此类都不改变原数组）"><a href="#把数组转换为字符串（此类都不改变原数组）" target="_blank" rel="noopener" class="headerlink" title="把数组转换为字符串（此类都不改变原数组）"></a>把数组转换为字符串（此类都不改变原数组）</h1><h1 id="toString-NaN"><a href="#toString-NaN" target="_blank" rel="noopener" class="headerlink" title="toString"></a>toString</h1><p>把数组转换为字符换<br>@params 无<br>@return 转换后的字符串，每一项用逗号分隔<br>是否改变原数组： 不改变<br>ary.toString()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> res = ary.toString();</span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//==&gt;"10,20,30"</span></span><br><span class="line"><span class="built_in">console</span>.log([].toString());<span class="comment">//==&gt;""</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">12</span>].toString());<span class="comment">//==&gt;"12"</span></span><br></pre></td></tr></table></figure>
<h1 id="join"><a href="#join" target="_blank" rel="noopener" class="headerlink" title="join"></a>join</h1><p>把数组转换为字符串<br>@params : 按指定的分隔符连接<br>@return 转换后的字符串<br>不改变<br>ary.join(‘指定分隔符’)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> res= ary.join(<span class="string">'-'</span>) ; <span class="comment">// 1-2-3</span></span><br></pre></td></tr></table></figure>
<p>ary.join(‘’) // 123<br>ary.join() 未指定分隔符用逗号隔开<br>ary.join(‘+’) ==&gt;’1+2+3’<br>    console.log(eval(res));//==&gt;6 //======eval:相当于把字符串变为JS表达式（加减乘除）执行</p>
<h1 id="检测数组中是否包含某一项，该类都不改变原数组"><a href="#检测数组中是否包含某一项，该类都不改变原数组" target="_blank" rel="noopener" class="headerlink" title="检测数组中是否包含某一项，该类都不改变原数组"></a>检测数组中是否包含某一项，该类都不改变原数组</h1><h1 id="indexOf"><a href="#indexOf" target="_blank" rel="noopener" class="headerlink" title="indexOf"></a>indexOf</h1><p>检测当前项在数组中第一次出现位置的索引值<br>@params 要检索的这一项内容<br>@return 这一项出现的位置索引值（数字），如果数组中没有这一项，返回的结果是-1<br>不改变<br>ary.indexOf(检索的项)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</span><br><span class="line"><span class="built_in">console</span>.log(ary.indexOf(<span class="number">20</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>想验证ARY中是否包含’培训’</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ary.indexOf(<span class="string">'培训'</span>) ===<span class="number">-1</span>) <span class="comment">// 不包含</span></span><br><span class="line">也可以使用es6新提供的includes 方法判断</span><br><span class="line"><span class="keyword">if</span> (ary.includes(<span class="string">'培训'</span>)) <span class="comment">// 如果存在返回的是true</span></span><br></pre></td></tr></table></figure>
<h1 id="lastIndexOf"><a href="#lastIndexOf" target="_blank" rel="noopener" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h1><p>检测当前项在数组中最后一次出现位置的索引值<br>与indexOf相同</p>
<h1 id="includes"><a href="#includes" target="_blank" rel="noopener" class="headerlink" title="includes"></a>includes</h1><p>检测当前数组是否包含某项<br>@params 要检索的这一项内容<br>@return ： 布尔，true 包含，false 代表不包含<br>不改变<br>ary.includes(检索的项)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">ary.includes(<span class="number">1</span>);===&gt;<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="排序或排列（均改变原数组）"><a href="#排序或排列（均改变原数组）" target="_blank" rel="noopener" class="headerlink" title="排序或排列（均改变原数组）"></a>排序或排列（均改变原数组）</h1><h1 id="reverse"><a href="#reverse" target="_blank" rel="noopener" class="headerlink" title="reverse"></a>reverse</h1><p>把数组倒过来排序<br>@params : 无<br>@return : 排列后的新数组<br>改变<br>ary.reverse()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> res=ary.reverse();==&gt;[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(res,ary);===&gt;[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h1 id="sort"><a href="#sort" target="_blank" rel="noopener" class="headerlink" title="sort"></a>sort</h1><p>把数组按大小顺序排序<br>@params: 可以没有，也可以是函数<br>@return : 排好序后的数组<br>是否改变原数组：改变<br>ary.sort() ： sort 方法中如果不传递参数，是无法处理10以上的数字排序的<br>想要实现多位数正常排序，需要给sort传递一个函数，函数中返回a-b实现升序，返回b-a实现降序。<br>ary.sort(function(a,b){return a-b})<br>可用箭头函数表示 ary.sort((a,b) =&gt; a-b )<br>【升序】</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">11</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">ary.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;); <span class="comment">// 1,2,3,11,12</span></span><br></pre></td></tr></table></figure>
<p>【降序】</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">11</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">ary.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="遍历和映射，均不改变原数组"><a href="#遍历和映射，均不改变原数组" target="_blank" rel="noopener" class="headerlink" title="遍历和映射，均不改变原数组"></a>遍历和映射，均不改变原数组</h1><h1 id="forEach"><a href="#forEach" target="_blank" rel="noopener" class="headerlink" title="forEach"></a>forEach</h1><p>遍历数组中的每一项内容<br>@params : 回调函数<br>@return ： 无/ undefined<br>ary.forEach(function(item,index){alert(item)})</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> res=ary.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">    alert(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>,log(res)</span><br></pre></td></tr></table></figure>
<p>ary.forEach((item,index) =&gt;{console.log(‘索引’+index+’内容’+item)})</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ary.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//数组中有多少项，函数就会被默认执行多少次</span></span><br><span class="line"><span class="comment">//每一次执行函数：item是数组中当前要操作的这一项，index是当前项的索引</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'索引：'</span>+index+<span class="string">'内容：'</span>+item)；</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>基于原生JS 中的循环实现for(let i =0;i&lt;ary.length;i++){console.log(‘索引’+i+’内容’+ary[i])}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（<span class="keyword">let</span> i = <span class="number">0</span>；i&lt;ary.length;i++）&#123;</span><br><span class="line"><span class="comment">//i:当前循环这一项的索引</span></span><br><span class="line"><span class="comment">//ary[i]:根据索引获取循环的一项</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'索引：'</span>+i+<span class="string">'内容：'</span>+ary[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="map"><a href="#map" target="_blank" rel="noopener" class="headerlink" title="map"></a>map</h1><p>数组映射<br>@params: 回调函数<br>@return： 映射后的新数组<br>不改变<br>ary.map(function(item,index){return ‘真棒’})</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> res=ary.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"你真棒"</span></span><br><span class="line">&#125;)</span><br><span class="line">[<span class="string">"你真棒"</span>，<span class="string">"你真棒"</span>，<span class="string">"你真棒"</span>，<span class="string">"你真棒"</span>]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/19/JS数组技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/19/JS数组技巧/" target="_blank" rel="noopener" itemprop="url">JS数组技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-19T13:02:52+08:00">
                2020-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="去重"><a href="#去重" target="_blank" rel="noopener" class="headerlink" title="去重"></a>去重</h1><p>对数组去重，在ES6的时代，有个非常快速且简单的方法，使用new Set() 以及 Array.from() 或者展开运算符(…)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"banana"</span>, “apple”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”];</span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(fruits));</span><br><span class="line"><span class="comment">// 方法2 </span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits2 = [...new <span class="built_in">Set</span>(fruits)]</span><br></pre></td></tr></table></figure>
<h1 id="替换"><a href="#替换" target="_blank" rel="noopener" class="headerlink" title="替换"></a>替换</h1><p>日常开发中经常需要替换或者删除一些指定的数据，遇到这种场景的时候一定要联想到 Array.protoType.splice 这个方法，传参的时候稍微复杂点，第一个参数是开始的索引，第二个参数是需要删除的数量，剩下就是需要添加的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [“banana”, “apple”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”];</span><br><span class="line">fruits.splice(<span class="number">0</span>,<span class="number">2</span>,<span class="string">'potato'</span>,<span class="string">'tomato'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fruits); <span class="comment">// returns [“potato”, “tomato”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”]</span></span><br></pre></td></tr></table></figure>
<h1 id="遍历数组"><a href="#遍历数组" target="_blank" rel="noopener" class="headerlink" title="遍历数组"></a>遍历数组</h1><p>平时我们使用最多的就是数组的.map 方法，其实还有一个方法也能达到一样的目的，用法比较冷门，那就是Array.from</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friends = [</span><br><span class="line">    &#123; <span class="attr">name</span>: ‘John’, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: ‘Peter’, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: ‘Mark’, <span class="attr">age</span>: <span class="number">24</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: ‘Maria’, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: ‘Monica’, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: ‘Martha’, <span class="attr">age</span>: <span class="number">19</span> &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> friendsName = <span class="built_in">Array</span>.from(friends,(&#123;name&#125;) =&gt; name);</span><br><span class="line"><span class="built_in">console</span>.log(friendsNames); <span class="comment">// returns [“John”, “Peter”, “Mark”, “Maria”, “Monica”, “Martha”]</span></span><br></pre></td></tr></table></figure>
<h1 id="清空数组"><a href="#清空数组" target="_blank" rel="noopener" class="headerlink" title="清空数组"></a>清空数组</h1><p>有时候我们需要清空一个数组，比如用户点击了清空购物车，那就是直接将length 设置成0</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [“banana”, “apple”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”];</span><br><span class="line">fruits.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fruits); <span class="comment">// returns []</span></span><br></pre></td></tr></table></figure>
<h1 id="数组转换成对象"><a href="#数组转换成对象" target="_blank" rel="noopener" class="headerlink" title="数组转换成对象"></a>数组转换成对象</h1><p>有时候需要将数组转换成对象的形式，使用.map() 一类的迭代方法能达到目的，这里还有个更快的方法，前提是你正好希望对象的key就是数组的索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [“banana”, “apple”, “orange”, “watermelon”];</span><br><span class="line"><span class="keyword">var</span> fruitsObj = &#123;...fruits&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fruitsObj); <span class="comment">// returns &#123;0: “banana”, 1: “apple”, 2: “orange”, 3: “watermelon”, 4: “apple”, 5: “orange”, 6: “grape”, 7: “apple”&#125;。</span></span><br></pre></td></tr></table></figure>
<h1 id="填充数组"><a href="#填充数组" target="_blank" rel="noopener" class="headerlink" title="填充数组"></a>填充数组</h1><p>创建数组的时候，需要给数组填充上默认值的场景，首先肯定想到的时候循环这个数组，Es6提供了更便捷.fill方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newArray); <span class="comment">// returns [“1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”]</span></span><br></pre></td></tr></table></figure>
<h1 id="合并数组"><a href="#合并数组" target="_blank" rel="noopener" class="headerlink" title="合并数组"></a>合并数组</h1><p>如何合并数组，使用.concat()。 还可以使用展开运算符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [“apple”, “banana”, “orange”];</span><br><span class="line"><span class="keyword">var</span> meat = [“poultry”, “beef”, “fish”];</span><br><span class="line"><span class="keyword">var</span> vegetables = [“potato”, “tomato”, “cucumber”];</span><br><span class="line"><span class="keyword">var</span> food = [...fruits,...meat,...vegetables];</span><br><span class="line"><span class="built_in">console</span>.log(food); <span class="comment">// [“apple”, “banana”, “orange”, “poultry”, “beef”, “fish”, “potato”, “tomato”, “cucumber”]</span></span><br></pre></td></tr></table></figure>
<h1 id="两个数组的交集"><a href="#两个数组的交集" target="_blank" rel="noopener" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1><p>下面使用ES6的简洁写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numOne = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> numTwo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> duplicatedValues = [...new <span class="built_in">Set</span>(numOne)].filter(<span class="function"><span class="params">item</span> =&gt;</span> newTow.includes(item))</span><br><span class="line"><span class="built_in">console</span>.log(duplicatedValues); <span class="comment">// returns [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<h1 id="去除假值"><a href="#去除假值" target="_blank" rel="noopener" class="headerlink" title="去除假值"></a>去除假值</h1><p>首先，熟悉一下假值（falsy values） 是什么。在JS 中假值有 false， 0， ‘’, null , NaN, undefined . 我们现在找到这些假值并将他们移除，这里使用的是.filter方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixedArr = [<span class="number">0</span>, “blue”, “”, <span class="literal">NaN</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, “white”, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> trueArr = mixedArr.filter(<span class="built_in">Boolean</span>)</span><br><span class="line"><span class="built_in">console</span>.log(trueArr); <span class="comment">// returns [“blue”, 9, true, “white”]</span></span><br></pre></td></tr></table></figure>
<h1 id="随机值"><a href="#随机值" target="_blank" rel="noopener" class="headerlink" title="随机值"></a>随机值</h1><p>从数组中获取随机的一个值，核心知识 是 随机生成一个x:x&gt;=0并且x&lt;数组的length</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [“blue”, “white”, “green”, “navy”, “pink”, “purple”, “orange”, “yellow”, “black”, “brown”];</span><br><span class="line"><span class="keyword">var</span> randomColor = colors[(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(colors.length)))]</span><br></pre></td></tr></table></figure>
<h1 id="倒序"><a href="#倒序" target="_blank" rel="noopener" class="headerlink" title="倒序"></a>倒序</h1><p>对数组进行倒序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [“blue”, “white”, “green”, “navy”, “pink”, “purple”, “orange”, “yellow”, “black”, “brown”];</span><br><span class="line"><span class="keyword">var</span> reversedColors = colors.reverse();</span><br><span class="line"><span class="comment">// 或者colors.slice().reverse()</span></span><br><span class="line"><span class="built_in">console</span>.log(reversedColors); <span class="comment">// returns [“brown”, “black”, “yellow”, “orange”, “purple”, “pink”, “navy”, “green”, “white”, “blue”]</span></span><br></pre></td></tr></table></figure>
<h1 id="lastIndexOf"><a href="#lastIndexOf" target="_blank" rel="noopener" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h1><p>查找某个元素是否存在于某个数组中，经常使用indexOf方法，尝尝忽略lastIndexOf 方法，后者会被使用的一个场景就是，某个数组中有重复的数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> lastIndex = nums.lastIndexOf(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(lastIndex); <span class="comment">// returns 9</span></span><br></pre></td></tr></table></figure>
<h1 id="求和"><a href="#求和" target="_blank" rel="noopener" class="headerlink" title="求和"></a>求和</h1><p>对数组中的所有元素进行求和，这里使用的是reduce， </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> sum = nums.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y );</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="LuXinZ.github.io2020/02/18/Promise对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luxin Z">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="2020/02/18/Promise对象/" target="_blank" rel="noopener" itemprop="url">Promise对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-18T15:16:08+08:00">
                2020-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Promise-的含义"><a href="#Promise-的含义" target="_blank" rel="noopener" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h1><p>Promise 是异步编程的一种解决访问，比传统的解决方案-回调函数和事件-更合理和更强大。<br>所谓promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的信息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。<br>Promise对象有以下两个特点</p>
<ul>
<li>对象的状态不受外接影响。promise 对象代表一个异步操作：有三种状态pending进行中，fulfilled已成功和reject 已失败。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise名字的由来，他的英语意思是承诺，表示其他手段无法更改。</li>
<li>一旦状态改变，就不会在变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending 变为rejected。 只有这两种情况发生了，状态就凝固了，不会在变了，会一直保持这个结果。这时候就成为resolved已定型。如果改变已经发生了，你在对promise对象添加回调函数，也会立即得到这个结果，这与事件event完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。<br>有了promise 对象，即可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数，此外promise对象提供统一的接口，使得控制异步操作更加容易。<br>promise也有一些缺点，首先无法取消promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，promise内部抛出的错误，不会反应到外部，第三，当处于pending状态的时候，无法得知目前进展到哪一个阶段了<br>如果某些事件不断地发生，一般来说，使用Stream模式比部署promise更好的选择。<h1 id="基本用法"><a href="#基本用法" target="_blank" rel="noopener" class="headerlink" title="基本用法"></a>基本用法</h1>ES6规定，promise对象是一个构造函数，用来生成promise实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>))</span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">//异步操作成功)&#123;</span></span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。 他们是两个函数，由JS 引擎提供，不用自己部署、<br>resolve 函数的作用是，将promise对象的状态从未完成变为成功（即从pending 变为resolved），在异步操作成功的时候调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将promise对象的状态从未完成变为失败（即从pending变为rejected)，在异步操作失败的时候调用，并将异步操作报出的错误，作为参数传递出去。<br>promise 实例生成以后，可以then方法分别制定resolved状态和rejected状态的回调函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
then 方法可以接受两个回调函数作为参数，第一个回调函数是promise对象的状态变为resolved的时候调用，第二个回调函数promise对象的状态rejected 的时候调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。<br>下面是一个Promise对象的简单例子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve,ms,<span class="string">'done'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的记过，过了指定的时间（ms参数）以后，promise实例的状态变为resolved，就会触发then 方法绑定的回调函数。<br>promise 新建后就会立即执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br></pre></td></tr></table></figure>
上面代码中 promise新建后立即执行，所以首先输出的是promise，然后then方法指定的回调函数，将在当前脚本所有同步惹怒我执行完才会执行，所以resolved 最后输出、<br>下面是异步加载图片的例子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码中，是promise包装了一个图片加载的异步操作，如果加载成功，就调用resolve方法，否则就调用reject方法。<br>下面是一个用promise对象实现的ajax操作的例子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
上面代码中getJSON 是对XMLHttpRequest 对象的封装，用于发出一个JSON数据的HTTP请求，并且返回一个promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用的时候，都带有参数。<br>如果调用resolve函数和reject函数的时候都带有参数，那么他们的参数会被传递给回调函数，reject函数的参数是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值意外，还可能是另一个Promise实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
上面的代码中，p1和p2 都是promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。<br>注意，这时p1的状态就会传递给p2，也就是说p1的状态决定了p2的状态，如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变。如果p1的状态已经是resolved或者rejected,那么p2的回调函数将会立即执行。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>
上面代码中，p1是一个Promise,3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1.由于p2返回的是另一个Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对p1，又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。<br>注意，调用resolve或者reject并不会终结Promise的参数函数的执行。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来，这是因为立即resolved的promise 是在本轮时间循环的末尾执行，总是晚于本轮循环的同步任务。<br>一般来说，调用resolve或者reject以后，promise的使命完成了，后续操作应该放到then方法里面，而不应该直接写resolve或者reject的后面。所以最好在他们前面加上return 语句，这样就不会有意外。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" target="_blank" rel="noopener" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1>Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype 上的。它的作用是为了Promise实例添加状态改变时候的回调函数。前面说过，then方法的第一个参数resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数<br>then 方法返回的是一个新的Promise实例，（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面在调用另外一个then方法。、<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
上面的代码使用then方法，一次指定了两个回调函数，第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。<br>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个promise对象（即由异步操作），这时候一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。<br>如果采用箭头函数，上面的代码可以写的更简洁<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" target="_blank" rel="noopener" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h1>Promise.prototype.catch()方法是.then(null,rejection) 或者.then(undefined,rejection)的别名，用于指定发生错误时候的回调函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
上面代码中，getJSON方法返回一个promise对象，如果该对象状态变为resolved， 则会调用then方法指定的回调函数，如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</span><br></pre></td></tr></table></figure>
下面是一个例子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure>
上面代码中，promise抛出一个错误，就被catch 方法指定的回调函数捕获，请注意，上面的写法与下面两种写法是等价的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。<br>如果promise状态已经变成resolved，再抛出错误是无效的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
上面代码中，promise 在resolve 语句后面，在抛出错误，不会被捕获，等于没有抛出。因为promise的状态一旦改变，就永久保持该状态，不会在变了。<br>Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获位置，也就是说，错误总是会被下一个catch语句捕获<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/1.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
上面代码中，一共有三个promise对象：一个由getJSON产生，两个由then产生，他们之中任何一个抛出的错误，都会被最后一个catch捕获。<br>一般来说，不要在then方法里面定义reject状态的回调函数（即then的第二个参数）。总是使用catch方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
上面代码中，第二个中写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近于同步的写法(try/catch)。因此，建议总是使用catch方法，而不是用then方法的第二个参数。<br>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，promise对象抛出的错误不会传递到外层代码，即不会有任何反应。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
上面代码中，someAsyncThing所产生的Promise对象，内部有语法错误，浏览器运行到这一行，会打印出错误ReferenceError: x is not defined。但是不会退出进程，终止脚本执行，2秒之后还是输出123，也就是说promise内部的错误不会影响到promise外部的代码，通俗的说法就是promise 会吃掉错误。<br>这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，node有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个时间的监听函数，可以在监听函数里面抛出错误<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
上面代码中，unhandledRejection 事件的监听函数有两个参数，第一个是错误对象，第二个是报错的Promise实例，他可以用来了解发生错误的环境信息。<br>注意node有计划在未来废除unhandledRejection事件，如果promise内部有未捕获的错误，会直接终止进程，并且进程的退出码不为0<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure>
上面的代码中promise指定在下一轮事件循环在抛出错误，到了那个时候，promise的运行已经结束了，所以这个错误是在promise函数体外抛出的，会冒泡到最外层，成了未捕获的错误。<br>一般总是建议，promise对象后面要跟catch方法，这样可以处理promise内部发生的错误。catch方法返回的是一个promise对象，因此后面还可以接着调用then方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure>
上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数，如果没有报错，则会跳过catch方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure>
上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法，此时要是then方法里面报错，就与前面catch无关了。<br>catch方法之中，还能在抛出错误<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为 y 没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br></pre></td></tr></table></figure>
上面代码中，catch 方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层，如果改写一下，结果就不一样了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure>
上面代码中，第二个catch方法用来捕获前一个catch方法抛出的错误。<h1 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" target="_blank" rel="noopener" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h1>finally 方法用于指定不管promise对象状态如何，都会执行的操作，该方式ES2018引入的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>
上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。<br>下面是一个例子，服务器使用promise处理请求，然后使用finally方法关掉服务器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>
finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的promise状态到底是fulfilled 还是rejected。这表明finally方法里面的操作应该是与状态无关的，不依赖于promise的执行结果。<br>finally本质上是then 方法的特例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
上面代码中，如果不适用finally方法，同样的语句需要为成功和失败两种情况各写一次，有了finally方法，则只需要写一次<br>它的实现也很简单<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上面的代码中，不管前面的promise是fulfilled还是rejected ，都会执行回调函数callback<br>从上面的实现还可以看到，finally 方法总是会返回原来的值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Promise-all"><a href="#Promise-all" target="_blank" rel="noopener" class="headerlink" title="Promise.all()"></a>Promise.all()</h1>Promise.all() 方法用于将多个promise 实例，包装成一个新的promise实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
上面代码中。promise.all()方法接受一个数组作为参数，p1,p2,p3都是promise实例，如果不是，就会先调用下面降到的promise.resolve方法，将参数转换为promise实例，在进一步处理。另外，promise.all()方法的参数可以不是数组，但必须具有iterator 接口，且返回的每个成员都是promise实例。<br>p的状态由p1,p2,p3决定，分成两种情况</li>
<li>只有p1,p2,p3的状态都变成fulfilled， p的状态才会变成fulfilled ，此时p1,p2,p3的返回值组成一个数组，传递给p的回调函数</li>
<li>只要p1,p2,p3之中有一个被rejected， p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">'/post/'</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
上面代码中，promises  是包含6个promise 实例的数组，只有这6个实例的状态都变fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = connectDatabase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise</span><br><span class="line">  .then(findAllBooks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise</span><br><span class="line">  .then(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> pickTopRecommendations(books, user));</span><br></pre></td></tr></table></figure>
上面代码中， booksPromise 和userPromise 是两个异步操作，只有等到他们的结果都返回了，才会触发pickTopRecommendations这个回调函数<br>主义，如果作为参数的promise实例，自己定义了catch方法，那么它一旦被rejected， 并不会触发Promise.all()的catch方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure>
上面代码中，p1会resolved， p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个promise实例，p2指向的实际上是这个实例，该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved。因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数<br>如果P2没有自己的catch方法，就会调用Promise()的catch方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure>
<h1 id="Promise-race"><a href="#Promise-race" target="_blank" rel="noopener" class="headerlink" title="Promise.race()"></a>Promise.race()</h1>Promise.race()方法同样是将多个Promise实例，包装成一个新的promise实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
上面代码中，只要p1,p2,p3之中有一个实例率先改变状态，p的状态就跟着改变，那个率先改变的Promise实例的返回值，就传递给p的回调函数<br>Promise.race()方法的参数与Promise.all()方法一样。如果不是Promise实例，就会先调用下面降到的Promise.resolve()方法，将参数转换为Promise实例，再进一步处理<br>下面是一个例子，如果指定时间内没有获得结果，就将promise的状态变为reject，否则变为resolve<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure>
上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected， 从而出发catch方法指定的回调函数。<h1 id="Promise-allSettled"><a href="#Promise-allSettled" target="_blank" rel="noopener" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h1>Promise.allSettled() 方法接受一组Promise实例作为参数，包装成一个新的Promise实例，只有等到所有参数实例都返回结果，不管fulfilled 还是rejected ，包装实例才会结束，该方法由 ES2020引入<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  fetch(<span class="string">'/api-1'</span>),</span><br><span class="line">  fetch(<span class="string">'/api-2'</span>),</span><br><span class="line">  fetch(<span class="string">'/api-3'</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line">removeLoadingIndicator();</span><br></pre></td></tr></table></figure>
上面代码对服务器发出三个请求，等到三个请求都结束了，不管请求成功还是失败，加载的滚动图表都会消失。<br>该方法返回的新的Promise实例，一旦结束，状态总是fulfilled ，不会变成rejected。状态变成fulfilled 后，promise的监听函数接受到的参数一个数组，每个成员对应传入Promise.allSettled()的Promise实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: 'fulfilled', value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: 'rejected', reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
上面代码中,Promise.allSettled() 的返回值 allSettledPromise, 状态只可能变成fulfilled。 它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应传入promise.allSettled()的两个Promise实例，。每个对象都有status 属性，该属性的值只可讷讷个是字符串fulfilled 或者字符串 rejected。 fulfilled的时候，对象由value属性，rejected的时候有reason属性，对应两种状态的返回值。<br>下面是返回值用法的例子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [ fetch(<span class="string">'index.html'</span>), fetch(<span class="string">'https://does-not-exist/'</span>) ];</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出成功的请求</span></span><br><span class="line"><span class="keyword">const</span> successfulPromises = results.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.status === <span class="string">'fulfilled'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出失败的请求，并输出原因</span></span><br><span class="line"><span class="keyword">const</span> errors = results</span><br><span class="line">  .filter(<span class="function"><span class="params">p</span> =&gt;</span> p.status === <span class="string">'rejected'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">p</span> =&gt;</span> p.reason);</span><br></pre></td></tr></table></figure>
有时候，我们不关心异步操作的结果，之关系你这些操作有没有结束，这时候Promise.allSettled()方法就很有用，如果没有这个方法，想要确保所有操作都结束，就很玛法，Promise.all()方法无法做到这一点<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [ <span class="comment">/* ... */</span> ];</span><br><span class="line"><span class="keyword">const</span> requests = urls.map(<span class="function"><span class="params">x</span> =&gt;</span> fetch(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requests);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'所有请求都成功。'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'至少一个请求失败，其他请求可能还没结束。'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码中，Promise.all()无法确定所有请求都结束，想要达到这个目的，写起来很麻烦，有了Promise.allSettled()这就很容易了。<h1 id="Promise-any"><a href="#Promise-any" target="_blank" rel="noopener" class="headerlink" title="Promise.any()"></a>Promise.any()</h1>Promise.any()方法接受一组Promise实例作为参数，包装成一个新的Promise实例。还有参数实例有一个编程fulfilled 状态，包装实例就会变成fulfilled 状态，如果所有参数实例都变成rejected 状态，包装实例就会变成rejected状态。该方法目前是一个第三阶段的提案<br>promise.any() 跟promise.race()方法很像，只有一点不同，就是不会因为某个promise变成rejected状态而结束。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  fetch(<span class="string">'/endpoint-a'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'a'</span>),</span><br><span class="line">  fetch(<span class="string">'/endpoint-b'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'b'</span>),</span><br><span class="line">  fetch(<span class="string">'/endpoint-c'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'c'</span>),</span><br><span class="line">];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> <span class="built_in">Promise</span>.any(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(first);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码中。Promise.any()方法的参数数组包含三个Promise操作，其中只要有一个变成fulfilled， promise.any()返回的Promise对象就变成fulfilled。 如果三个操作都变成rejected，那么就会awiat 命令就会抛出错误。<br>Promise.any()抛出的错误，不是一个一般的错误，而是一个AggregateError 实例，它相当于一个数组，每个成员对应一个呗reject的操作所抛出的错误。下面是AggregateError 的实例示例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AggregateError() extends <span class="built_in">Array</span> -&gt; AggregateError</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> AggregateError();</span><br><span class="line">err.push(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"first error"</span>));</span><br><span class="line">err.push(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"second error"</span>));</span><br><span class="line"><span class="keyword">throw</span> err;</span><br></pre></td></tr></table></figure>
捕捉错误的时候，如果不用try…catch 结构和await命令可以像下面这样写<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any(promises).then(</span><br><span class="line">  (first) =&gt; &#123;</span><br><span class="line">    <span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    <span class="comment">// All of the promises were rejected.</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
下面是一个例子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">var</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">var</span> alsoRejected = <span class="built_in">Promise</span>.reject(<span class="literal">Infinity</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any([resolved, rejected, alsoRejected]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any([rejected, alsoRejected]).catch(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results); <span class="comment">// [-1, Infinity]</span></span><br></pre></td></tr></table></figure>
<h1 id="Promise-resolve"><a href="#Promise-resolve" target="_blank" rel="noopener" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1>有时候需要将对象转换为Promise对象，Promise.resolve()方法就起到这个作用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>
上面代码将JQ生成的deferred 对象，专为一个新的Promise对象<br>Promise.resolve()等价于下面的写法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure>
Promise.resolve方法的参数分成四种情况<h2 id="参数是一个Promise-实例"><a href="#参数是一个Promise-实例" target="_blank" rel="noopener" class="headerlink" title="参数是一个Promise 实例"></a>参数是一个Promise 实例</h2>如果参数是Promise实例，那么Promise.resolve 将不做任何修改，原封不动地返回这个实例。<h2 id="参数是一个tenable对象"><a href="#参数是一个tenable对象" target="_blank" rel="noopener" class="headerlink" title="参数是一个tenable对象"></a>参数是一个tenable对象</h2>thenable 对象值得是具有then方法的对象，比如下面这个对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
Promise.resolve 方法会讲这个对象转换为Promise对象，然后就立即执行thenable对象的then方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resovled, 从而立即执行最后那个then方法指定的回调函数，输出42<h2 id="参数不是具有then方法的对象，或根本就不是对象"><a href="#参数不是具有then方法的对象，或根本就不是对象" target="_blank" rel="noopener" class="headerlink" title="参数不是具有then方法的对象，或根本就不是对象"></a>参数不是具有then方法的对象，或根本就不是对象</h2>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态resolved。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
上面代码生成一个新的promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有then方法），返回Promise实例的状态从已生成就是resolved，所以回调函数会立即执行。Promise.resolve 方法的参数，会同时传给回调函数。<h2 id="不带有任何参数"><a href="#不带有任何参数" target="_blank" rel="noopener" class="headerlink" title="不带有任何参数"></a>不带有任何参数</h2>Promise.resolve()方法允许调用时不带参数，直接返回一个resolved 状态的Promise 对象<br>所以，如果希望得到一个promise对象，比较方便的方法就是调用Promise.resolve()方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
上面代码的变量p就是一个promise 对象<br>需要注意的是，立即resolve()的Promise对象，是在本轮时间循环的结束时候执行，而不是在下一轮事件循环开始的时候<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure>
上面代码中，setTimeout(fn，0)在下一轮事件循环开始的时候执行，promise.resolve()在本轮事件循环结束的时候执行，console.log(‘one’)则是立即执行，因此最先输出<h1 id="Promise-reject"><a href="#Promise-reject" target="_blank" rel="noopener" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h1>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
上面代码生成一个Promise对象的实例p,状态为rejected，回调函数会立即执行<br>主义，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的‘出错了’这个字符胡灿，而是thenable对象。<h1 id="应用"><a href="#应用" target="_blank" rel="noopener" class="headerlink" title="应用"></a>应用</h1><h2 id="加载图片"><a href="#加载图片" target="_blank" rel="noopener" class="headerlink" title="加载图片"></a>加载图片</h2>我们可以将图片的加载携程一个Promise,一旦加载完成Promise 的状态就会发生变化。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="page/2/" target="_blank" rel="noopener">2</a><a class="extend next" rel="next noopener" href="page/2/" target="_blank">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Luxin Z</p>
              <p class="site-description motion-element" itemprop="description">用于分享读书笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/" target="_blank" rel="noopener">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luxin Z</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
